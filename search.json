[
  {
    "objectID": "further-resources.html#a-growing-list-of-resources",
    "href": "further-resources.html#a-growing-list-of-resources",
    "title": "Additional resources",
    "section": "A growing list of resources!",
    "text": "NASA Earthdata: How to Cloud\nUSGS Eyes on Earth Podcast: Satellites and Cloud Computing - with Aaron Friesz (LP DAAC!)\nPO.DAAC Cloud Data Page\nPO.DAAC Earthdata Webinar (Aug 2021): Surfing Ocean Data in the Cloud - The Beginner’s Guide to PO.DAAC in the NASA Earthdata Cloud\nPO.DAAC Github Repository"
  },
  {
    "objectID": "further-resources.html#additional-tutorials",
    "href": "further-resources.html#additional-tutorials",
    "title": "Additional resources",
    "section": "Additional tutorials",
    "text": "Data_Access__Direct_S3_Access__PODAAC_ECCO_SSH using CMR-STAC API to retrieve S3 links\nDirect access to ECCO data in S3 (from us-west-2) example, with netCDF data\nDirect_S3_Access__gdalvrt\nDirect_S3_Access__rioxarray_clipping"
  },
  {
    "objectID": "clinic/github.html#what-is-github",
    "href": "clinic/github.html#what-is-github",
    "title": "",
    "section": "What is GitHub?",
    "text": "GitHub is a hosting service for Git repositories, enabling us to share code across teams in a web environment."
  },
  {
    "objectID": "clinic/github.html#why-do-i-need-a-github-account",
    "href": "clinic/github.html#why-do-i-need-a-github-account",
    "title": "",
    "section": "Why do I need a GitHub account?",
    "text": "There are three reasons you are required to have a GitHub account for the hackweek:\n\nYour GitHub accounts will give you access to the hackweek cloud computing resources\nAll hackweek tutorials will be shared on GitHub\nAll project teams will use GitHub to collaborate and work together on their code"
  },
  {
    "objectID": "clinic/github.html#creating-a-github-account",
    "href": "clinic/github.html#creating-a-github-account",
    "title": "",
    "section": "Creating a GitHub account",
    "text": "Go to GitHub.\n\n\n\ngithub-signup\n\n\nNext, enter your email address and click on the green ‘Sing up for GitHub’ button. You will need to answer a few required questions in the following dialogs. Be sure to save your password somewhere safe because you will need it later! The steps for doing this are also well documented on this GitHub help page.\n\n\n\nrepos-tab\n\n\nEach repository is a container for a specific subset of material for this event. For example, there is a repository for the public-facing website you used to register for this event {{website_url}}. We’ll also create new repositories for each project."
  },
  {
    "objectID": "clinic/index.html#welcome",
    "href": "clinic/index.html#welcome",
    "title": "Overview and Agenda",
    "section": "Welcome!",
    "text": "Thanks for being here\n\nWho instructors & helpers are, how to ask for help.\nCode of Conduct reminder: Be respectful and value each other’s ideas, styles and viewpoints.\nIf you have issues, please direct them to: Julie - lowndes @ nceas.ucsb.edu.\nLive transcripts are available.\nWe are recording this session.\n\n\n\n\n\n\n\nText to paste into Zoom Chat\n\n\n\n\n\nWelcome to the Cloud Hackathon Clinic!\nPlease go to https://openscapes.2i2c.cloud/hub/ - log in with your GitHub Account, and select “Small”\nClinic materials that we’ll cover today are here: https://nasa-openscapes.github.io/2021-Cloud-Hackathon/clinic/"
  },
  {
    "objectID": "clinic/index.html#agenda",
    "href": "clinic/index.html#agenda",
    "title": "Overview and Agenda",
    "section": "Agenda",
    "text": "The Clinic will occur in 2 halves, with a 5 minute break in-between:\n\n\n\nTime, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nWelcome\nJulie Lowndes, Openscapes\n\n\n8:05 am\nJupyterHub, repos, environments\nLuis Lopez, NSIDC\n\n\n9:00 am\nBreak\n\n\n\n9:05 am\nNotebooks, python, syncing\nMakhan Virdi, ASDC\n\n\n10:00 am\nClosing"
  },
  {
    "objectID": "clinic/index.html#before-the-clinic",
    "href": "clinic/index.html#before-the-clinic",
    "title": "Overview and Agenda",
    "section": "Before the Clinic",
    "text": "Please follow the set up prerequisites before the Clinic."
  },
  {
    "objectID": "clinic/jupyterhub.html#why-are-we-using-a-cloud-environment",
    "href": "clinic/jupyterhub.html#why-are-we-using-a-cloud-environment",
    "title": "NASA Openscapes Cloud Environment",
    "section": "Why are we using a cloud environment?",
    "text": "“Anyone working with large-scale Earth System data today faces the same general problems:\n\nThe data we want to work with are huge (typical analyses involve several TB at least)\nThe data we need are produced and distributed by many different organizations (NASA, NOAA, ESGF, Copernicus, etc.)\nWe want to apply a wide range of different analysis methodologies to the data, from simple statistics to signal processing to machine learning.\n\nThe community is waking up to the idea that we can’t simply expect scientists to download all this data to their personal computers for processing.”\nRyan Abernathey, Pangeo Project.\n\n\n\nDownload-based workflow. From Abernathey, Ryan (2020): Data Access Modes in Science"
  },
  {
    "objectID": "clinic/jupyterhub.html#openscapes-hub-and-cloud-infrastructure",
    "href": "clinic/jupyterhub.html#openscapes-hub-and-cloud-infrastructure",
    "title": "NASA Openscapes Cloud Environment",
    "section": "Openscapes Hub and Cloud Infrastructure",
    "text": "There is no cloud, it’s someone else’s computer\nGo to https://openscapes.2i2c.cloud/hub/. You will be asked to log in with your GitHub Account\n\n\n\nOpenscapes JupyterHub Login\n\n\nOnce we are logged with our Github account we need to select our server type. There are different hardware configurations for each profile, for the duration of the Hackweek we’ll use small instances, the option at the top.\n\n\n\nMachine Profiles\n\n\nAfter we select our server type and click on start, Jupyterhub will allocate our instance using Amazon Web Services (AWS). This may take several minutes. While we wait, we’ll get set up with GitHub and a brief overview.\n\n\n\nJupyterhub Spawning"
  },
  {
    "objectID": "clinic/jupyterhub.html#jupyter-ecosystem",
    "href": "clinic/jupyterhub.html#jupyter-ecosystem",
    "title": "NASA Openscapes Cloud Environment",
    "section": "Jupyter Ecosystem",
    "text": "Source: Project Pythia"
  },
  {
    "objectID": "clinic/jupyterhub.html#pythonconda-environments",
    "href": "clinic/jupyterhub.html#pythonconda-environments",
    "title": "NASA Openscapes Cloud Environment",
    "section": "Python/Conda environments",
    "text": "name: nsidc\nchannels:\n  - conda-forge\ndependencies:\n  - ipykernel\n  - awscli~=1.21.4\n  - requests\n  - pip\n\nHow do I get my code in and out of the Openscapes hub?\nWhen you start your own server you will have access to your own virtual drive space. No other users will be able to see or access your data files. You can easily upload files to your virtual drive space and save files from the hub back to another location, such as GitHub or your own local laptop drive.\nHere we’ll show you how to pull (copy) some files from GitHub into your virtual drive space using git. This will be a common task during the hackweek: at the start of each tutorial we’ll ask you to “fork” (create your own copy of in your GitHub account) and “clone” (make a copy of in a computing environment, such as your local computer or Openscapes instance) the GitHub repository corresponding to the specific tutorial being taught into your Openscapes drive space.\n\n\n\nterminal-button\n\n\nThis will open a new terminal tab in your JupyterLab interface:\n\n\n\nterminal-tab\n\n\nNow you can issue any Linux commands to manage your local file system.\nYou may also upload files from your local system using the upload button (up-pointing arrow) on the top left of the JupyterHub navigation panel. Similarly, you may download files to your local system by right-clicking the file and selecting download (down-pointing arrow).\nSimple, example GitHub/git/local-workspace workflows for getting a tutorial started in your Openscapes instance and working on a group project are provided. The getting started on a tutorial workflow briefly reviews much of the information in this preliminary exercise along with steps for making and saving notes or other changes as you work through the tutorial and keeping it updated with the original, master copy. The basic git workflow for a project serves as a reminder of the git workflow for working on a group project while minimizing code conflicts that could result from multiple people making changes to the same files simultaneously."
  },
  {
    "objectID": "clinic/jupyterhub.html#how-do-i-end-my-openscapes-session",
    "href": "clinic/jupyterhub.html#how-do-i-end-my-openscapes-session",
    "title": "NASA Openscapes Cloud Environment",
    "section": "How do I end my Openscapes session?",
    "text": "When you are finished working for the day it is important to explicitly log out of your Openscapes session. The reason for this is it will save money and is a good habit to be in. When you keep a session active it uses up AWS resources and keeps a series of virtual machines deployed.\nStopping the server happens automatically when you log out, so navigate to “File -> Log Out” and click “Log Out”!\n\n\n\nhub-control-panel-button\n\n\n\nWill I lose all of my work?\nLogging out will NOT cause any of your work to be lost or deleted. It simply shuts down some resources. It would be equivalent to turning off your desktop computer at the end of the day."
  },
  {
    "objectID": "clinic/jupyterhub.html#references",
    "href": "clinic/jupyterhub.html#references",
    "title": "NASA Openscapes Cloud Environment",
    "section": "References",
    "text": "Project Pythia\nWhy Jupyter is data scientists’ computational notebook of choice\nClosed Platforms vs. Open Architectures for Cloud-Native Earth System Analytics\nIntroduction to Geospatial Concepts\n2i2c user storage\nSnowEX Hackweek"
  },
  {
    "objectID": "clinic/jupyterhub.html#faq",
    "href": "clinic/jupyterhub.html#faq",
    "title": "NASA Openscapes Cloud Environment",
    "section": "FAQ",
    "text": "from participants during our first Clinic\nI have an empty ‘shared’ folder. That’s expected. There shouldn’t be anything in the ‘shared/’ folder\nAfter the 3 months are up, what do we do with our work on the server? You’ll have them since you can back everything up with GitHub. We can follow up with more details of what happens on the 2i2c side\nCan we use Matlab with JupyterHub? You can also use Octave kernel as a Matlab replacement. It is open source and free. If you want to integrate Matlab, there is a project to do so jupyter-matlab-proxy\nWhy do we have the same home directory as /home/jovyan? /home/jovyan is the default home directory for ‘jupyter’ based images/dockers. It is the historic home directory for Jupyter deployments.\n/home/jovyan is the default home directory for jupyter-based deployments\nCan other users see the .git-credentials file in my /home/jovyan folder? No, other users can not see your creds\nHow to exit 2i2c’s terminal text editor? esc to get to the command, and then :w to save, :q to quit."
  },
  {
    "objectID": "clinic/notebooks.html#summary",
    "href": "clinic/notebooks.html#summary",
    "title": "Notebooks, Python, Git",
    "section": "Summary",
    "text": "In this session, we will provide a brief introduction to:\n\nCommand line (terminal/shell)\nVersion Control (code management using git)\nProgramming in Python (using Jupyter Notebook)\nGeospatial Fundamentals (optional, self-study)\n\nYou will need a working knowledge of git and terminal for this hackathon. We will provide an overview of these topics and also share resources for self-paced learning."
  },
  {
    "objectID": "clinic/notebooks.html#introduction-command-line-terminalshell",
    "href": "clinic/notebooks.html#introduction-command-line-terminalshell",
    "title": "Notebooks, Python, Git",
    "section": "Introduction :: Command Line (Terminal/Shell)",
    "text": "Shell Basics\n\nWhat is Terminal or Shell?\nNavigating Files and Directories\nWorking with Files and Directories\n\n\n\nShell: More Details\nDetailed self-paced lesson on shell: Shell Lesson from Software Carpentry"
  },
  {
    "objectID": "clinic/notebooks.html#introduction-version-control-git-and-github",
    "href": "clinic/notebooks.html#introduction-version-control-git-and-github",
    "title": "Notebooks, Python, Git",
    "section": "Introduction :: Version Control (Git and Github)",
    "text": "What is version control, git, github, and how to set it up?\nVersion control is managing and tracking changes to your documents (program source code, images, websites, data files, etc.). git is a popular tool used for version control of software code. github.com is popular platform that provides remote server hosting for git repositories. A repository is a collection of various files that you are tracking for changes and versions (think of it as a directory with files that are being tracked for changes, using git for taking snapshots of versions as you are developing).\nThis section is a step-by-step guide to set up git on your 2i2c JupyterHub instance (referred to as 2i2c JupyterHub in these instruction). We will also configure git to use your github.com account for managing your repositories hosted on github.com. There are 5 main steps with substeps, includes instruction for addressing github’s new approach for token authentication.\n\n\nStep 1: Create a github account\nTo complete the setup, you will need an account on github.com. If you don’t have an account, please visit github.com, create an account (free) and come back to this guide for setting up git.\n\n\nStep 2: Fork a repository\nA fork is a copy of a repository from another github account (for example NASA-Openscapes account) to your github account (for example, my account virdi) that then you have permission to edit. To help you finish this setup correctly, we have created a demo repository on Openscapes github account named check_github_setup. You can fork this repository into your github account following these steps:\n\nLog in to your github.com account\nGo to the demo repository at NASA-Openscapes github\n\n\n\nDemo repository on NASA-Openscapes github\n\n\nClick on the fork icon in the top right corner, as shown in the image below and click your user name if prompted to do so\n\n\n\n\nStep 3: Clone the repository that you just forked\nNow you have a fork of the demo repository in your github account that we can clone it in your 2i2c instance. In the code below, commands beginning with git is a git command for version control and synching; commands that don’t start with git are bash/linux/command line commands.\n\nStart your 2i2c JupyterHub and open a terminal\nFile >> New >> Terminal\nMake sure you are in your home directory by usingpwd command and verifying the output as below\n/home/jovyan\n\nConfigure git with your name and email address.\ngit config --global user.name \"Makhan Virdi\"\ngit config --global user.email \"Makhan.Virdi@gmail.com\"\nNote: This name and email could be different from your github.com credentials. Remember git is a program that keeps track of your changes locally (on 2i2c JupyterHub or your own computer) and github.com is a platform to host your repositories. However, since your changes are tracked by git, the email/name used in git configuration will show up next to your contributions on github.com when you push your repository to github.com (git push is discussed in a later step).\nConfigure git to store your github credentials to avoid having to enter your github username and token each time you push changes to your repository(in Step 5, we will describe how to use github token instead of a password)\ngit config --global credential.helper store\nCopy link for the demo repository from your github account. Click the green “Code” button and copy the link as shown.\n\nClone the repository using git clone command in the terminal\nTo clone a repository from github, copy the link for the repository (previous step) and use git clone:\ngit clone https://github.com/YOUR-GITHUB-USERNAME/check_github_setup\nNote: Replace YOUR-GITHUB-USERNAME here with your github.com username. For example, it is virdi for my github.com account as seen in this image.\n\nUse ls (list files) to verify the existence of the repository that you just cloned\n\nChange directory to the cloned repository using cd check_github_setup and check the current directory using pwd command (present working directory)\n\nCheck status of your git repository to confirm git set up using git status\n\nYou are all set with using git on your 2i2c JupyterHub! But the collaborative power of git through github needs some additional setup.\nIn the next step, we will create a new file in this repository, track changes to this file, and link it with your github.com account.\n\n\n\nStep 4. Creating new file and tracking changes\n\nIn the left panel on your 2i2c JupyterHub, click on the “directory” icon and then double click on “check_github_setup” directory.\n\n\nOnce you are in the check_github_setup directory, create a new file using the text editor in your 2i2c JupyterHub (File >> New >> Text File).\n\nName the file lastname.txt. For example, virdi.txt for me (use your last name). Add some content to this file (for example, I added this to my virdi.txt file: my last name is virdi).\n\nNow you should have a new file (lastname.txt) in the git repository directory check_github_setup\nCheck if git can see that you have added a new file using git status. Git reports that you have a new file that is not tracked by git yet, and suggests adding that file to the git tracking system.\n\nAs seen in this image, git suggests adding that file so it can be tracked for changes. You can add file to git for tracking changes using git add. Then, you can commit changes to this file’s content using git commit as shown in the image.\ngit add virdi.txt\ngit status\ngit commit -m \"adding a new file\"\ngit status\n\nAs seen in the image above, git is suggesting to push the change that you just committed to the remote server at github.com (so that your collaborators can also see what changes you made).\nNote: DO NOT execute push yet. Before we push to github.com, let’s configure git further and store our github.com credentials to avoid entering the credentials every time we invoke git push. For doing so, we need to create a token on github.com to be used in place of your github.com password.\n\n\n\nStep 5. Create access token on github.com\n\nGo to your github account and create a new “personal access token”: https://github.com/settings/tokens/new\n\n\n\nGenerate Personal Access Token on github.com\n\n\nEnter a description in “Note” field as seen above, select “repo” checkbox, and scroll to the bottom and click the green button “Generate Token”. Once generated, copy the token (or save it in a text file for reference).\nIMPORTANT: You will see this token only once, so be sure to copy this. If you do not copy your token at this stage, you will need to generate a new token.\n\nTo push (transfer) your changes to github, use git push in terminal. It requires you to enter your github credentials. You will be prompted to enter your github username and “password”. When prompted for your “password”, DO NOT use your github password, use the github token that was copied in the previous step.\ngit push\n\nNote: When you paste your token in the terminal window, windows users will press Ctrl+V and mac os users will press Cmd+V. If it does not work, try generating another token and use the copy icon next to the token to copy the token. Then, paste using your computer’s keyboard shortcut for paste.\nNow your password is stored in ~/.git-credentials and you will not be prompted again unless the Github token expires. You can check the presence of this git-credentials file using Terminal. Here the ~ character represents your home directory (/home/jovyan/).\nls -la ~\nThe output looks like this:\ndrwxr-xr-x 13 jovyan jovyan 6144 Oct 22 17:35 .\ndrwxr-xr-x  1 root   root   4096 Oct  4 16:21 ..\n-rw-------  1 jovyan jovyan 1754 Oct 29 18:30 .bash_history\ndrwxr-xr-x  4 jovyan jovyan 6144 Oct 29 16:38 .config\n-rw-------  1 jovyan jovyan   66 Oct 22 17:35 .git-credentials\n-rw-r--r--  1 jovyan jovyan   84 Oct 22 17:14 .gitconfig\ndrwxr-xr-x 10 jovyan jovyan 6144 Oct 21 16:19 2021-Cloud-Hackathon\nYou can also verify your git configuration\n(notebook) jovyan@jupyter-virdi:~$ git config -l\nThe output should have credential.helper = store:\nuser.email        = Makhan.Virdi@gmail.com\nuser.name         = Makhan Virdi\ncredential.helper = store\n\nNow we are all set to collaborate with github on the JupyterHub during the Cloud Hackathon!\n\n\nSummary: Git Commands\n\nCommonly used git commands (modified from source)\n\n\n\n\n\n\nGit Command\nDescription\n\n\n\n\ngit status\nShows the current state of the repository: the current working branch, files in the staging area, etc.\n\n\ngit add\nAdds a new, previously untracked file to version control and marks already tracked files to be committed with the next commit\n\n\ngit commit\nSaves the current state of the repository and creates an entry in the log\n\n\ngit log\nShows the history for the repository\n\n\ngit diff\nShows content differences between commits, branches, individual files and more\n\n\ngit clone\nCopies a repository to your local environment, including all the history\n\n\ngit pull\nGets the latest changes of a previously cloned repository\n\n\ngit push\nPushes your local changes to the remote repository, sharing them with others\n\n\n\n\n\nGit: More Details\nLesson: For a more detailed self-paced lesson on git, visit Git Lesson from Software Carpentry\nCheatsheet: Frequently used git commands\nDangit, Git!?!: If you are stuck after a git mishap, there are ready-made solutions to common problems at Dangit, Git!?!\n\n\nCloning our repository using the git Jupyter lab extension.\nIf we’re already familiar with git commands and feel more confortable using a GUI our Jupyterhub deployment comes with a git extension. This plugin allows us to operate with git using a simple user interface.\nFor example we can clone our repository using the extension.\n\n\n\ngit extension"
  },
  {
    "objectID": "clinic/notebooks.html#introduction-programming-in-python",
    "href": "clinic/notebooks.html#introduction-programming-in-python",
    "title": "Notebooks, Python, Git",
    "section": "Introduction :: Programming in Python",
    "text": "Switch to Jupyter Notebook for an introduction to programming in Python\n\nVariables (and mathematical operations)\nData Structures (list, tuple, dict)\nFlow Control using loops (for, while)\nConditionals (if, else, elif)\nFunctions\nErrors and Exceptions (understanding and handling errors)\nUsing modules (libraries, packages)\n\npandas: high-performance, easy-to-use data structures and data analysis tools\nrioxarray: based on the rasterio package for working with rasters and xarray\n\n\n\nPython Learning Resources\nSelf-paced lesson on Programming with Python from Software Carpentry"
  },
  {
    "objectID": "clinic/notebooks.html#introduction-geospatial-fundamentals-optional",
    "href": "clinic/notebooks.html#introduction-geospatial-fundamentals-optional",
    "title": "Notebooks, Python, Git",
    "section": "Introduction :: Geospatial Fundamentals (Optional)",
    "text": "Detailed self-paced lesson on Fundamentals of Geospatial Raster and Vector Data with Python from Data Carpentry"
  },
  {
    "objectID": "clinic/earthdata.html#overview",
    "href": "clinic/earthdata.html#overview",
    "title": "",
    "section": "Overview",
    "text": "NASA data are stored at one of several Distributed Active Archive Centers (DAACs). If you’re interested in available data for a given area and time of interest, the Earthdata Search portal provides a convenient web interface."
  },
  {
    "objectID": "clinic/earthdata.html#why-do-i-need-an-earthdata-login",
    "href": "clinic/earthdata.html#why-do-i-need-an-earthdata-login",
    "title": "",
    "section": "Why do I need an Earthdata login?",
    "text": "Each participant will need a login. We will be teaching you ways to programmatically access NASA data from within your Python scripts. You will need to enter your Earthdata username and password in order for this to work."
  },
  {
    "objectID": "clinic/earthdata.html#getting-an-earthdata-login",
    "href": "clinic/earthdata.html#getting-an-earthdata-login",
    "title": "",
    "section": "Getting an Earthdata login",
    "text": "If you do not already have an Earthdata login, then navigate to the Earthdata Login page, a username and password, and then record this somewhere for use during the tutorials:\n\n\n\nearthdata-login"
  },
  {
    "objectID": "clinic/earthdata.html#configure-programmatic-access-to-nasa-servers",
    "href": "clinic/earthdata.html#configure-programmatic-access-to-nasa-servers",
    "title": "",
    "section": "Configure programmatic access to NASA servers",
    "text": "If you use web interfaces to retrieve nasa data such as Earthdata Search you are prompted to login. We will be using software to retrieve data from NASA Servers during the hackweek, so you must store your credentials on the JupyterHub as explained in this documentation. Run the following commands on the JupyterHub in a terminal replacing your Earthdata login username and password:\necho \"machine urs.earthdata.nasa.gov login EARTHDATA_LOGIN password EARTHDATA_PASSWORD\" > ~/.netrc\nchmod 0600 .netrc"
  },
  {
    "objectID": "logistics/github-workflows.html#first-time-setup",
    "href": "logistics/github-workflows.html#first-time-setup",
    "title": "GitHub workflows",
    "section": "First-Time Setup",
    "text": "Fork the hackathon repo\nGo to https://github.com/nasa-openscapes/2021-Cloud-Hackathon and fork the repository. This will enable you to you can edit your own copy and live-code with us\n\nNote: The term fork means that you are going to copy the project into your own user space in Github\n\n\n\n\nFork a copy\n\n\n\n\nClone your forked repo into JupyterHub\nOpen your terminal\ngit clone https://github.com/YOUR-USERNAME/2021-Cloud-Hackathon\ndon’t do all the credentials/token — they don’t need push access to follow along with the tutorials. We can help them via Slack/breakouts when/if they need to push with tokens"
  },
  {
    "objectID": "logistics/github-workflows.html#daily-setup",
    "href": "logistics/github-workflows.html#daily-setup",
    "title": "GitHub workflows",
    "section": "Daily Setup",
    "text": "GitHub: Get the latest\nThis has 2 steps:\n\nFrom github.com: Update your forked repo from main by clicking “fetch and merge””\n\n\n\nFrom the terminal in Jupyterhub: git pull\n\nhttps://openscapes.2i2c.cloud/hub/\ncd 2021-Cloud-Hackathon\ngit pull"
  },
  {
    "objectID": "logistics/github-workflows.html#git-update-revert-etc",
    "href": "logistics/github-workflows.html#git-update-revert-etc",
    "title": "GitHub workflows",
    "section": "Git: update, revert, etc",
    "text": "These are some useful commands to revert/delete your local changes and update your fork with the most recent information from the main branch.\n\nDelete your local changes\nThere are several ways to delete your local changes if you were playing around and want to reset. Here are a few:\nUndo changes you’ve maybe saved or committed, but not pushed. This is less time and internet intensive (no new clone/download).\nIf you’ve got changes saved, but not yet staged, committed, or pushed, you’ll delete unstaged changes in the working directory with clean:\ncd YOUR-REPO\ngit clean -df\ngit checkout -- .\nBurn it all down - delete the whole repo that you have locally, and then reclone.\ncd YOUR-REPO\nrm -rf YOUR-REPO\nHere is a whole blog on how to go back in time (walk back changes), with conceptual diagrams, command line code, and screenshots from RStudio. https://ohi-science.org/news/github-going-back-in-time\n\n\nUpdate local branch with remote main branch\nIf while you’re working you would like to update your local your-branch with the most recent updates on the main branch on GitHub.com, there are several ways to do this. Here’s one.\ngit checkout your-branch\ngit fetch\ngit merge origin/main\n\n\nUpdate from main"
  },
  {
    "objectID": "logistics/github-workflows.html#project-hacktime-setup",
    "href": "logistics/github-workflows.html#project-hacktime-setup",
    "title": "GitHub workflows",
    "section": "Project Hacktime Setup",
    "text": "Here are some suggestions for collaborating with your project groups (and beyond!) using GitHub.\nThis means a combination of creating a place to collaborate (a github repository) and a shared workflow to contribute.\n\nCreate a repository on GitHub.com\nJust one person does this.\nYou can do this in one of your user/organization accounts, or ask someone from the Cloud Hackathon Team to create one for you in the NASA-Openscapes organization.\nHere are instructions for creating a repo on GitHub.com — remember to make it public so that other hackathon folks can see and help!\n\n\nDiscuss edit access vs branches\nThe person who created the repo will manage the permission.\nThe simplest way to collaborate on GitHub is if everyone has permission to edit the repository directly through the main branch. Talk to your team — folks that have experience using branches can do so but others can push changes directly to the main branch.\nHere are instructions for updating github repo permissions.\n\n\nClone repo into 2i2c\nEverybody does this.\nTo to the JupyterHub, go to your Terminal, then:\ngit clone https://github.com/USERNAME/REPOSITORY-NAME.\n\n\nCheck in as you push changes\nWhether you’re using branches or not, check in with each other as you push updates to avoid merge conflicts and have the latest progress.\nHere are instructions for a workflow with branches (optional).\n\n\nUploading files from your local computer to 2i2c\nDo this using the “Upload Files” button in JupyterHub in 2i2c, the UP arrow two over from the big blue + button."
  },
  {
    "objectID": "logistics/prerequisites.html#prerequisites",
    "href": "logistics/prerequisites.html#prerequisites",
    "title": "Prerequisites & help",
    "section": "Prerequisites",
    "text": "Before the Hackathon, please do the following (20 minutes). All software is free. If you are attending the Clinic, please do this in advance of the Clinic.\n\nGitHub username\n\nCreate a GitHub account (if you don’t already have one) at https://github.com. Follow optional advice on choosing your username\nPlease provide your GitHub username here; this will allow us to add you to the cloud hackathon workspace.\nRemember your username and password; you will need to be logged in during the workshop!\n\nEarthdata Login account\n\nCreate an Earthdata Login account (if you don’t already have one) at https://urs.earthdata.nasa.gov\nRemember your username and password; you will need to be logged in during the workshop!\n\nSlack\n\nJoin our Slack workspace (invite sent via email). In the 2021-nasacloudhack-projects channel, suggest a hackathon project idea/use case, and mention if you are looking for teammates to join. Read through other entries and comment on those of interest to you. On Day one of the hackathon we will hold a project pitchfest and finalize teams for the week.\nLearn more about how we’ll use Slack during the workshop\n\nZoom\n\nBe prepared to call into Zoom using the link provided in the Slack 2021-nasacloudhack-general Channel.\n\nGet comfortable\n\nConsider your computer set-up in advance, including an external monitor if possible. You will be following along in Jupyter Hub on your own computer while also watching an instructor live-code over Zoom (or equivalent), and will also want quick-access to Slack to ask for help and follow links."
  },
  {
    "objectID": "logistics/prerequisites.html#getting-help",
    "href": "logistics/prerequisites.html#getting-help",
    "title": "Prerequisites & help",
    "section": "Getting help",
    "text": "We will use Slack rather than Zoom Chat as our main channel for help, since the conversations are preserved beyond a single call and since it’s easier to reply and have threaded conversations and post screenshots.\n\nSlack\nYou will be invited to the Openscapes Slack organization, where there is a growing community of Openscapes Champions. (New to Slack? See this Quick Start Guide). We have three private Slack channels for the Hackathon:\n2021-nasacloudhack-general: General channel is for announcements and general questions and communications.\n2021-nasacloudhack-projects: Projects channel is for for participants to pitch project ideas and discuss projects with the whole hackathon group. As teams form you can have direct messages with your team (and we can create new channels as needed).\n2021-nasacloudhack-help: Help channel is the place to get troubleshooting help: please paste error messages and post screenshots and we will help you by replying to your post.\nTo create a screenshot:\n\nOn your Mac - Screenshot\nOn your PC - Snipping Tool\n\n\n\nZoom Breakout Rooms\n\nDuring Tutorials Session\nIf you’d like to talk to someone and live-screenshare about your issue, please write in Zoom Chat that you need help and we will move you into a breakout room with a helper.\n\n\nDuring Team Hacktime\nDuring the team project time, you will be placed in a Zoom breakout room with your respective teammates to collaborate more easily. If you have questions as you work, post your question(s) in the Slack 2021-nasacloudhack-help Channel and a helper will respond in that thread. If needed, a helper can also join your team’s Zoom breakour room for easy screensharing, troubleshooting or to further discuss a question."
  },
  {
    "objectID": "logistics/schedule.html#hackathon-day-1-november-15",
    "href": "logistics/schedule.html#hackathon-day-1-november-15",
    "title": "Schedule",
    "section": "Hackathon Day 1: November 15",
    "text": "Time, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n9:00 am\nWelcome\nErin Robinson, Openscapes\n\n\n9:25 am\nCloud Paradigm Overview\nCatalina Oaida, PO.DAAC\n\n\n9:45 am\nTutorial 0: Getting set up and connected\nLuis Lopez, NSIDC and Makhan Virdi, ASDC\n\n\n10:45 am\nQ&A and Break\n\n\n\n11:00 am\nTutorial 1: Data discovery with CMR\nAndy Barrett, NSIDC\n\n\n11:30 am\nTutorial 2: Data discovery with CMR-STAC API\nAaron Friesz, LP DAAC\n\n\n12:00 pm\nQ&A and Break\n\n\n\n12:15 pm\nProjects Pitchfest\nCatalina Oaida, PO.DAAC\n\n\n12:55 pm\nClosing\nErin Robinson, Openscapes\n\n\n\n\nWelcome Day 1\nPlease see the CloudHackathon_Notes Google Doc:\n\nWelcome and Code of Conduct\nLogistics\nMeet your neighbors\n\n\n\nClosing Day 1\n\nThank you!\nJupyterHub: close out.\n\nclose out your JupyterHub instance if you are finished for the day, following these instructions.\n\nContinued work.\n\nYou’re welcome to continue working beyond the hackathon daily scheduled session, using JupyterHub and Slack. Note that questions in Slack, including 2021-nasacloudhack-help might have delayed Helper response outside of the daily scheduled cloud hackathon times.\n\nAgenda for tomorrow: what’s coming next."
  },
  {
    "objectID": "logistics/schedule.html#hackathon-day-2-november-16",
    "href": "logistics/schedule.html#hackathon-day-2-november-16",
    "title": "Schedule",
    "section": "Hackathon Day 2: November 16",
    "text": "Time, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nOptional Catch-up/help\n\n\n\n9:00 am\nWelcome\nJulie Lowndes, Openscapes\n\n\n9:15 am\nDemo: the power of Earthdata Cloud and Q&A\nMarisol Garcia Reyes, Farallon Institute\n\n\n9:35 am\nTutorial 3: Introduction to Xarray\nAndy Barrett, NSIDC\n\n\n10:30 am\nQ&A and Break\n\n\n\n10:50 am\nTutorial 4: Authentication for NASA Earthdata\nAaron Friesz, LP DAAC\n\n\n11:05 am\nTutorial 5: Direct S3 Access\nAaron Friesz, LP DAAC\n\n\n11:35 am\nTeam Hack Time\nAll\n\n\n12:55 pm\nClosing\nJulie Lowndes, Openscapes\n\n\n\n\nWelcome Day 2\nAny additional text we want.\n\nJupyterHub: Log in.\n\nLog into 2i2c at https://openscapes.2i2c.cloud/hub/. This takes a few minutes so please start this as soon we reconvene each day\n\nGitHub: Get the latest.\n\nYou’ll need to git fetch, merge, and pull: follow the github workflows daily setup.\n\n\n\n\nClosing Day 2\n\nThank you!\nJupyterHub: close out.\n\nclose out your JupyterHub instance if you are finished for the day, following these instructions.\n\nContinued work.\n\nYou’re welcome to continue working beyond the hackathon daily scheduled session, using JupyterHub and Slack. Note that questions in Slack, including 2021-nasacloudhack-help might have delayed Helper response outside of the daily scheduled cloud hackathon times.\n\nAgenda for tomorrow: what’s coming next."
  },
  {
    "objectID": "logistics/schedule.html#hackathon-day-3-november-17",
    "href": "logistics/schedule.html#hackathon-day-3-november-17",
    "title": "Schedule",
    "section": "Hackathon Day 3: November 17",
    "text": "Time, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nOptional Catch-up/help\n\n\n\n9:00 am\nWelcome\nCatalina Oaida, PO.DAAC\n\n\n9:15 am\nTutorial 6: Sentinel-6 MF L2 Altimetry Data Access (OPeNDAP) & Gridding\nJack McNelis, PO.DAAC\n\n\n9:45 am\nQ&A and Break\n\n\n\n10:00 am\nTutorial 7: Data Subsetting and Transformation Services in the Cloud\nAmy Steiker, NSIDC\n\n\n10:40 am\nQ&A and Break\n\n\n\n11:00 am\nTeam Hack Time\nAll\n\n\n12:55 pm\nClosing\nCatalina Oaida, PO.DAAC\n\n\n\n\nWelcome Day 3\n\nJupyterHub: Log in.\n\nLog into 2i2c at https://openscapes.2i2c.cloud/hub/. This takes a few minutes so please start this as soon we reconvene each day\n\nGitHub: Get the latest.\n\nYou’ll need to git fetch, merge, and pull: follow the github workflows daily setup.\n\n\n\n\nClosing Day 3\n\nThank you!\nJupyterHub: close out.\n\nclose out your JupyterHub instance if you are finished for the day, following these instructions.\n\nContinued work.\n\nYou’re welcome to continue working beyond the hackathon daily scheduled session, using JupyterHub and Slack. Note that questions in Slack, including 2021-nasacloudhack-help might have delayed Helper response outside of the daily scheduled cloud hackathon times.\n\nAgenda for tomorrow: what’s coming next."
  },
  {
    "objectID": "logistics/schedule.html#hackathon-day-4-november-18",
    "href": "logistics/schedule.html#hackathon-day-4-november-18",
    "title": "Schedule",
    "section": "Hackathon Day 4: November 18",
    "text": "Time, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nOptional Catch-up/help\n\n\n\n9:00 am\nWelcome\nErin Robinson, Openscapes\n\n\n9:15 am\nTutorial 8: EDC and on-prem DAAC hybrid use case\nAmy Steiker, NSIDC\n\n\n10:00 am\nQ&A and Break\n\n\n\n10:15 am\nTutorial 9: Access COF data vis Zarr EOSDIS Store\nPatrick Quinn, Element84\n\n\n11:00 am\nQ&A and Break\n\n\n\n11:20 am\nTeam Hack Time\nAll\n\n\n12:55 pm\nClosing\nErin Robinson, Openscapes\n\n\n\n\nWelcome Day 4\n\nJupyterHub: Log in.\n\nLog into 2i2c at https://openscapes.2i2c.cloud/hub/. This takes a few minutes so please start this as soon we reconvene each day\n\nGitHub: Get the latest.\n\nYou’ll need to git fetch, merge, and pull: follow the github workflows daily setup.\n\n\n\n\nClosing Day 4\n\nThank you!\nJupyterHub: close out.\n\nclose out your JupyterHub instance if you are finished for the day, following these instructions.\n\nContinued work.\n\nYou’re welcome to continue working beyond the hackathon daily scheduled session, using JupyterHub and Slack. Note that questions in Slack, including 2021-nasacloudhack-help might have delayed Helper response outside of the daily scheduled cloud hackathon times.\n\nAgenda for tomorrow: what’s coming next."
  },
  {
    "objectID": "logistics/schedule.html#hackathon-day-5-november-19",
    "href": "logistics/schedule.html#hackathon-day-5-november-19",
    "title": "Schedule",
    "section": "Hackathon Day 5: November 19",
    "text": "Time, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nOptional Catch-up/help\n\n\n\n9:00 am\nWelcome\nCatalina Oaida, PO.DAAC\n\n\n9:05 am\nTeam Hack Time\nAll\n\n\n10:00 am\nTeam Report-outs Part 1\nTeams 1-6\n\n\n11:00 am\nBreak\n\n\n\n11:15 am\nTeam Report-outs Part 2\nTeams 7-12\n\n\n12:15 pm\nSurvey\n\n\n\n12:30 pm\nWhat’s next\nJulie Lowndes, Openscapes\n\n\n12:55 pm\nClosing\nCatalina Oaida, PO.DAAC\n\n\n\n\nWelcome Day 5\n\nJupyterHub: Log in.\n\nLog into 2i2c at https://openscapes.2i2c.cloud/hub/. This takes a few minutes so please start this as soon we reconvene each day\n\nGitHub: Get the latest.\n\nYou’ll need to git fetch, merge, and pull: follow the github workflows daily setup.\n\n\n\n\nClosing Day 5\nThank you! More details upcoming"
  },
  {
    "objectID": "logistics/schedule.html#pre-hackathon-clinic-november-9",
    "href": "logistics/schedule.html#pre-hackathon-clinic-november-9",
    "title": "Schedule",
    "section": "Pre-Hackathon Clinic: November 9",
    "text": "This Clinic is optional and we will share a recording that participants can review ahead of time.\n\n\n\nTime, PST (UTC-8)\nEvent\nLeads/Instructors\n\n\n\n\n8:00 am\nWelcome\nJulie Lowndes, Openscapes\n\n\n8:05 am\nJupyterHub, repos, environments\nLuis Lopez, NSIDC\n\n\n9:00 am\nBreak\n\n\n\n9:05 am\nNotebooks, python, syncing\nMakhan Virdi, ASDC\n\n\n10:00 am\nClosing"
  },
  {
    "objectID": "logistics/for-participants-helpers.html#for-hackathon-participants",
    "href": "logistics/for-participants-helpers.html#for-hackathon-participants",
    "title": "For participants & helpers",
    "section": "For Hackathon Participants",
    "text": "Before the hackathon, please complete the prerequisites and be prepared for the daily setup and be familiar with the ways of getting help."
  },
  {
    "objectID": "logistics/for-participants-helpers.html#for-hackathon-helpers---a-mentors-guide",
    "href": "logistics/for-participants-helpers.html#for-hackathon-helpers---a-mentors-guide",
    "title": "For participants & helpers",
    "section": "For Hackathon Helpers - A Mentor’s Guide",
    "text": "Mentor = trainer = helper = any DAAC or Openscapes staff\n\nSlack\nChannels in Openscapes workspace\nUpdate your Slack name temporarily to include “helper”, e.g. Catalina Oaida (Helper)\n\nMentors’/Helper channel - #nasa-daac-mentors1\n\nOur back channel to coordinate amongst ourselves\n\nGeneral channel - #2021-nasacloudhack-general\n\nAnnouncements, general questions and communications\n\nPitchfest channel - #2021-nasacloudhack-projects\n\nParticipants discuss project ideas\nUse slack direct message (DM) for team/project work\n\nHelp channel - #2021-nasacloudhack-help\n\nTroubleshooting, share screenshots, etc\nWhen you see a question you will reply to, please add the “eyes” emoji below so other helpers know that you are looking into it. Then please reply in-thread in Slack to help. Can tag additional helpers if you need further support.\n\n\n\n\nGithub\nHackathon repo: https://github.com/NASA-Openscapes/2021-Cloud-Hackathon; any updates to the main branch will be updated in this book (via GitHub Action).\n\ntutorials folder\ntutorials-templates folder for live coding - same as tutorials but the code is removed and only markdown remains\nParticipants will create their own repos, we can link to their projects in the cloud hackathon repo to capture the hackathon projects artifacts\nWorking with the CH repo\n\nParticipants are instructed to fork the CH repo to their own github, then clone the CH repo. This way they can push any updates or changes to the CH repo within their own version of the repo without impacting the original CH repo\nThis should be covered in Tutorial 0.\n\nWhat happens to my work on 2i2c after the 3 months?\n\nCode: push to your own Github repo\nData and analysis outputs - working on S3 solution\n\nFrom Clinic chapter: “This section is a step-by-step guide to set up git on your 2i2c instance and configure git to use your github.com account for managing your repositories hosted on github.com.” We are also looking into using Git Extension.\n\n\n\nZoom teleconference\n\nHost: Erin and Julie\nBreak-out rooms\n\nWe will set up Breakout rooms ahead of time, and have helpers ready to meet with participants. If there are many people in breakout rooms/lots of same issues, we’ll pause the tutorial and address things together\nIf a participant is stuck and needs 1:1 help, ping one of the Zoom hosts in the mentor/general channel to place you in a breakout room with participant X\n\nChat - Encourage participants to use the Slack general or help channel for questions, not the Zoom chat\n\nErin will mention this in the Welcome (logistics) session beginning of Day 1\n\n\n\n\nTutorials workflow\n\nWelcome mentor share link to CH Book during Welcome each day\nWelcome mentor to instruct participant to spin up 2i2c JupyterHub if they haven’t done so that morning already\nTutorial presenters can also role-model having the CH Book open as a tab when they teach if they want to refer to it.\nTutorial presenter will be using template notebooks based on each tutorial\nTutorial presenter will live code, and participants will follow along in their instance\nTutorial presenter screen zoom level should be 130%\n\n\n\nHelpers support during “live coding” Tutorials Demos\n\nTutorial mentor live codes, participants follow along\nAll other helpers monitor Slack help (and general) channel for questions, people being stuck\n\nWhen you see a question you will reply to, please add the “eyes” emoji below so other helpers know that you are looking into it. Then please reply in-thread in Slack to help. Can tag additional helpers if you need further support.\nIf needed, ask host to place you and participant in breakout room temporarily for easier help/support\n\nReminder: Update your Slack name temporarily to include “helper”, e.g. “Catalina Oaida (Helper)”\n\n\n\nHelper support during Team Hack Time\n\nZoom host - Place participants in breakout rooms based on their team\n\nCan collaborate in zoom breakout rooms and in their slack team DM (direct messaging)\n\nParticipants should post any team project questions in the help slack channel; screenshot are helpful\n\nParticipants can create a DM thread with their teammates for team work discussions\n\nMentors monitor the help slack channel for questions\n\nWhen you see a question you will reply to, please add the “eyes” emoji below so other helpers know that you are looking into it. Then please reply in-thread in Slack to help. Can tag additional helpers if you need further support.\nand/or ask host to be added to the team zoom breakout room\n\nMentors use the mentor slack channel if you need additional help from a colleague\n\nThey can then also be added to zoom breakout room, as needed\n\nBeyond the scheduled time for Team Hack Time, the zoom meeting will close out, but participants are welcome to continue to discuss via their DM in slack\n\nNo on-call mentor support beyond the scheduled team hack time session\nAdditional help from mentors available 8-9am Tue-Fri during optional office hours\n\n\n\n\n2i2c JupyterHub\nLog-in before we start each day: https://openscapes.2i2c.cloud/hub/"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "2021 Cloud Hackathon",
    "section": "Welcome",
    "text": "Welcome to Cloud Hackathon: Transitioning Earthdata Workflows to the Cloud, co-hosted by the NASA EOSDIS Physical Oceanography Distributed Active Archive Center (PO.DAAC), National Snow and Ice Data Center DAAC (NSIDC DAAC), Land Processes Distributed Active Archive Center (LP.DAAC), with support provided by ASDC DAAC, GES DISC, IMPACT, and NASA Openscapes.\nThe Cloud Hackathon will take place virtually from November 15-19, 2021. The event is free to attend, but an application is required. The application period (September 21 - October 12, 2021) is now closed. Those who applied will be informed of the outcome on or around October 20th, 2021."
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "2021 Cloud Hackathon",
    "section": "About",
    "text": "The Cloud Hackathon: Transitioning Earthdata Workflows to the Cloud is a virtual 5-day (4 hours per day) collaborative open science learning experience aimed at exploring, creating, and promoting effective cloud-based science and applications workflows using NASA Earthdata Cloud data, tools, and services (among others), in support of Earth science data processing and analysis in the era of big data. Its goals are to:\n\nIntroduce Earth science data users to NASA Earthdata cloud-based data products, tools and services in order to increase awareness and support transition to cloud-based science and applications workflows.\nEnable science and applications workflows in the cloud that leverage NASA Earth Observations and capabilities (services) from within the NASA Earthdata Cloud, hosted in Amazon Web Services (AWS) cloud, thus increasing NASA Earthdata data utility and meaningfulness for science and applications use cases.\nFoster community engagement utilizing Earthdata cloud tools and services in support of open science and open data.\n\nOutcome: Participants prototype their science and applications workflows (via hackathon projects) that leverage Earthdata Cloud data and services (focusing on, but not limited to, oceanography, cryosphere, hydrology and land data), which supports them in their transition to cloud-based or hybrid workflows for data processing and analysis.\nThis is an opportunity for researchers that might not yet have had the opportunity to work in the Cloud to explore, learn and prototype workflows with NASA Earthdata in the Cloud, but more intermediate or advanced cloud users interested in further exploring cloud workflows with Earthdata Cloud data and service are also welcome."
  },
  {
    "objectID": "index.html#application",
    "href": "index.html#application",
    "title": "2021 Cloud Hackathon",
    "section": "Application",
    "text": "Information for applicants\nThe Cloud Hackathon will be a virtual event held November 15-19, 2021, where participants will explore the intersection of Earth science data, cloud computing, and big data analysis through demonstration tutorials and hands-on “hacking” projects. To best benefit from the event, we recommend some familiarity or experience with:\n\nNASA Earthdata data (focusing on oceanography, cryosphere, hydrology, cryosphere and land data, including interdisciplinary applications); and\nProgramming skills using Python. We plan to accept participants with diverse skill levels and backgrounds in programming. However, to best benefit from and contribute to the program, participants are expected to have some experience with Python programming.\n\nNo cloud computing experience is required, but we encourage both beginner and more experienced participants with AWS cloud to apply.\nIf selected, participants will have the option to attend a Carpentries-style github, python, shell scripting clinic ahead of the Cloud Hachathon.\n\n\nApplication Form\nIn the application form, we encourage you to think about and provide a science use case that you would like to prototype in the cloud. At the beginning of the hackathon, participants will be able to pitch their use case to support the formation of “hack” projects - by which we mean collaboratively experiment working in with NASA Earthdata data and capabilities in the Cloud. During the hackathon, participants will get into teams of their choosing, around a common use case to “hack” in the cloud. The use cases provided in the application form will also help the organizers best prepare materials tailored to those use cases.\nThe application period has now closed. Thank you for your interest."
  },
  {
    "objectID": "index.html#what-to-expect",
    "href": "index.html#what-to-expect",
    "title": "2021 Cloud Hackathon",
    "section": "What to expect",
    "text": "During the Cloud Hackathon, the selected participants will have access to cloud environments in AWS through a JupyterHub interface, provided through 2i2c.\nParticipants will be guided on how to log into the cloud environment, import needed data recipes and resources, and will have the opportunity to explore and develop science and applications workflows in a cloud environment (hosted in AWS) using example tutorials as building blocks.\nThe Cloud Hackathon is an open science event: all tutorials and examples are developed openly and will be publicly available during and following hackathon. Participants will strengthen their practice of open science, using open source code and “hacking” their projects openly to enable further discovery and contributions by the broader open community following the hackathon.\nThroughout the hackathon, participants will learn about NASA’s Earthdata move to the cloud and Earthdata APIs for data discovery, access, and transformations to enable faster, more efficient time to science.\n\nIn the two to three weeks leading up to the hackathon, participants are encouraged to review background resources that will facilitate a more effective hackathon experience. These resources will be shared here leading up to the Hackathon dates, and will be accessible to all data users, whether they attend the hackathon or not.\nThe following datasets are currently available from the NASA Earthdata Cloud. Participants can choose to prototype a cloud-based science workflow using a combination of these datasets, as well as other non-Earthdata Cloud data. If your preferred dataset is not yet available in the Earthdata Cloud, consider using a current cloud-based dataset as proxy to explore prototyping.\n\nhttps://search.earthdata.nasa.gov/search?ff=Available%20from%20AWS%20Cloud\n\nExample use cases to explore in the cloud (note these are for inspiration only, you are not limited to these workflows):\n\nUse the advanced wildcard search capabilities in Earthdata Search Client/Common Metadata Repository (CMR) to precisely search/select all cloud-archived Sentinel-6A granules\n\nfrom a specific cycle (i.e. a sequence orbits that together provide global spatial coverage), and/or\nfrom a specific pass(es) over multiple cycles (i.e. selected orbits over a series of cycles that together provide a time series coverage).\nThen, prepare the data for gridding or for local analysis at space/time scales which are appropriate for the target analysis (and limited by default given the length of S6A data record…)\n\nTime series analysis across multi-mission measurements spanning data housed both within and outside of NASA Earthdata Cloud, to develop a workflow that can accommodate different data locations, as data continue to migrate to the Cloud:\n\nProgrammatically search for a data variable (e.g. altimetry measurements) at a single point or area of interest across multiple datasets and identify whether the data are available in the Cloud\nAcquire the data based on archived location and combine in order to produce a homogenous time series\n\nExplore/leverage cloud-optimized formats (COFs) such as Zarr to compute global or regional climatology and anomalies for a large-volume dataset (e.g. 1-km MUR SST) without having to download data (in-cloud analysis).\nSubset Level 2 swath dataset of interest spatially and for specific variable and do some exploratory analysis and visualization from within the cloud.\nUse NASA’s CMR-STAC API to search and discover Harmonized Landsat Sentinel-2 (HLS) cloud assets based on cloud data products, area of interest, and date range query parameters.\nHarmonized Landsat Sentinel-2 (HLS) for land monitoring: access, explore, and visualize time series surface reflectance data in the cloud.\n\nThis event is motivated by the dawn of the era of Big Data. NASA’s Earth Observing System Data and Information System (EOSDIS) is in the process of moving EOSDIS data to the cloud, driven by a rapid rate of data ingest into the EOSDIS archive. NASA remote sensing data from both upcoming (e.g. SWOT) and existing (e.g. Terra, Aqua, ICESat-2) missions will be available in the Earthdata Cloud platform in the coming years. The paradigm shift from on-premise (local) to cloud-based data distribution, and that from “download and analyze” to “analysis in place” present opportunities and challenges. Guiding users through this transition is of the utmost importance."
  },
  {
    "objectID": "index.html#code-of-conduct",
    "href": "index.html#code-of-conduct",
    "title": "2021 Cloud Hackathon",
    "section": "Code of Conduct",
    "text": "The 2021 Cloud Hackathon is a safe learning space and all participants are required to abide by our Code of Conduct."
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "2021 Cloud Hackathon",
    "section": "Acknowledgements",
    "text": "Cloud Hackathon: Transitioning Earthdata Workflows to the Cloud is co-hosted by NASA’s PO.DAAC, NSIDC DAAC, LP.DAAC, with support from ASDC DAAC, GES DISC and the NASA Openscapes Project, and cloud computing infrastructure by 2i2c.   \nWe thank all of the additional NASA staff that have have joined as helpers.\nThank you to the open science community that has created software, teaching resources, and workflows that we have been able to build heavily from! These include:\n\neScience Institute, University of Washington:\n\nhttps://uwhackweek.github.io/hackweeks-as-a-service/intro.html\nhttps://snowex-hackweek.github.io/website/intro.html\nhttps://icesat-2hackweek.github.io/learning-resources/"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#summary",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Hello World"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#exercise",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#exercise",
    "title": "",
    "section": "Exercise",
    "text": "Import Required Packages\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nimport os\nimport subprocess\nimport requests\nimport boto3\nfrom pystac_client import Client\nfrom collections import defaultdict\nimport numpy as np\nimport xarray as xr\nimport rasterio as rio\nfrom rasterio.session import AWSSession\nfrom rasterio.plot import show\nimport rioxarray\nimport geopandas\nimport pyproj\nfrom pyproj import Proj\nfrom shapely.ops import transform\nimport geoviews as gv\nfrom cartopy import crs\nimport hvplot.xarray\nimport holoviews as hv\ngv.extension('bokeh', 'matplotlib')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n  \n  \n\n\n\n\n\n\n\nGet Temporary Credentials and Configure Local Environment\nTo perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME.\ndef get_temp_creds():\n    temp_creds_url = 'https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials'\n    return requests.get(temp_creds_url).json()\ntemp_creds_req = get_temp_creds()\n#temp_creds_req                      # !!! BEWARE, removing the # on this line will print your temporary S3 credentials.\n\nInsert the credentials into our boto3 session and configure out rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session can then be used to pass those credentials and get S3 objects from applicable buckets.\nsession = boto3.Session(aws_access_key_id=temp_creds_req['accessKeyId'], \n                        aws_secret_access_key=temp_creds_req['secretAccessKey'],\n                        aws_session_token=temp_creds_req['sessionToken'],\n                        region_name='us-west-2')\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n\nrio_env = rio.Env(AWSSession(session),\n                  GDAL_DISABLE_READDIR_ON_OPEN='TRUE',\n                  GDAL_HTTP_COOKIEFILE=os.path.expanduser('~/cookies.txt'),\n                  GDAL_HTTP_COOKIEJAR=os.path.expanduser('~/cookies.txt'))\nrio_env.__enter__()\n\n<rasterio.env.Env at 0x7fdb42409c10>\n\n\n\n\n\nRead In and Process STAC Asset Links\nIn the previous section, we used the NASA CMR-STAC API to discover HLS assets the intersect with our search criteria, i.e., ROI, Date range, and collections. The search results were filtered and saved as text files by individual bands for each tile. We will read in the text files for tile T13TGF for the RED (L30: B04 & S30: B04), NIR (L30: B05 & S30: B8A), and Fmask bands.\n\nList text files with HLS links\n\n[t for t in os.listdir('./data') if '.txt' in t]\n\n['HTTPS_T13TGF_B02_Links.txt',\n 'S3_T13TGF_B05_Links.txt',\n 'HTTPS_T13TGF_Fmask_Links.txt',\n 'S3_T13TGF_B8A_Links.txt',\n 'HTTPS_T13TGF_B04_Links.txt',\n 'S3_T13TGF_B04_Links.txt',\n 'S3_T13TGF_Fmask_Links.txt',\n 'HTTPS_T13TGF_B8A_Links.txt',\n 'HTTPS_T13TGF_B05_Links.txt',\n 'S3_T13TGF_B02_Links.txt']\n\n\n\n\nRead in our asset links for BO4 (RED)\n\nred_s3_links = open('./data/S3_T13TGF_B04_Links.txt').read().splitlines()\nred_s3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']\n\n\n\n\nRead in and combine our asset links for BO5 (Landsat NIR) and B8A (Sentinel-2 NIR)\nThe near-infrared (NIR) band for Landsat is B05 while the NIR band for Sentinel-2 is B8A. In the next step we will read in and combine the lists into a single NIR list.\n\nnir_bands = ['B05', 'B8A']\nnir_link_text = [x for x in os.listdir('./data') if any(b in x for b in nir_bands) and 'S3' in x]\nnir_s3_links = []\nfor file in nir_link_text:\n    nir_s3_links.extend(open(f'./data/{file}').read().splitlines())\nnir_s3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B05.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B8A.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B8A.tif']\n\n\n\n\nRead in our asset links for Fmask\nfmask_s3_links = open('./data/S3_T13TGF_Fmask_Links.txt').read().splitlines()\n#fmask_s3_links\nIn this example we will use the gdalbuildvrt.exe utility to create a time series virtual raster format (VRT) file. The utility, however, expects the links to be formated with the GDAL virtual file system (VSI) path, rather than the actual asset links. We will therefore use the VSI path to access our assets. The examples below show the VSI path substitution for S3 (vsis3) links.\n/vsis3/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2020191T172901.v1.5.B04.tif\nSee the GDAL Virtual File Systems for more information regarding GDAL VSI.\n\n\nWrite out a new text file containing the vsis3 path\nwith open('./data/S3_T13TGF_RED_VSI_Links.txt', 'w') as f:\n    links_vsi = [r.replace('s3://', '/vsis3/' ) + '\\n' for r in red_s3_links]\n    for link in links_vsi:\n        f.write(link)\nwith open('./data/S3_T13TGF_NIR_VSI_Links.txt', 'w') as f:\n    links_vsi = [r.replace('s3://', '/vsis3/' ) + '\\n' for r in nir_s3_links]\n    for link in links_vsi:\n        f.write(link)\nwith open('./data/S3_T13TGF_FMASK_VSI_Links.txt', 'w') as f:\n    links_vsi = [r.replace('s3://', '/vsis3/' ) + '\\n' for r in fmask_s3_links]\n    for link in links_vsi:\n        f.write(link)\n\n\n\nRead in geoJSON for subsetting\nWe will use the input geoJSON file to clip the source data to our desired region of interest.\nfield = geopandas.read_file('./data/ne_w_agfields.geojson')\nfieldShape = field['geometry'][0]  \nTo clip the source data to our input feature boundary, we need to transform the feature boundary from its original WGS84 coordinate reference system to the projected reference system of the source HLS file (i.e., UTM Zone 13).\n\nfoa_url = red_s3_links[0]\nwith rio.open(foa_url) as src:\n    hls_proj = src.crs.to_string()\n\nhls_proj    \n\n'EPSG:32613'\n\n\n\nTransform geoJSON feature from WGS84 to UTM\ngeo_CRS = Proj('+proj=longlat +datum=WGS84 +no_defs', preserve_units=True)   # Source coordinate system of the ROI\nproject = pyproj.Transformer.from_proj(geo_CRS, hls_proj)                    # Set up the transformation\nfsUTM = transform(project.transform, fieldShape)\n\n\n\nDirect S3 Data Access\n\nStart up a dask client\n#from dask.distributed import Client\n#client = Client(n_workers=2)\n#client\nThere are multiple way to read COG data in as a time series. The subprocess package is used in this example to run GDAL’s build virtual raster file (gdalbuildvrt) executable outside our python session. First we’ll need to construct a string object with the command and it’s parameter parameters (including our temporary credentials). Then, we run the command using the subprocess.call() function.\n\n\nBuild GDAL VRT Files\n\nConstruct the GDAL VRT call\nbuild_red_vrt = f\"gdalbuildvrt ./data/red_stack.vrt -separate -input_file_list ./data/S3_T13TGF_RED_VSI_Links.txt --config AWS_ACCESS_KEY_ID {temp_creds_req['accessKeyId']} --config AWS_SECRET_ACCESS_KEY {temp_creds_req['secretAccessKey']} --config AWS_SESSION_TOKEN {temp_creds_req['sessionToken']} --config GDAL_DISABLE_READDIR_ON_OPEN TRUE\"\n#build_red_vrt    # !!! BEWARE, removing the # on this line will print your temporary S3 credentials.\nWe now have a fully configured gdalbuildvrt string that we can pass to Python’s subprocess module to run the gdalbuildvrt executable outside our Python environment.\n\n\n\nExecute gdalbuildvrt to construct a VRT on disk from the S3 links\n\n%%time\n\nsubprocess.call(build_red_vrt, shell=True)\n\nCPU times: user 2.1 ms, sys: 3.83 ms, total: 5.93 ms\nWall time: 3.74 s\n\n\n0\n\n\n0 means success! We’ll have some troubleshooting to do you get any other value. In this tutorial, the path for the output VRT file or the input file list are the first things to check.\nWhile we’re here, we’ll build the VRT files for the NIR layers and the Fmask layers.\n\nbuild_nir_vrt = f\"gdalbuildvrt ./data/nir_stack.vrt -separate -input_file_list ./data/S3_T13TGF_NIR_VSI_Links.txt --config AWS_ACCESS_KEY_ID {temp_creds_req['accessKeyId']} --config AWS_SECRET_ACCESS_KEY {temp_creds_req['secretAccessKey']} --config AWS_SESSION_TOKEN {temp_creds_req['sessionToken']} --config GDAL_DISABLE_READDIR_ON_OPEN TRUE\"\nsubprocess.call(build_nir_vrt, shell=True)\n\n0\n\n\n\nbuild_fmask_vrt = f\"gdalbuildvrt ./data/fmask_stack.vrt -separate -input_file_list ./data/S3_T13TGF_FMASK_VSI_Links.txt --config AWS_ACCESS_KEY_ID {temp_creds_req['accessKeyId']} --config AWS_SECRET_ACCESS_KEY {temp_creds_req['secretAccessKey']} --config AWS_SESSION_TOKEN {temp_creds_req['sessionToken']} --config GDAL_DISABLE_READDIR_ON_OPEN TRUE\"\nsubprocess.call(build_fmask_vrt, shell=True)\n\n0\n\n\n\n\n\nReading in an HLS time series\nWe can now read the VRT files into our Python session. A drawback of reading VRTs into Python is that the time coordinate variable needs to be contructed. Below we not only read in the VRT file using rioxarray, but we also repurpose the band variable, which is generated automatically, to hold out time information.\n\nRead the RED VRT in as xarray with Dask backing\n\n%%time\n\nchunks=dict(band=1, x=1024, y=1024)\n#chunks=dict(band=1, x=512, y=512)\nred = rioxarray.open_rasterio('./data/red_stack.vrt', chunks=chunks)                    # Read in VRT\nred = red.rename({'band':'time'})                                                       # Rename the 'band' coordinate variable to 'time' \nred['time'] = [datetime.strptime(x.split('.')[-5], '%Y%jT%H%M%S') for x in links_vsi]   # Extract the time information from the input file names and assign them to the time coordinate variable\nred = red.sortby('time')                                                                # Sort by the time coordinate variable\nred\n\nCPU times: user 219 ms, sys: 20.3 ms, total: 239 ms\nWall time: 246 ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 3660, x: 3660)>\ndask.array<getitem, shape=(19, 3660, 3660), dtype=int16, chunksize=(1, 1024, 1024), chunktype=numpy.ndarray>\nCoordinates:\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0xarray.DataArraytime: 19y: 3660x: 3660dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         2.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nCoordinates: (4)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (3)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0\n\n\nAbove we use the parameter chunk in the rioxarray.open_rasterio() function to enable the Dask backing. What this allows is lazy reading of the data, which means the data is not actually read in into memory at this point. What we have is an object with some metadata and pointer to the source data. The data will be streamed to us when we call for it, but not stored in memory until with call the Dask compute() or persist() methods.\n\n\nPrint out the time coordinate\n\nred.time\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'time' (time: 19)>\narray(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')\nCoordinates:\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n    spatial_ref  int64 0xarray.DataArray'time'time: 192021-05-13T17:24:06 2021-05-13T17:38:59 ... 2021-08-17T17:24:41array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')Coordinates: (2)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (0)\n\n\n\n\nClip out the ROI and persist the result in memory\nUp until now, we haven’t read any of the HLS data into memory. Now we will use the persist() method to load the data into memory.\n\nred_clip = red.rio.clip([fsUTM]).persist()\nred_clip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 56, x: 56)>\ndask.array<astype, shape=(19, 56, 56), dtype=int16, chunksize=(1, 56, 56), chunktype=numpy.ndarray>\nCoordinates:\n  * y            (y) float64 4.551e+06 4.551e+06 ... 4.549e+06 4.549e+06\n  * x            (x) float64 7.796e+05 7.796e+05 ... 7.812e+05 7.812e+05\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n    spatial_ref  int64 0\nAttributes:\n    scale_factor:  0.0001\n    add_offset:    0.0\n    _FillValue:    -9999xarray.DataArraytime: 19y: 56x: 56dask.array<chunksize=(1, 56, 56), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         116.38 kiB \n                         6.12 kiB \n                    \n                    \n                    \n                         Shape \n                         (19, 56, 56) \n                         (1, 56, 56) \n                    \n                    \n                         Count \n                         19 Tasks \n                         19 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  56\n  56\n  19\n\n        \n    \nCoordinates: (4)y(y)float644.551e+06 4.551e+06 ... 4.549e+06axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([4551045., 4551015., 4550985., 4550955., 4550925., 4550895., 4550865.,\n       4550835., 4550805., 4550775., 4550745., 4550715., 4550685., 4550655.,\n       4550625., 4550595., 4550565., 4550535., 4550505., 4550475., 4550445.,\n       4550415., 4550385., 4550355., 4550325., 4550295., 4550265., 4550235.,\n       4550205., 4550175., 4550145., 4550115., 4550085., 4550055., 4550025.,\n       4549995., 4549965., 4549935., 4549905., 4549875., 4549845., 4549815.,\n       4549785., 4549755., 4549725., 4549695., 4549665., 4549635., 4549605.,\n       4549575., 4549545., 4549515., 4549485., 4549455., 4549425., 4549395.])x(x)float647.796e+05 7.796e+05 ... 7.812e+05axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([779595., 779625., 779655., 779685., 779715., 779745., 779775., 779805.,\n       779835., 779865., 779895., 779925., 779955., 779985., 780015., 780045.,\n       780075., 780105., 780135., 780165., 780195., 780225., 780255., 780285.,\n       780315., 780345., 780375., 780405., 780435., 780465., 780495., 780525.,\n       780555., 780585., 780615., 780645., 780675., 780705., 780735., 780765.,\n       780795., 780825., 780855., 780885., 780915., 780945., 780975., 781005.,\n       781035., 781065., 781095., 781125., 781155., 781185., 781215., 781245.])time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :779580.0 30.0 0.0 4551060.0 0.0 -30.0array(0)Attributes: (3)scale_factor :0.0001add_offset :0.0_FillValue :-9999\n\n\nAbove, we persisted the clipped results to memory using the persist() method. This doesn’t necessarily need to be done, but it will substantially improve the performance of the visualization of the time series below.\n\n\nPlot red_clip with hvplot\n\nred_clip.hvplot.image(x='x', y='y', width=800, height=600, colorbar=True, cmap='Reds').opts(clim=(0.0, red_clip.values.max()))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nRead in the NIR and Fmask VRT files\n\n%%time\nchunks=dict(band=1, x=1024, y=1024)\nnir = rioxarray.open_rasterio('./data/nir_stack.vrt', chunks=chunks)                    # Read in VRT\nnir = nir.rename({'band':'time'})                                                       # Rename the 'band' coordinate variable to 'time' \nnir['time'] = [datetime.strptime(x.split('.')[-5], '%Y%jT%H%M%S') for x in links_vsi]   # Extract the time information from the input file names and assign them to the time coordinate variable\nnir = nir.sortby('time')                                                                # Sort by the time coordinate variable\nnir\n\nCPU times: user 69.9 ms, sys: 216 µs, total: 70.1 ms\nWall time: 81.9 ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 3660, x: 3660)>\ndask.array<getitem, shape=(19, 3660, 3660), dtype=int16, chunksize=(1, 1024, 1024), chunktype=numpy.ndarray>\nCoordinates:\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0xarray.DataArraytime: 19y: 3660x: 3660dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         2.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nCoordinates: (4)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (3)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0\n\n\n\n%%time\nchunks=dict(band=1, x=1024, y=1024)\nfmask = rioxarray.open_rasterio('./data/fmask_stack.vrt', chunks=chunks)                    # Read in VRT\nfmask = fmask.rename({'band':'time'})                                                       # Rename the 'band' coordinate variable to 'time' \nfmask['time'] = [datetime.strptime(x.split('.')[-5], '%Y%jT%H%M%S') for x in links_vsi]     # Extract the time information from the input file names and assign them to the time coordinate variable\nfmask = fmask.sortby('time')                                                                # Sort by the time coordinate variable\nfmask\n\nCPU times: user 64.6 ms, sys: 85 µs, total: 64.7 ms\nWall time: 74.8 ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 3660, x: 3660)>\ndask.array<getitem, shape=(19, 3660, 3660), dtype=uint8, chunksize=(1, 1024, 1024), chunktype=numpy.ndarray>\nCoordinates:\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    255.0\n    scale_factor:  1.0\n    add_offset:    0.0xarray.DataArraytime: 19y: 3660x: 3660dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         242.73 MiB \n                         1.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     uint8 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nCoordinates: (4)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (3)_FillValue :255.0scale_factor :1.0add_offset :0.0\n\n\n\n\nCreate an xarray dataset\nWe will now combine the RED, NIR, and Fmask arrays into a dataset and create/add a new NDVI variable.\n\nhls_ndvi = xr.Dataset({'red': red, 'nir': nir, 'fmask': fmask, 'ndvi': (nir - red) / (nir + red)})\nhls_ndvi\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:      (time: 19, x: 3660, y: 3660)\nCoordinates:\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nData variables:\n    red          (time, y, x) int16 dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    nir          (time, y, x) int16 dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    fmask        (time, y, x) uint8 dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    ndvi         (time, y, x) float64 dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>xarray.DatasetDimensions:time: 19x: 3660y: 3660Coordinates: (4)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Data variables: (4)red(time, y, x)int16dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>_FillValue :-9999.0scale_factor :0.0001add_offset :0.0\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         2.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nnir(time, y, x)int16dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>_FillValue :-9999.0scale_factor :0.0001add_offset :0.0\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         2.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nfmask(time, y, x)uint8dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>_FillValue :255.0scale_factor :1.0add_offset :0.0\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         242.73 MiB \n                         1.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         609 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     uint8 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nndvi(time, y, x)float64dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         1.90 GiB \n                         8.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         2130 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     float64 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nAttributes: (0)\n\n\nAbove, we created a new NDVI variable. Now, we will clip and plot our results.\n\nndvi_clip = hls_ndvi.ndvi.rio.clip([fsUTM]).persist()\nndvi_clip\n\n/srv/conda/envs/notebook/lib/python3.7/site-packages/dask/core.py:119: RuntimeWarning: divide by zero encountered in true_divide\n  return func(*(_execute_task(a, cache) for a in args))\n/srv/conda/envs/notebook/lib/python3.7/site-packages/dask/core.py:119: RuntimeWarning: invalid value encountered in true_divide\n  return func(*(_execute_task(a, cache) for a in args))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'ndvi' (time: 19, y: 56, x: 56)>\ndask.array<getitem, shape=(19, 56, 56), dtype=float64, chunksize=(1, 56, 56), chunktype=numpy.ndarray>\nCoordinates:\n  * y            (y) float64 4.551e+06 4.551e+06 ... 4.549e+06 4.549e+06\n  * x            (x) float64 7.796e+05 7.796e+05 ... 7.812e+05 7.812e+05\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n    spatial_ref  int64 0xarray.DataArray'ndvi'time: 19y: 56x: 56dask.array<chunksize=(1, 56, 56), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         465.50 kiB \n                         24.50 kiB \n                    \n                    \n                    \n                         Shape \n                         (19, 56, 56) \n                         (1, 56, 56) \n                    \n                    \n                         Count \n                         19 Tasks \n                         19 Chunks \n                    \n                    \n                     Type \n                     float64 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  56\n  56\n  19\n\n        \n    \nCoordinates: (4)y(y)float644.551e+06 4.551e+06 ... 4.549e+06axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([4551045., 4551015., 4550985., 4550955., 4550925., 4550895., 4550865.,\n       4550835., 4550805., 4550775., 4550745., 4550715., 4550685., 4550655.,\n       4550625., 4550595., 4550565., 4550535., 4550505., 4550475., 4550445.,\n       4550415., 4550385., 4550355., 4550325., 4550295., 4550265., 4550235.,\n       4550205., 4550175., 4550145., 4550115., 4550085., 4550055., 4550025.,\n       4549995., 4549965., 4549935., 4549905., 4549875., 4549845., 4549815.,\n       4549785., 4549755., 4549725., 4549695., 4549665., 4549635., 4549605.,\n       4549575., 4549545., 4549515., 4549485., 4549455., 4549425., 4549395.])x(x)float647.796e+05 7.796e+05 ... 7.812e+05axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([779595., 779625., 779655., 779685., 779715., 779745., 779775., 779805.,\n       779835., 779865., 779895., 779925., 779955., 779985., 780015., 780045.,\n       780075., 780105., 780135., 780165., 780195., 780225., 780255., 780285.,\n       780315., 780345., 780375., 780405., 780435., 780465., 780495., 780525.,\n       780555., 780585., 780615., 780645., 780675., 780705., 780735., 780765.,\n       780795., 780825., 780855., 780885., 780915., 780945., 780975., 781005.,\n       781035., 781065., 781095., 781125., 781155., 781185., 781215., 781245.])time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:28:59.000000000', '2021-05-20T17:30:21.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :779580.0 30.0 0.0 4551060.0 0.0 -30.0array(0)Attributes: (0)\n\n\n\nPlot NDVI\n\nndvi_clip.hvplot.image(x='x', y='y', groupby='time', width=800, height=600, colorbar=True, cmap='YlGn').opts(clim=(0.0, 1.0))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\nYou may have notices that some images for some of the time step are ‘blurrier’ than other. This is because they are contaminated in some way, be it clouds, cloud shadows, snow, ice.\n\n\n\nApply quality filter\nWe want to keep NDVI data values where Fmask equals 0 (no clouds, no cloud shadow, no snow/ice, no water.\n\nndvi_clip_filter = hls_ndvi.ndvi.where(fmask==0, np.nan).rio.clip([fsUTM]).persist()\n\n/srv/conda/envs/notebook/lib/python3.7/site-packages/dask/core.py:119: RuntimeWarning: divide by zero encountered in true_divide\n  return func(*(_execute_task(a, cache) for a in args))\n/srv/conda/envs/notebook/lib/python3.7/site-packages/dask/core.py:119: RuntimeWarning: invalid value encountered in true_divide\n  return func(*(_execute_task(a, cache) for a in args))\n\n\n\nndvi_clip_filter.hvplot.image(x='x', y='y', groupby='time', width=800, height=600, colorbar=True, cmap='YlGn').opts(clim=(0.0, 1.0))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\n\nAggregate by month\nFinally, we will use xarray’s groupby operation to aggregate by month.\n\nndvi_clip_filter.groupby('time.month').mean('time').hvplot.image(x = 'x', y = 'y', crs = hls_proj, groupby='month', cmap='YlGn', width=800, height=600, colorbar=True).opts(clim=(0.0, 1.0))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\nrio_env.__exit__()"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#references",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__gdalvrt.html#references",
    "title": "",
    "section": "References",
    "text": "https://rasterio.readthedocs.io/en/latest/\nhttps://corteva.github.io/rioxarray/stable/index.html\nhttps://tutorial.dask.org/index.html\nhttps://examples.dask.org/applications/satellite-imagery-geotiff.html"
  },
  {
    "objectID": "tutorials/03_Xarray.html#why-do-we-need-xarray",
    "href": "tutorials/03_Xarray.html#why-do-we-need-xarray",
    "title": "",
    "section": "Why do we need xarray?",
    "text": "As Geoscientists, we often work with time series of data with two or more dimensions: a time series of calibrated, orthorectified satellite images; two-dimensional grids of surface air temperature from an atmospheric reanalysis; or three-dimensional (level, x, y) cubes of ocean salinity from an ocean model. These data are often provided in GeoTIFF, NetCDF or HDF format with rich and useful metadata that we want to retain, or even use in our analysis. Common analyses include calculating means, standard deviations and anomalies over time or one or more spatial dimensions (e.g. zonal means). Model output often includes multiple variables that you want to apply similar analyses to.\n\n\n\nA schematic of multi-dimensional data\n\n\nThe schematic above shows a typical data structure for multi-dimensional data. There are two data cubes, one for temperature and one for precipitation. Common coordinate variables, in this case latitude, longitude and time are associated with each variable. Each variable, including coordinate variables, will have a set of attributes: name, units, missing value, etc. The file containing the data may also have attributes: source of the data, model name coordinate reference system if the data are projected. Writing code using low-level packages such as netcdf4 and numpy to read the data, then perform analysis, and write the results to file is time consuming and prone to errors."
  },
  {
    "objectID": "tutorials/03_Xarray.html#what-is-xarray",
    "href": "tutorials/03_Xarray.html#what-is-xarray",
    "title": "",
    "section": "What is xarray",
    "text": "xarray is an open-source project and python package to work with labelled multi-dimensional arrays. It is leverages numpy, pandas, matplotlib and dask to build Dataset and DataArray objects with built-in methods to subset, analyze, interpolate, and plot multi-dimensional data. It makes working with multi-dimensional data cubes efficient and fun. It will change your life for the better. You’ll be more attractive, more interesting, and better equiped to take on lifes challenges."
  },
  {
    "objectID": "tutorials/03_Xarray.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials/03_Xarray.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "In this tutorial you will learn how to:\n\nload a netcdf file into xarray\ninterrogate the Dataset and understand the difference between DataArray and Dataset\nsubset a Dataset\ncalculate annual and monthly mean fields\ncalculate a time series of zonal means\nplot these results\n\nAs always, we’ll start by importing xarray. We’ll follow convention by giving the module the shortname xr\nimport xarray as xr\nxr.set_options(keep_attrs=True)\nI’m going to use one of xarray’s tutorial datasets. In this case, air temperature from the NCEP reanalysis. I’ll assign the result of the open_dataset to ds. I may change this to access a dataset directly\nds = xr.tutorial.open_dataset(\"air_temperature\")\nAs we are in an interactive environment, we can just type ds to see what we have.\nds\nFirst thing to notice is that ds is an xarray.Dataset object. It has dimensions, lat, lon, and time. It also has coordinate variables with the same names as these dimensions. These coordinate variables are 1-dimensional. This is a NetCDF convention. The Dataset contains one data variable, air. This has dimensions (time, lat, lon).\nClicking on the document icon reveals attributes for each variable. Clicking on the disk icon reveals a representation of the data.\nEach of the data and coordinate variables can be accessed and examined using the variable name as a key.\nds.air\nds['air']\nThese are xarray.DataArray objects. This is the basic building block for xarray.\nVariables can also be accessed as attributes of ds.\nds.time\nA major difference between accessing a variable as an attribute versus using a key is that the attribute is read-only but the key method can be used to update the variable. For example, if I want to convert the units of air from Kelvin to degrees Celsius.\nds['air'] = ds.air - 273.15\nThis approach can also be used to add new variables\nds['air_kelvin'] = ds.air + 273.15\nIt is helpful to update attributes such as units, this saves time, confusion and mistakes, especially when you save the dataset.\nds['air'].attrs['units'] = 'degC'\nds"
  },
  {
    "objectID": "tutorials/03_Xarray.html#subsetting-and-indexing",
    "href": "tutorials/03_Xarray.html#subsetting-and-indexing",
    "title": "",
    "section": "Subsetting and Indexing",
    "text": "Subsetting and indexing methods depend on whether you are working with a Dataset or DataArray. A DataArray can be accessed using positional indexing just like a numpy array. To access the temperature field for the first time step, you do the following.\nds['air'][0,:,:]\nNote this returns a DataArray with coordinates but not attributes.\nHowever, the real power is being able to access variables using coordinate variables. I can get the same subset using the following. (It’s also more explicit about what is being selected and robust in case I modify the DataArray and expect the same output.)\nds['air'].sel(time='2013-01-01').time\nds.air.sel(time='2013-01-01')\nI can also do slices. I’ll extract temperatures for the state of Colorado. The bounding box for the state is [-109 E, -102 E, 37 N, 41 N].\nIn the code below, pay attention to both the order of the coordinates and the range of values. The first value of the lat coordinate variable is 41 N, the second value is 37 N. Unfortunately, xarray expects slices of coordinates to be in the same order as the coordinates. Note lon is 0 to 360 not -180 to 180, and I let python calculate it for me within the slice.\nds.air.sel(lat=slice(41.,37.), lon=slice(360-109,360-102))\nWhat if we want temperature for a point, for example Denver, CO (39.72510678889283 N, -104.98785545855408 E). xarray can handle this! If we just want data from the nearest grid point, we can use sel and specify the method as “nearest”.\ndenver_lat, denver_lon = 39.72510678889283, -104.98785545855408\nds.air.sel(lat=denver_lat, lon=360+denver_lon, method='nearest')\nIf we want to interpolate, we can use interp(). In this case I use linear or bilinear interpolation.\ninterp() can also be used to resample data to a new grid and even reproject data\nds.air.interp(lat=denver_lat, lon=360+denver_lon, method='linear')\nsel() and interp() can also be used on Dataset objects.\nds.sel(lat=slice(41.,37.), lon=slice(360-109,360-102))\nds.interp(lat=denver_lat, lon=360+denver_lon, method='linear')"
  },
  {
    "objectID": "tutorials/03_Xarray.html#analysis",
    "href": "tutorials/03_Xarray.html#analysis",
    "title": "",
    "section": "Analysis",
    "text": "As a simple example, let’s try to calculate a mean field for the whole time range.\nds.mean(dim='time')\nWe can also calculate a zonal mean (averaging over longitude)\nds.mean(dim='lon')\nOther aggregation methods include min(), max(), std(), along with others.\nds.std(dim='time')\nThe data we have are in 6h timesteps. This can be resampled to daily or monthly. If you are familiar with pandas, xarray uses the same methods.\nds.resample(time='M').mean()\nds_mon = ds.resample(time='M').mean()\nds_mon\nThis is a really short time series but as an example, let’s calculate a monthly climatology (at least for 2 months). For this we can use groupby()\nds_clim = ds_mon.groupby(ds_mon.time.dt.month).mean()"
  },
  {
    "objectID": "tutorials/03_Xarray.html#plot-results",
    "href": "tutorials/03_Xarray.html#plot-results",
    "title": "",
    "section": "Plot results",
    "text": "Finally, let’s plot the results! This will plot the lat/lon axes of the original ds DataArray.\nds_clim.air.sel(month=10).plot()"
  },
  {
    "objectID": "tutorials/01_Data_Discovery_CMR.html#what-is-cmr",
    "href": "tutorials/01_Data_Discovery_CMR.html#what-is-cmr",
    "title": "",
    "section": "What is CMR",
    "text": "CMR is the Common Metadata Repository. It catalogs all data for NASA’s Earth Observing System Data and Information System (EOSDIS). It is the backend of Earthdata Search, the GUI search interface you are probably familiar with. More information about CMR can be found here.\nUnfortunately, the GUI for Earthdata Search is not accessible from a cloud instance - at least not without some work. Earthdata Search is also not immediately reproducible. What I mean by that is if you create a search using the GUI you would have to note the search criteria (date range, search area, collection name, etc), take a screenshot, copy the search url, or save the list of data granules returned by the search, in order to recreate the search. This information would have to be re-entered each time you or someone else wanted to do the search. You could make typos or other mistakes. A cleaner, reproducible solution is to search CMR programmatically using the CMR API."
  },
  {
    "objectID": "tutorials/01_Data_Discovery_CMR.html#what-is-the-cmr-api",
    "href": "tutorials/01_Data_Discovery_CMR.html#what-is-the-cmr-api",
    "title": "",
    "section": "What is the CMR API",
    "text": "API stands for Application Programming Interface. It allows applications (software, services, etc) to send information to each other. A helpful analogy is a waiter in a restaurant. The waiter takes your drink or food order that you select from the menu, often translated into short-hand, to the bar or kitchen, and then returns (hopefully) with what you ordered when it is ready.\nThe CMR API accepts search terms such as collection name, keywords, datetime range, and location, queries the CMR database and returns the results."
  },
  {
    "objectID": "tutorials/01_Data_Discovery_CMR.html#how-to-search-cmr-from-python",
    "href": "tutorials/01_Data_Discovery_CMR.html#how-to-search-cmr-from-python",
    "title": "",
    "section": "How to search CMR from Python",
    "text": "The first step is to import python packages. We will use:\n- requests This package does most of the work for us accessing the CMR API using HTTP methods. - pprint to pretty print the results of the search.\nA more in depth tutorial on requests is here\nimport requests\nfrom pprint import pprint\nThen we need to authenticate with EarthData Login. Since we’ve already set this up in the previous lesson, here you need to enter your username before executing the cell.\nTo conduct a search using the CMR API, requests needs the url for the root CMR search endpoint. We’ll build this url as a python variable.\nCMR_OPS = 'https://cmr.earthdata.nasa.gov/search'\nCMR allows search by collections, which are datasets, and granules, which are files that contain data. Many of the same search parameters can be used for colections and granules but the type of results returned differ. Search parameters can be found in the API Documentation.\nWhether we search collections or granules is distinguished by adding \"collections\" or \"granules\" to the url for the root CMR endpoint.\nWe are going to search collections first, so we add collections to the url. I’m using a python format string here.\nurl = f'{CMR_OPS}/{\"collections\"}'\nIn this first example, I want to retrieve a list of collections that are hosted in the cloud. Each collection has a cloud_hosted parameter that is either True if that collection is in the cloud and False if it is not. The migration of NASA data to the cloud is a work in progress. Not all collections tagged as cloud_hosted have granules. To search for only cloud_hosted datasets with granules, I also set has_granules to True.\nI also want to get the content in json (pronounced “jason”) format, so I pass a dictionary to the header keyword argument to say that I want results returned as json.\nThe .get() method is used to send this information to the CMR API. get() calls the HTTP method GET.\nresponse = requests.get(url,\n                        params={\n                            'cloud_hosted': 'True',\n                            'has_granules': 'True',\n                        },\n                        headers={\n                            'Accept': 'application/json',\n                        }\n                       )\nrequests returns a Response object.\nOften, we want to check that our request was successful. In a notebook or someother interactive environment, we can just type the name of the variable we have saved our requests Response to, in this case the response variable.\n\nresponse\n\n<Response [200]>\n\n\nA cleaner and more understandable method is to check the status_code attribute. Both methods return a HTTP status code. You’ve probably seen a 404 error when you have tried to access a website that doesn’t exist.\n\nresponse.status_code\n\n200\n\n\nTry changing CMR_OPS to https://cmr.earthdata.nasa.gov/searches and run requests.get again. Don’t forget to rerun the cell that assigns the url variable\nThe response from requests.get returns the results of the search and metadata about those results in the headers.\nMore information about the response object can be found by typing help(response).\nheaders contains useful information in a case-insensitive dictionary. This information is printed below. TODO: maybe some context for where the 2 elements k, v, come from?\n\nfor k, v in response.headers.items():\n    print(f'{k}: {v}')\n\nContent-Type: application/json;charset=utf-8\nContent-Length: 3820\nConnection: keep-alive\nDate: Tue, 02 Nov 2021 22:07:37 GMT\nX-Frame-Options: SAMEORIGIN\nAccess-Control-Allow-Origin: *\nX-XSS-Protection: 1; mode=block\nCMR-Request-Id: 510cf611-d65b-4b46-981b-f4719405676a\nStrict-Transport-Security: max-age=31536000\nCMR-Search-After: [0.0,14000.0,\"SENTINEL-1A_RAW\",\"1\",1214470561,1320]\nCMR-Hits: 917\nAccess-Control-Expose-Headers: CMR-Hits, CMR-Request-Id, X-Request-Id, CMR-Scroll-Id, CMR-Search-After, CMR-Timed-Out, CMR-Shapefile-Original-Point-Count, CMR-Shapefile-Simplified-Point-Count\nX-Content-Type-Options: nosniff\nCMR-Took: 435\nX-Request-Id: 510cf611-d65b-4b46-981b-f4719405676a\nVary: Accept-Encoding, User-Agent\nContent-Encoding: gzip\nServer: ServerTokens ProductOnly\nX-Cache: Miss from cloudfront\nVia: 1.1 3f7e5e686bf8f19b9c786efbe99c7589.cloudfront.net (CloudFront)\nX-Amz-Cf-Pop: DEN52-C1\nX-Amz-Cf-Id: BXEUlb5ygB9nj9ygUbSZvIc3BE4k0d1Mn1qDd66IkkuX1rC_Z-mN6Q==\n\n\nWe can see that the content returned is in json format in the UTF-8 character set. We can also see from CMR-Hits that 919 collections were found.\nEach item in the dictionary can be accessed in the normal way you access a python dictionary but because it is case-insensitive, both\n\nresponse.headers['CMR-Hits']\n\n'917'\n\n\nand\n\nresponse.headers['cmr-hits']\n\n'917'\n\n\nwork.\nThis is a large number of data sets. I’m going to restrict the search to cloud-hosted datasets from ASF (Alaska SAR Facility) because I’m interested in SAR images of sea ice. To do this, I set the provider parameter to ASF.\nYou can modify the code below to explore all of the cloud-hosted datasets or cloud-hosted datasets from other providers. A partial list of providers is given below.\n\n\n\n\n\n\n\n\n\nDAAC\nShort Name\nCloud Provider\nOn-Premises Provider\n\n\n\n\nNSIDC\nNational Snow and Ice Data Center\nNSIDC_CPRD\nNSIDC_ECS\n\n\nGHRC DAAC\nGlobal Hydrometeorology Resource Center\nGHRC_DAAC\nGHRC_DAAC\n\n\nPO DAAC\nPhysical Oceanography Distributed Active Archive Center\nPOCLOUD\nPODAAC\n\n\nASF\nAlaska Satellite Facility\nASF\nASF\n\n\nORNL DAAC\nOak Ridge National Laboratory\nORNL_CLOUD\nORNL_DAAC\n\n\nLP DAAC\nLand Processes Distributed Active Archive Center\nLPCLOUD\nLPDAAC_ECS\n\n\nGES DISC\nNASA Goddard Earth Sciences (GES) Data and Information Services Center (DISC)\nGES_DISC\nGES_DISC\n\n\nOB DAAC\nNASA’s Ocean Biology Distributed Active Archive Center\n\nOB_DAAC\n\n\nSEDAC\nNASA’s Socioeconomic Data and Applications Center\n\nSEDAC\n\n\n\nWhen search by provider, use Cloud Provider to search for cloud-hosted datasets and On-Premises Provider to search for datasets archived at the DAACs.\nprovider = 'ASF'\nresponse = requests.get(url,\n                        params={\n                            'cloud_hosted': 'True',\n                            'has_granules': 'True',\n                            'provider': provider,\n                        },\n                        headers={\n                            'Accept': 'application/json'\n                        }\n                       )\n\nresponse.headers['cmr-hits']\n\n'45'\n\n\nSearch results are contained in the content part of the Response object. However, response.content returns information in bytes.\n\nresponse.content\n\nb'{\"feed\":{\"updated\":\"2021-11-02T22:41:34.322Z\",\"id\":\"https://cmr.earthdata.nasa.gov:443/search/collections.json?cloud_hosted=True&has_granules=True&provider=ASF\",\"title\":\"ECHO dataset metadata\",\"entry\":[{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:39.000Z\",\"dataset_id\":\"SENTINEL-1A_SLC\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_SLC\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1A_SLC\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1A slant-range product\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214470488-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2016-04-25T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:17:22.000Z\",\"dataset_id\":\"SENTINEL-1B_SLC\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1B_SLC\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1B_SLC\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1B slant-range product\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1327985661-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1B\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:15:56.000Z\",\"dataset_id\":\"SENTINEL-1A_DUAL_POL_GRD_HIGH_RES\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_DP_GRD_HIGH\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1A_DUAL_POL_GRD_HIGH_RES\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1A Dual-pol ground projected high and full resolution images\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214470533-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2016-04-25T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:47.000Z\",\"dataset_id\":\"SENTINEL-1B_DUAL_POL_GRD_HIGH_RES\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1B_DP_GRD_HIGH\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1B_DUAL_POL_GRD_HIGH_RES\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1B Dual-pol ground projected high and full resolution images\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1327985645-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1B\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2016-04-25T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:49.000Z\",\"dataset_id\":\"SENTINEL-1B_DUAL_POL_GRD_MEDIUM_RES\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1B_DP_GRD_MEDIUM\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1B_DUAL_POL_GRD_MEDIUM_RES\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1B Dual-pol ground projected medium resolution images\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1327985660-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1B\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:15:58.000Z\",\"dataset_id\":\"SENTINEL-1A_DUAL_POL_GRD_MEDIUM_RES\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_DP_GRD_MEDIUM\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1A_DUAL_POL_GRD_MEDIUM_RES\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1A Dual-pol ground projected medium resolution images\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214471521-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:20.000Z\",\"dataset_id\":\"SENTINEL-1A_RAW\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_RAW\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1A_RAW\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1A level zero product\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214470561-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:15.000Z\",\"dataset_id\":\"SENTINEL-1A_METADATA_SLC\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_META_SLC\",\"organizations\":[\"ASF\"],\"title\":\"SENTINEL-1A_METADATA_SLC\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Metadata for Sentinel-1A slant-range product\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214470496-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2016-04-25T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:17:02.000Z\",\"dataset_id\":\"SENTINEL-1B_METADATA_SLC\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1B_META_SLC\",\"organizations\":[\"ASF\"],\"title\":\"SENTINEL-1B_METADATA_SLC\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Metadata for Sentinel-1B slant-range product\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1327985617-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1B\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]},{\"boxes\":[\"-90 -180 90 180\"],\"time_start\":\"2014-04-03T00:00:00.000Z\",\"version_id\":\"1\",\"updated\":\"2021-07-15T19:16:26.000Z\",\"dataset_id\":\"SENTINEL-1A_SINGLE_POL_GRD_HIGH_RES\",\"has_spatial_subsetting\":false,\"has_transforms\":false,\"has_variables\":false,\"data_center\":\"ASF\",\"short_name\":\"SENTINEL-1A_SP_GRD_HIGH\",\"organizations\":[\"ASF\",\"ESA/CS1CGS\"],\"title\":\"SENTINEL-1A_SINGLE_POL_GRD_HIGH_RES\",\"coordinate_system\":\"CARTESIAN\",\"summary\":\"Sentinel-1A Single-pol ground projected high and full resolution images\",\"service_features\":{\"opendap\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"esi\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false},\"harmony\":{\"has_formats\":false,\"has_variables\":false,\"has_transforms\":false,\"has_spatial_subsetting\":false,\"has_temporal_subsetting\":false}},\"orbit_parameters\":{},\"id\":\"C1214470682-ASF\",\"has_formats\":false,\"original_format\":\"ECHO10\",\"archive_center\":\"ASF\",\"has_temporal_subsetting\":false,\"browse_flag\":false,\"platforms\":[\"Sentinel-1A\"],\"online_access_flag\":true,\"links\":[{\"rel\":\"http://esipfed.org/ns/fedsearch/1.1/data#\",\"hreflang\":\"en-US\",\"href\":\"https://vertex.daac.asf.alaska.edu/\"}]}]}}'\n\n\nIt is more convenient to work with json formatted data. I’m using pretty print pprint to print the data in an easy to read way.\nStep through response.json(), then to response.json()['feed']['entry'][0]. A reminder that python starts indexing at 0, not 1!\n\npprint(response.json()['feed']['entry'][0])\n\n{'archive_center': 'ASF',\n 'boxes': ['-90 -180 90 180'],\n 'browse_flag': False,\n 'coordinate_system': 'CARTESIAN',\n 'data_center': 'ASF',\n 'dataset_id': 'SENTINEL-1A_SLC',\n 'has_formats': False,\n 'has_spatial_subsetting': False,\n 'has_temporal_subsetting': False,\n 'has_transforms': False,\n 'has_variables': False,\n 'id': 'C1214470488-ASF',\n 'links': [{'href': 'https://vertex.daac.asf.alaska.edu/',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n 'online_access_flag': True,\n 'orbit_parameters': {},\n 'organizations': ['ASF', 'ESA/CS1CGS'],\n 'original_format': 'ECHO10',\n 'platforms': ['Sentinel-1A'],\n 'service_features': {'esi': {'has_formats': False,\n                              'has_spatial_subsetting': False,\n                              'has_temporal_subsetting': False,\n                              'has_transforms': False,\n                              'has_variables': False},\n                      'harmony': {'has_formats': False,\n                                  'has_spatial_subsetting': False,\n                                  'has_temporal_subsetting': False,\n                                  'has_transforms': False,\n                                  'has_variables': False},\n                      'opendap': {'has_formats': False,\n                                  'has_spatial_subsetting': False,\n                                  'has_temporal_subsetting': False,\n                                  'has_transforms': False,\n                                  'has_variables': False}},\n 'short_name': 'SENTINEL-1A_SLC',\n 'summary': 'Sentinel-1A slant-range product',\n 'time_start': '2014-04-03T00:00:00.000Z',\n 'title': 'SENTINEL-1A_SLC',\n 'updated': '2021-07-15T19:16:39.000Z',\n 'version_id': '1'}\n\n\nThe first response is not the result I am looking for TODO: because xyz…but it does show a few variables that we can use to further refine the search. So I want to print the name of the dataset (dataset_id) and the concept id (id). We can build this variable and print statement like we did above with the url variable. TODO: is it worth saying something about what “feed” and “entry” are?\ncollections = response.json()['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"archive_center\"]} {collection[\"dataset_id\"]} {collection[\"id\"]}')\n\nASF SENTINEL-1A_SLC C1214470488-ASF\nASF SENTINEL-1B_SLC C1327985661-ASF\nASF SENTINEL-1A_DUAL_POL_GRD_HIGH_RES C1214470533-ASF\nASF SENTINEL-1B_DUAL_POL_GRD_HIGH_RES C1327985645-ASF\nASF SENTINEL-1B_DUAL_POL_GRD_MEDIUM_RES C1327985660-ASF\nASF SENTINEL-1A_DUAL_POL_GRD_MEDIUM_RES C1214471521-ASF\nASF SENTINEL-1A_RAW C1214470561-ASF\nASF SENTINEL-1A_METADATA_SLC C1214470496-ASF\nASF SENTINEL-1B_METADATA_SLC C1327985617-ASF\nASF SENTINEL-1A_SINGLE_POL_GRD_HIGH_RES C1214470682-ASF\n\n\nBut there is a problem. We know from CMR-Hits that there are 49 datasets but only 10 are printed. This is because CMR restricts the number of results returned by a query. The default is 10 but it can be set to a maximum of 2000. Knowing that there were 49 ‘hits’, I’ll set page_size to 49. Then, we can re-run our for loop for the collections.\nresponse = requests.get(url,\n                        params={\n                            'cloud_hosted': 'True',\n                            'provider': provider,\n                            'page_size': 49,\n                        },\n                        headers={\n                            'Accept': 'application/json'\n                        }\n                       )\n\ncollections = response.json()['feed']['entry']\nfor collection in collections:\n    print(f'{collection[\"archive_center\"]} {collection[\"dataset_id\"]} {collection[\"id\"]}')\n\nASF SENTINEL-1A_SLC C1214470488-ASF\nASF SENTINEL-1B_SLC C1327985661-ASF\nASF SENTINEL-1A_DUAL_POL_GRD_HIGH_RES C1214470533-ASF\nASF SENTINEL-1B_DUAL_POL_GRD_HIGH_RES C1327985645-ASF\nASF SENTINEL-1B_DUAL_POL_GRD_MEDIUM_RES C1327985660-ASF\nASF SENTINEL-1A_DUAL_POL_GRD_MEDIUM_RES C1214471521-ASF\nASF SENTINEL-1A_RAW C1214470561-ASF\nASF SENTINEL-1A_METADATA_SLC C1214470496-ASF\nASF SENTINEL-1B_METADATA_SLC C1327985617-ASF\nASF SENTINEL-1A_SINGLE_POL_GRD_HIGH_RES C1214470682-ASF\nASF SENTINEL-1A_OCN C1214472977-ASF\nASF SENTINEL-1B_RAW C1327985647-ASF\nASF SENTINEL-1A_DUAL_POL_METADATA_GRD_HIGH_RES C1214470576-ASF\nASF SENTINEL-1B_OCN C1327985579-ASF\nASF SENTINEL-1A_METADATA_RAW C1214470532-ASF\nASF SENTINEL-1B_DUAL_POL_METADATA_GRD_HIGH_RES C1327985741-ASF\nAlaska Satellite Facility Sentinel-1 Interferograms (BETA) C1595422627-ASF\nASF ALOS_AVNIR_OBS_ORI C1808440897-ASF\nASF SENTINEL-1A_SINGLE_POL_GRD_MEDIUM_RES C1214472994-ASF\nASF SENTINEL-1B_METADATA_RAW C1327985650-ASF\nASF SENTINEL-1B_SINGLE_POL_GRD_HIGH_RES C1327985571-ASF\nASF SENTINEL-1B_SINGLE_POL_GRD_MEDIUM_RES C1327985740-ASF\nASF SENTINEL-1A_METADATA_OCN C1266376001-ASF\nASF SENTINEL-1B_METADATA_OCN C1327985646-ASF\nASF SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES C1214472336-ASF\nASF SENTINEL-1A_SINGLE_POL_METADATA_GRD_HIGH_RES C1214470732-ASF\nASF SENTINEL-1A_SINGLE_POL_METADATA_GRD_MEDIUM_RES C1214473170-ASF\nASF SENTINEL-1B_DUAL_POL_METADATA_GRD_MEDIUM_RES C1327985578-ASF\nASF SENTINEL-1B_SINGLE_POL_METADATA_GRD_HIGH_RES C1327985619-ASF\nASF SENTINEL-1B_SINGLE_POL_METADATA_GRD_MEDIUM_RES C1327985739-ASF\nASF STS-68_BROWSE_GRD C1661710593-ASF\nASF STS-68_BROWSE_SLC C1661710596-ASF\nASF STS-59_BROWSE_GRD C1661710578-ASF\nASF STS-59_BROWSE_SLC C1661710581-ASF\nASF SENTINEL-1A_DUAL_POL_GRD_FULL_RES C1214471197-ASF\nASF SENTINEL-1A_DUAL_POL_METADATA_GRD_FULL_RES C1214471960-ASF\nASF SENTINEL-1A_SINGLE_POL_GRD_FULL_RES C1214472978-ASF\nASF SENTINEL-1A_SINGLE_POL_METADATA_GRD_FULL_RES C1214473165-ASF\nASF SENTINEL-1B_DUAL_POL_GRD_FULL_RES C1327985697-ASF\nASF SENTINEL-1B_DUAL_POL_METADATA_GRD_FULL_RES C1327985651-ASF\nASF SENTINEL-1B_SINGLE_POL_GRD_FULL_RES C1327985644-ASF\nASF SENTINEL-1B_SINGLE_POL_METADATA_GRD_FULL_RES C1327985674-ASF\nAlaska Satellite Facility Sentinel-1 Unwrapped Interferogram and Coherence Map (BETA) C1379535600-ASF\nAlaska Satellite Facility Sentinel-1 Interferograms - Amplitude (BETA) C1596065640-ASF\nAlaska Satellite Facility Sentinel-1 Interferograms - Coherence (BETA) C1596065639-ASF\nAlaska Satellite Facility Sentinel-1 Interferograms - Connected Components (BETA) C1596065641-ASF\nAlaska Satellite Facility Sentinel-1 Interferograms - Unwrapped Phase (BETA) C1595765183-ASF\nASF STS-59_GRD C1661710583-ASF\nASF STS-59_METADATA_GRD C1661710586-ASF"
  },
  {
    "objectID": "tutorials/01_Data_Discovery_CMR.html#granule-search",
    "href": "tutorials/01_Data_Discovery_CMR.html#granule-search",
    "title": "",
    "section": "Granule Search",
    "text": "In NASA speak, Granules are files. In this example, we will search for recent Sentinel-1 Ground Range Detected (GRD) Medium Resolution Synthetic Aperture Radar images over the east coast of Greenland. The data in these files are most useful for sea ice mapping.\nI’ll use the data range 2021-10-17 00:00 to 2021-10-18 23:59:59.\nI’ll use a simple bounding box to search. - SW: 76.08166,-67.1746 - NW: 88.19689,21.04862\nFrom the collections search, I know the concept ids for Sentinel-1A and Sentinel-1B GRD medium resolution are - C1214472336-ASF - C1327985578-ASF\nWe need to change the resource url to look for granules instead of collections\nurl = f'{CMR_OPS}/{\"granules\"}'\nWe will search by concept_id, temporal, and bounding_box. Details about these search parameters can be found in the CMR API Documentation.\nThe formatting of the values for each parameter is quite specific.\nTemporal parameters are in ISO 8061 format yyyy-MM-ddTHH:mm:ssZ.\nBounding box coordinates are lower left longitude, lower left latitude, upper right longitude, upper right latitude.\n\nresponse = requests.get(url, \n                        params={\n                            'concept_id': 'C1214472336-ASF',\n                            'temporal': '2020-10-17T00:00:00Z,2020-10-18T23:59:59Z',\n                            'bounding_box': '76.08166,-67.1746,88.19689,21.04862',\n                            'page_size': 200,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nprint(response.status_code)\n\n200\n\n\n\nprint(response.headers['CMR-Hits'])\n\n6\n\n\ngranules = response.json()['feed']['entry']\n#for granule in granules:\n#    print(f'{granule[\"archive_center\"]} {granule[\"dataset_id\"]} {granule[\"id\"]}')\n\npprint(granules)\n\n[{'browse_flag': True,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633258819580078',\n  'id': 'G1954601581-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201017T132009_20201017T132039_034836_040F98_404E.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://datapool.asf.alaska.edu/BROWSE/SA/S1A_EW_GRDM_1SDH_20201017T132009_20201017T132039_034836_040F98_404E.jpg',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34836'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-59.163563 87.942726 -60.893669 89.293564 -59.279579 '\n                '96.119583 -57.619923 94.49958 -59.163563 87.942726']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201017T132009_20201017T132039_034836_040F98_404E',\n  'time_end': '2020-10-17T13:20:39.000Z',\n  'time_start': '2020-10-17T13:20:09.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201017T132009_20201017T132039_034836_040F98_404E-METADATA_GRD_MD',\n  'updated': '2020-10-19T17:13:39.000Z'},\n {'browse_flag': False,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633354187011719',\n  'id': 'G1954616816-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201017T145616_20201017T145720_034837_040FA0_0B4B.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34837'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-66.104271 69.819366 -69.571243 74.741966 -67.42112 83.209152 '\n                '-64.210938 77.59269 -66.104271 69.819366']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201017T145616_20201017T145720_034837_040FA0_0B4B',\n  'time_end': '2020-10-17T14:57:20.000Z',\n  'time_start': '2020-10-17T14:56:16.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201017T145616_20201017T145720_034837_040FA0_0B4B-METADATA_GRD_MD',\n  'updated': '2020-10-19T18:35:34.000Z'},\n {'browse_flag': True,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633354187011719',\n  'id': 'G1954616638-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201017T145720_20201017T145820_034837_040FA0_72CE.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://datapool.asf.alaska.edu/BROWSE/SA/S1A_EW_GRDM_1SDH_20201017T145720_20201017T145820_034837_040FA0_72CE.jpg',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34837'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-62.765087 66.277176 -66.103951 69.81897 -64.211227 77.590164 '\n                '-61.060097 73.427185 -62.765087 66.277176']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201017T145720_20201017T145820_034837_040FA0_72CE',\n  'time_end': '2020-10-17T14:58:20.000Z',\n  'time_start': '2020-10-17T14:57:20.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201017T145720_20201017T145820_034837_040FA0_72CE-METADATA_GRD_MD',\n  'updated': '2020-10-19T18:33:31.000Z'},\n {'browse_flag': True,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633354187011719',\n  'id': 'G1954805829-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201018T135856_20201018T140000_034851_041027_2659.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://datapool.asf.alaska.edu/BROWSE/SA/S1A_EW_GRDM_1SDH_20201018T135856_20201018T140000_034851_041027_2659.jpg',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34851'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-65.236397 83.18071 -68.712318 87.887711 -66.630493 96.161102 '\n                '-63.400326 90.779785 -65.236397 83.18071']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201018T135856_20201018T140000_034851_041027_2659',\n  'time_end': '2020-10-18T14:00:00.000Z',\n  'time_start': '2020-10-18T13:58:56.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201018T135856_20201018T140000_034851_041027_2659-METADATA_GRD_MD',\n  'updated': '2020-10-20T07:16:54.000Z'},\n {'browse_flag': True,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633354187011719',\n  'id': 'G1954799806-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201018T140000_20201018T140100_034851_041027_2777.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://datapool.asf.alaska.edu/BROWSE/SA/S1A_EW_GRDM_1SDH_20201018T140000_20201018T140100_034851_041027_2777.jpg',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34851'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-61.876564 79.848251 -65.236069 83.180344 -63.400402 90.778 '\n                '-60.217258 86.840034 -61.876564 79.848251']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201018T140000_20201018T140100_034851_041027_2777',\n  'time_end': '2020-10-18T14:01:00.000Z',\n  'time_start': '2020-10-18T14:00:00.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201018T140000_20201018T140100_034851_041027_2777-METADATA_GRD_MD',\n  'updated': '2020-10-20T06:51:16.000Z'},\n {'browse_flag': False,\n  'collection_concept_id': 'C1214472336-ASF',\n  'coordinate_system': 'GEODETIC',\n  'data_center': 'ASF',\n  'dataset_id': 'SENTINEL-1A_DUAL_POL_METADATA_GRD_MEDIUM_RES',\n  'day_night_flag': 'UNSPECIFIED',\n  'granule_size': '0.05633258819580078',\n  'id': 'G1954798927-ASF',\n  'links': [{'href': 'https://datapool.asf.alaska.edu/METADATA_GRD_MD/SA/S1A_EW_GRDM_1SDH_20201018T140100_20201018T140148_034851_041027_C95D.iso.xml',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n             'title': 'This link provides direct download access to the '\n                      'granule.'},\n            {'href': 'www.asf.alaska.edu/sar-data-sets/sentinel-1',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 data set landing page (VIEW RELATED '\n                      'INFORMATION)'},\n            {'href': 'www.asf.alaska.edu/sar-information/sentinel-1-documents-tools',\n             'hreflang': 'en-US',\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n             'title': 'ASF DAAC Sentinel-1 User Guide and Technical '\n                      'Documentation (VIEW RELATED INFORMATION)'},\n            {'href': 'https://vertex.daac.asf.alaska.edu/',\n             'hreflang': 'en-US',\n             'inherited': True,\n             'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n  'online_access_flag': True,\n  'orbit_calculated_spatial_domains': [{'orbit_number': '34851'}],\n  'original_format': 'ECHO10',\n  'polygons': [['-59.113174 77.623962 -61.876228 79.847961 -60.217464 '\n                '86.837784 -57.570774 84.174744 -59.113174 77.623962']],\n  'producer_granule_id': 'S1A_EW_GRDM_1SDH_20201018T140100_20201018T140148_034851_041027_C95D',\n  'time_end': '2020-10-18T14:01:48.000Z',\n  'time_start': '2020-10-18T14:01:00.000Z',\n  'title': 'S1A_EW_GRDM_1SDH_20201018T140100_20201018T140148_034851_041027_C95D-METADATA_GRD_MD',\n  'updated': '2020-10-20T06:46:01.000Z'}]"
  },
  {
    "objectID": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#summary",
    "href": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This tutorial will combine several workflow steps and components from the previous days, demonstrating the process of using the geolocation of data available outside of the Earthdata Cloud to then access coincident variables of cloud-accessible data. This may be a common use case as NASA Earthdata continues to migrate to the cloud, producing a “hybrid” data archive across Amazon Web Services (AWS) and original on-premise data storage systems. Additionally, you may also want to combine field measurements with remote sensing data available on the Earthdata Cloud.\nThis specific example explores the harmonization of the ICESat-2 ATL03 data product, currently (as of November 2021) available publicly via direct download at the NSIDC DAAC, with Sea Surface Temperature variables available from PO.DAAC on the Earthdata Cloud.\n\nObjectives\n[TODO]\n\n\n\nImport packages\nimport requests\nimport netrc\nfrom pprint import pprint\nimport os\nfrom pathlib import Path\n\nimport s3fs\n\nimport xarray as xr\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\n# packages below here are not used\n#from xml.etree import ElementTree as ET\n#import time\n#import zipfile\n#import io\n#import shutil\n#import json\n#from urllib import request\n\n\nDetermine storage location of datasets of interest\nFirst, let’s see whether our datasets of interest reside in the Earthdata Cloud or whether they reside on premise, or “on prem” at a local data center.\nBackground from CMR API [TODO: consider removing]: The cloud_hosted parameter can be set to “true” or “false”. When true, the results will be restricted to collections that have a DirectDistributionInformation element or have been tagged with gov.nasa.earthdatacloud.s3.\nWe are building off of the CMR introductory tutorial, beginning with a collection search.\ncmr_search_url = 'https://cmr.earthdata.nasa.gov/search'\nWe want to search by collection to inspect the access and service options that exist:\ncmr_collection_url = f'{cmr_search_url}/{\"collections\"}'\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given dataset id (also referred to as a short_name). Here we’ll start with two datasets that we want to explore over a coincident area and time:\nmodis_name = 'MODIS_A-JPL-L2P-v2019.0'\nicesat2_name = 'ATL03'\nLike in the intro tutorial, we’re going to first determine what concept-ids are returned for the MODIS dataset. First, retrieve collection results based on the MODIS short_name:\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': modis_name,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\nFor each collection result, print out the CMR concept-id and version:\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\nTwo collections are returned, both at version 2019.0. We can see from the suffix of the id that one is associated with “POCLOUD” versus “PODAAC”. That gives us a clue in terms of where the data are hosted, but we can also use the cloud_hosted parameter set to True to confirm.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': modis_name,\n                            'cloud_hosted': 'True',\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\nWe will save this concept-id to use later on when we access the data granules.\nmodis_cloud_id = collections[0][\"id\"]\nNow we will try our ICESat-2 dataset to see what id’s are returned for a given dataset name.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': icesat2_name,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\nTwo separate datasets exist in the CMR, one at version 3 and one at version 4. Let’s see if these are cloud_hosted:\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': icesat2_name,\n                            'cloud_hosted': 'False',\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\nWhen set to False, we get our collections back. We have now determined that we have a copy of the MODIS dataset in the cloud, whereas the ICESat-2 dataset (both versions) remains “on premise”, residing in a local data center.\nSave the ATL03 concept ID and the MODIS GHRSST concept ID to variables:\nicesat2_concept_id = 'C1997321091-NSIDC_ECS'\nmodis_concept_id = 'C1940475563-POCLOUD'\n\nSpecify time range and area of interest\nWe are going to focus on getting data for an area north of Greenland for a single day in June.\nThese bounding_box and temporal variables will be used for data search, subset, and access below\n# Bounding Box spatial parameter in decimal degree 'W,S,E,N' format.\nbounding_box = '-62.8,81.7,-56.4,83'\n\n# Each date in yyyy-MM-ddTHH:mm:ssZ format; date range in start,end format\ntemporal = '2019-06-22T00:00:00Z,2019-06-22T23:59:59Z'\nPerform a granule search over our time and area of interest. How many granules are returned?\ngranule_url = f'{cmr_search_url}/{\"granules\"}'\nresponse = requests.get(granule_url, \n                        params={\n                            'concept_id': icesat2_concept_id,\n                            'temporal': temporal,\n                            'bounding_box': bounding_box,\n                            'page_size': 200,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nprint(response.headers['CMR-Hits'])\nPrint the file names, size, and links:\ngranules = response.json()['feed']['entry']\n\nfor granule in granules:\n    print(f'{granule[\"producer_granule_id\"]} {granule[\"granule_size\"]} {granule[\"links\"][0][\"href\"]}')\n\n\n\nDownload ICESat-2 ATL03 granule\n[TODO] Describe what services are available, including icepyx (provide references), but just direct download for simplicity. Describe that this is being “downloaded” to our cloud environment - what does that mean in terms of cost, etc.\nWe’ve found 2 granules. We’ll download the first one and write it to a file with the same name as the producer_granule_id.\nWe need the url for the granule as well. This is href links we printed out above.\nicesat_id = granules[0][\"producer_granule_id\"]\nicesat_url = granules[0]['links'][0]['href']\nYou need Earthdata login credentials to download data from NASA DAACs. These are the credentials you stored in the .netrc file you setup in previous tutorials.\nWe’ll use the netrc package to retrieve your login and password without exposing them.\ninfo = netrc.netrc()\nlogin, account, password = info.authenticators('urs.earthdata.nasa.gov')\nTo retrieve the granule data, we use the requests.get() method, passing Earthdata login credentials as a tuple using the auth keyword.\nr = requests.get(icesat_url, auth=(login, password))\nThe response returned by requests has the same structure as all the other responses: a header and contents. The header information has information about the response, including the size of the data we downloaded in bytes.\nfor k, v in r.headers.items():\n    print(f'{k}: {v}')\nThe contents needs to be saved to a file. To keep the directory clean, we will create a downloads directory to store the file. We can use a shell command to do this or use the mkdir method from the os package.\nos.mkdir('downloads')\nYou should see a downloads directory in the file browser.\nTo write the data to a file, we use open to open a file. We need to specify that the file is open for writing by using the write-mode w. We also need to specify that we want to write bytes by setting the binary-mode b. This is important because the response contents are bytes. The default mode for open is text-mode. So make sure you use b.\nWe’ll use the with statement context-manager to open the file, write the contents of the response, and then close the file. Once the data in r.content is written sucessfully to the file, or if there is an error, the file is closed by the context-manager.\nWe also need to prepend the downloads path to the filename. We do this using Path from the pathlib package in the standard library.\noutfile = Path('downloads', icesat_id)\nwith open(outfile, 'wb') as f:\n    f.write(r.content)\nCheck to make sure it is downloaded.\nls -l ./downloads\nATL03_20190622061415_12980304_004_01.h5 is an HDF5 file. xarray can open this but you need to tell it which group to read the data from. In this case we read the height data for ground-track 1 left-beam.\noutfile = Path('downloads', icesat_id)\nds = xr.open_dataset(icesat_id, group='/gt1l/heights')\nds\n\n\nDetermine variables of interest: SST, ocean color, chemistry…\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'concept_id': 'C1940475563-POCLOUD',\n                            'cloud_hosted': 'True',\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\nvariables = response['feed']['entry'][0]['associations']['variables']\noutput_format = \"umm_json\"\nvar_url = \"https://cmr.earthdata.nasa.gov/search/variables\"\nfor i in range(len(variables)):\n    response = requests.get(f\"{var_url}.{output_format}?concept-id={variables[i]}\")\n    response = response.json()\n    # print(response['items'][0]['umm'])\n    if 'Name' in response['items'][0]['umm']: pprint(response['items'][0]['umm']['Name'])\n\n\nPull those variables into xarray “in place”\n\nFirst, we need to determine the granules returned from our time and area of interest\nresponse = requests.get(granule_url, \n                        params={\n                            'concept_id': 'C1940475563-POCLOUD',\n                            'temporal': temporal,\n                            'bounding_box': bounding_box,\n                            'page_size': 200,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nprint(response.status_code)\nprint(response.headers['CMR-Hits'])\nmodis_granules_meta = response.json()['feed']['entry']\nfor granule_meta in modis_granules_meta:\n    print(granule_meta['boxes'])\n    print(granule_meta['links'][0]['href'])\nhttps_link = modis_granules_meta[0]['links'][0]['href']\ns3_link = https_link.replace('https://archive.podaac.earthdata.nasa.gov/','s3://')\ns3_link\n\n\n\nGet S3 credentials\ns3_credentials = requests.get('https://archive.podaac.earthdata.nasa.gov/s3credentials').json()\ns3_fs = s3fs.S3FileSystem(\n    key=s3_credentials[\"accessKeyId\"],\n    secret=s3_credentials[\"secretAccessKey\"],\n    token=s3_credentials[\"sessionToken\"],\n)\n\n\nOpen a s3 file\nf = s3_fs.open(s3_link)\nds = xr.open_dataset(f, engine='h5netcdf')\n\n\nUse geolocation of ICESat-2 to define the single transect used to pull coincident ocean data out from array\n\n\nCreate a plot of the single transect of gridded data\n(bonus: time series) - describe what this means to egress out of the cloud versus pulling the original data down (benefit to processing in the cloud)"
  },
  {
    "objectID": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "href": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "title": "",
    "section": "Download MODIS GHRSST data from Cloud",
    "text": "from shapely.geometry import box\nmap_proj = ccrs.PlateCarree()\ndef bbox_geometry(boxs, t_crs=ccrs.NorthPolarStereo()):\n    '''Generates a shapely.geometry.box object from boxes metadata'''\n    lat_min, lon_min, lat_max, lon_max = [float(v) for v in bbox.split()]\n    x_min, y_min = t_crs.transform_point(lon_min, lat_min, ccrs.PlateCarree())\n    x_max, y_max = t_crs.transform_point(lon_max, lat_max, ccrs.PlateCarree())\n    return box(x_min, y_min, x_max, y_max)\n\nbbox_features = []\nfor granule in modis_granules_meta:\n    for bbox in granule['boxes']:\n        bbox_features.append(bbox_geometry(bbox))\nfig = plt.figure(figsize=(7,7))\nax = fig.add_subplot(projection=ccrs.NorthPolarStereo())\nax.set_extent([-180.,180.,60.,90.], ccrs.PlateCarree())\nax.coastlines()\nax.add_geometries([bbox_features[0]], crs=map_proj, alpha=0.3)"
  },
  {
    "objectID": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#resources-optional",
    "href": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#resources-optional",
    "title": "",
    "section": "Resources (optional)",
    "text": ""
  },
  {
    "objectID": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#conclusion",
    "href": "tutorials/08_Data_Access_Harmonize-cloud-non-cloud.html#conclusion",
    "title": "",
    "section": "Conclusion",
    "text": ""
  },
  {
    "objectID": "tutorials/04_NASA_Earthdata_Authentication.html#summary",
    "href": "tutorials/04_NASA_Earthdata_Authentication.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This notebook creates a hidden .netrc file (_netrc for Window OS) with Earthdata login credentials in your home directory. This file is need to access NASA Earthdata assets from a scripting environment like Python.\n\nEarthdata Login\nAn Earthdata Login account is required to access data, as well as discover restricted data, from the NASA Earthdata system. Thus, to access NASA data, you need Earthdata Login. Please visit https://urs.earthdata.nasa.gov to register and manage your Earthdata Login account. This account is free to create and only takes a moment to set up.\n\n\nAuthentication via netrc File\nYou will need a netrc file containing your NASA Earthdata Login credentials in order to execute the notebooks. A netrc file can be created manually within text editor and saved to your home directory. An example of the required content is below.\nmachine urs.earthdata.nasa.gov\nlogin <USERNAME>\npassword <PASSWORD>\n<USERNAME> and <PASSWORD> would be replaced by your actual Earthdata Login username and password respectively."
  },
  {
    "objectID": "tutorials/04_NASA_Earthdata_Authentication.html#import-required-packages",
    "href": "tutorials/04_NASA_Earthdata_Authentication.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "from netrc import netrc\nfrom subprocess import Popen\nfrom platform import system\nfrom getpass import getpass\nimport os\nThe code below will:\n\ncheck what operating system (OS) is being used to determine which netrc file to check for/create (.netrc or _netrc)\ncheck if you have an netrc file, and if so, varify if those credentials are for the Earthdata endpoint\ncreate a netrc file if a netrc file is not present.\n\n\nurs = 'urs.earthdata.nasa.gov'    # Earthdata URL endpoint for authentication\nprompts = ['Enter NASA Earthdata Login Username: ',\n           'Enter NASA Earthdata Login Password: ']\n\n# Determine the OS (Windows machines usually use an '_netrc' file)\nnetrc_name = \"_netrc\" if system()==\"Windows\" else \".netrc\"\n\n# Determine if netrc file exists, and if so, if it includes NASA Earthdata Login Credentials\ntry:\n    netrcDir = os.path.expanduser(f\"~/{netrc_name}\")\n    netrc(netrcDir).authenticators(urs)[0]\n\n# Below, create a netrc file and prompt user for NASA Earthdata Login Username and Password\nexcept FileNotFoundError:\n    homeDir = os.path.expanduser(\"~\")\n    Popen('touch {0}{2} | echo machine {1} >> {0}{2}'.format(homeDir + os.sep, urs, netrc_name), shell=True)\n    Popen('echo login {} >> {}{}'.format(getpass(prompt=prompts[0]), homeDir + os.sep, netrc_name), shell=True)\n    Popen('echo password \\{} >> {}{}'.format(getpass(prompt=prompts[1]), homeDir + os.sep, netrc_name), shell=True)\n    # Set restrictive permissions\n    Popen('chmod 0600 {0}{1}'.format(homeDir + os.sep, netrc_name), shell=True)\n\n    # Determine OS and edit netrc file if it exists but is not set up for NASA Earthdata Login\nexcept TypeError:\n    homeDir = os.path.expanduser(\"~\")\n    Popen('echo machine {1} >> {0}{2}'.format(homeDir + os.sep, urs, netrc_name), shell=True)\n    Popen('echo login {} >> {}{}'.format(getpass(prompt=prompts[0]), homeDir + os.sep, netrc_name), shell=True)\n    Popen('echo password \\{} >> {}{}'.format(getpass(prompt=prompts[1]), homeDir + os.sep, netrc_name), shell=True)\n\nEnter NASA Earthdata Login Username:  ·······\n\n\n\nSee if the file was created\nIf the file was created, we’ll see a .netrc file (_netrc for Window OS) in the list printed below. To view the contents from a Jupyter environment, click File on the top toolbar, select Open from Path…, type .netrc, and click Open. The .netrc file will open within the text editor.\n\n!!! Beware, your password will be visible if the .netrc file is opened in the text editor.\n\n\n!ls -al ~/\n\ntotal 928\ndrwxr-xr-x 14 jovyan jovyan   6144 Nov  4 19:11 .\ndrwxr-xr-x  1 root   root     4096 Oct  4 16:21 ..\n-rw-------  1 jovyan jovyan   7738 Nov  4 17:43 .bash_history\ndrwxr-xr-x  8 jovyan jovyan   6144 Nov  2 17:49 .cache\ndrwxrwsr-x  2 jovyan jovyan   6144 Jun 11 16:31 .conda\ndrwxr-xr-x  4 jovyan jovyan   6144 Nov  2 17:37 .config\ndrwxr-xr-x  2 jovyan jovyan   6144 Jun 11 16:31 .empty\n-rw-r--r--  1 jovyan jovyan     52 Oct 19 20:19 .gitconfig\ndrwxr-xr-x  2 jovyan jovyan   6144 Nov  3 12:58 .ipynb_checkpoints\ndrwxr-xr-x  5 jovyan jovyan   6144 May 13 19:04 .ipython\ndrwxr-xr-x  3 jovyan jovyan   6144 Jun 11 13:09 .jupyter\n-rw-r--r--  1 jovyan jovyan    183 Oct 28 21:32 .jupyter-server-log.txt\ndrwxr-xr-x  3 jovyan jovyan   6144 May 13 19:04 .local\n-rw-------  1 jovyan jovyan     67 Nov  4 19:11 .netrc\ndrwxr-xr-x 10 jovyan jovyan   6144 Nov  4 17:29 2021-Cloud-Hackathon\n-rw-r--r--  1 jovyan jovyan    119 Nov  3 18:07 additional_packages.txt\n-rw-r--r--  1 jovyan jovyan    131 Nov  4 15:55 cookies.txt\ndrwxr-xr-x  5 jovyan jovyan   6144 Nov  4 15:03 corn\n-rw-r--r--  1 jovyan jovyan  11709 Nov  4 14:48 environment.yml\n-rw-r--r--  1 jovyan jovyan 847997 Nov  3 13:35 s6a_atrack_altimetry_demo.ipynb\ndrwxr-xr-x  2 root   root     6144 May 11 19:41 shared\ndrwxr-xr-x  2 root   root     6144 May 11 19:41 shared-readwrite"
  },
  {
    "objectID": "tutorials/Additional_Resources__Data_Access__Direct_S3_Access__PODAAC_ECCO_SSH.html",
    "href": "tutorials/Additional_Resources__Data_Access__Direct_S3_Access__PODAAC_ECCO_SSH.html",
    "title": "",
    "section": "",
    "text": "Direct S3 Data Access - Rough PODAAC ECCO SSH Example"
  },
  {
    "objectID": "tutorials/00_Setup.html#cloud-environment",
    "href": "tutorials/00_Setup.html#cloud-environment",
    "title": "00. Setup for tutorials",
    "section": "Cloud environment",
    "text": "A brief overview about the NASA Openscapes Cloud Environment (following lessons from the Clinic).\n\nCloud infrastructure\n\nCloud: AWS us-west-2\n\nData: AWS S3 (cloud) and NASA DAAC data centers (on-prem).\nCloud compute environment: 2i2c Jupyterhub deployment\n\nIDE: JupyterLab"
  },
  {
    "objectID": "tutorials/00_Setup.html#this-is-how-my-desktop-is-setup",
    "href": "tutorials/00_Setup.html#this-is-how-my-desktop-is-setup",
    "title": "00. Setup for tutorials",
    "section": "This is how my desktop is setup",
    "text": "I’ll screenshare to show and/or talk through how I have oriented the following software we’re using:\n\n2i2c Jupyterhub (our main workspace)\nCloud Hackathon Book (my teaching notes, your reference material)\nZoom Chat\nSlack"
  },
  {
    "objectID": "tutorials/00_Setup.html#fork-the-hackathon-github-repository",
    "href": "tutorials/00_Setup.html#fork-the-hackathon-github-repository",
    "title": "00. Setup for tutorials",
    "section": "Fork the Hackathon GitHub repository",
    "text": "“How do I get the tutorial repository into the Hub?”. There are 2 steps. The first is from GitHub.com to fork the tutorial repository so that there is a connected copy in your user account that you can edit and push changes that won’t affect the nasa-openscapes copy.\nGo to https://github.com/nasa-openscapes/2021-Cloud-Hackathon and fork the repository."
  },
  {
    "objectID": "tutorials/00_Setup.html#python-and-conda-environments",
    "href": "tutorials/00_Setup.html#python-and-conda-environments",
    "title": "00. Setup for tutorials",
    "section": "Python and Conda environments",
    "text": "Why Python?\n\n\n\nPython Data Stack. Source: Jake VanderPlas, “The State of the Stack,” SciPy Keynote (SciPy 2015).\n\n\nDefault Python Environment:\nWe’ve set up the Python environment with conda.\n\n\n\n\n\n\nConda environment\n\n\n\n\n\nname: openscapes\nchannels:\n  - conda-forge\ndependencies:\n  - python=3.9\n  - pangeo-notebook\n  - awscli~=1.20\n  - boto3~=1.19\n  - gdal~=3.3\n  - rioxarray~=0.8\n  - xarray~=0.19\n  - h5netcdf~=0.11\n  - netcdf4~=1.5\n  - h5py~=2.10\n  - geoviews~=1.9\n  - matplotlib-base~=3.4\n  - hvplot~=0.7\n  - pyproj~=3.2\n  - bqplot~=0.12\n  - geopandas~=0.10\n  - zarr~=2.10\n  - cartopy~=0.20\n  - shapely==1.7.1\n  - pyresample~=1.22\n  - joblib~=1.1\n  - pystac-client~=0.3\n  - s3fs~=2021.7\n  - ipyleaflet~=0.14\n  - sidecar~=0.5\n  - jupyterlab-geojson~=3.1\n  - jupyterlab-git\n  - jupyter-resource-usage\n  - ipympl~=0.6\n  - conda-lock~=0.12\n  - pooch~=1.5\n  - pip\n  - pip:\n    - tqdm\n    - harmony-py\n    - earthdata\n    - zarr-eosdis-store\n\n\n\n\nBash terminal and installed software\nLibraries that are available from the terminal\n\ngdal 3.3 commands ( gdalinfo, gdaltransform…)\nhdf5 commands ( h5dump, h5ls..)\nnetcdf4 commands (ncdump, ncinfo …)\njq (parsing json files or streams from curl)\ncurl (fetch resources from the web)\nawscli (AWS API client, to interact with AWS cloud services)\nvim (editor)\ntree ( directory tree)\nmore …\n\n\n\nUpdating the environment\nScientific Python is a vast space and we only included libraries that are needed in our tutorials. Our default environment can be updated to include any Python library that’s available on pip or conda.\nThe project used to create our default environment is called corn (as it can include many Python kernels).\nIf we want to update a library or install a whole new environment we need to open an issue on this repository. We can help your teams do this during project hacktime.\n\n\ncorn 🌽"
  },
  {
    "objectID": "tutorials/00_Setup.html#jupyterhub-orientation",
    "href": "tutorials/00_Setup.html#jupyterhub-orientation",
    "title": "00. Setup for tutorials",
    "section": "JupyterHub orientation",
    "text": "Now that the JupyterHubs have loaded, let’s get oriented.\n\nFirst impressions\nReiterate a few things we just talked about (TODO - what’s useful here Luis?)\n\n“home directory”\nbig blue button\nenvironments we just talked about (?)\n\n\n\nTerminal\nOpen terminal: Big blue “+” button > Terminal\nYou’ll start off in your home directory, /home/jovyan. To confirm this is your present working directory (pwd), type:\npwd"
  },
  {
    "objectID": "tutorials/00_Setup.html#clone-the-hackathon-github-repository",
    "href": "tutorials/00_Setup.html#clone-the-hackathon-github-repository",
    "title": "00. Setup for tutorials",
    "section": "Clone the Hackathon GitHub repository",
    "text": "Now we’ll clone the GitHub repository, using the terminal.\ngit clone https://github.com/YOUR-USERNAME/2021-Cloud-Hackathon\nThese two github steps are also posted in github workflows: first-time setup."
  },
  {
    "objectID": "tutorials/00_Setup.html#jupyter-notebooks",
    "href": "tutorials/00_Setup.html#jupyter-notebooks",
    "title": "00. Setup for tutorials",
    "section": "Jupyter notebooks",
    "text": "Let’s get oriented to Jupyter notebooks, which we’ll use in all the tutorials.\nBig blue button > Notebook > …"
  },
  {
    "objectID": "tutorials/00_Setup.html#how-to-i-end-my-session",
    "href": "tutorials/00_Setup.html#how-to-i-end-my-session",
    "title": "00. Setup for tutorials",
    "section": "How to I end my session?",
    "text": "(Also see How do I end my Openscapes session? Will I lose all of my work?)\nWhen you are finished working for the day it is important to explicitly log out of your Openscapes session. The reason for this is it will save us a bit of money! When you keep a session active it uses up AWS resources and keeps a series of virtual machines deployed.\nStopping the server happens automatically when you log out, so navigate to “File -> Log Out” and just click “Log Out”!\n!!! NOTE “logging out” - Logging out will NOT cause any of your work to be lost or deleted. It simply shuts down some resources. It would be equivalent to turning off your desktop computer at the end of the day."
  },
  {
    "objectID": "tutorials/06_S6_OPeNDAP_Access_Gridding.html#getting-started",
    "href": "tutorials/06_S6_OPeNDAP_Access_Gridding.html#getting-started",
    "title": "",
    "section": "Getting Started",
    "text": "Summary\nDescription goes here…\n\n\nObjectives\nIn this tutorial you will learn…\n\nabout level 2 radar altimetry data from the Sentinel-6 Michael Freilich mission;\nhow to efficiently download variable subsets using OPeNDAP;\nhow to grid the along-track altimetry observations produced by S6 at level 2.;\n\n\n\nRequirements\nThis workflow was developed using Python 3.9 (and tested against versions 3.7, 3.8).\nimport os\nimport os.path\nimport json\nimport warnings\nimport requests\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nfrom tqdm import tqdm\nfrom io import StringIO\nfrom concurrent.futures import ThreadPoolExecutor\nwarnings.filterwarnings(\"ignore\")\nimport pyresample as pr\nfrom pyresample.kd_tree import resample_gauss\n\nprint(\"\\n# TEMPORARY, CHECK ENVIRONMENT:\\n\")\nfor k,v in dict(globals()).items():\n    if 'module' in str(type(v)):\n        if hasattr(v, \"__path__\"):\n            print(f\"  {v.__name__}  \\t{v.__version__ }\\t({v.__path__[0]})\")\n\n\n# TEMPORARY, CHECK ENVIRONMENT:\n\n  json      2.0.9   (/srv/conda/envs/notebook/lib/python3.9/json)\n  requests      2.26.0  (/srv/conda/envs/notebook/lib/python3.9/site-packages/requests)\n  numpy     1.21.4  (/srv/conda/envs/notebook/lib/python3.9/site-packages/numpy)\n  pandas    1.3.4   (/srv/conda/envs/notebook/lib/python3.9/site-packages/pandas)\n  xarray    0.20.1  (/srv/conda/envs/notebook/lib/python3.9/site-packages/xarray)\n  pyresample    1.22.0  (/srv/conda/envs/notebook/lib/python3.9/site-packages/pyresample)\n\n\n\n\nWorkspace\nCreate some directories inside a temporary user workspace. They will be used to write outputs.\nworkspace = \"data/\"\n\nfor d in ['subsets', 'cycles']:\n    os.makedirs(os.path.join(workspace, d), exist_ok=True)\n\nhttps://docs.python.org/3/library/os.html#os.makedirs"
  },
  {
    "objectID": "tutorials/06_S6_OPeNDAP_Access_Gridding.html#datasets",
    "href": "tutorials/06_S6_OPeNDAP_Access_Gridding.html#datasets",
    "title": "",
    "section": "Dataset(s)",
    "text": "This example operates on Level 2 Low Resolution Altimetry from Sentinel-6 Michael Freilich (the Near Real Time Reduced distribution). It is most easily identified by its collection ShortName, given below:\nShortName = 'JASON_CS_S6A_L2_ALT_LR_RED_OST_NRT_F'\nSearch CMR using a simple function that wraps requests.get:\n\ncollection\n\nresponse = requests.get(url=f\"https://cmr.earthdata.nasa.gov/search/collections.umm_json\", \n                        params=dict(ShortName=ShortName))\n\nprint('hits:', response.headers[\"cmr-hits\"])\n\nhits: 1\n\n\nGet the collection’s concept-id from the record’s meta object. It uniquely identifies the collection in the CMR and is a component of the OPeNDAP endpoints for its granules.\n\ncollection = response.json().get(\"items\")[0]\n\nconcept_id = collection.get(\"meta\").get(\"concept-id\")\n\nprint(concept_id)\n\nC1968980576-POCLOUD\n\n\n\nhttps://docs.python-requests.org/en/latest/api/#requests.get\n\n\n\ngranules\n\nresponse = requests.get(url=f\"https://cmr.earthdata.nasa.gov/search/granules.csv\", \n                        params=dict(ShortName=ShortName, page_size=2000))\n\nprint('hits:', response.headers[\"cmr-hits\"])\n\nhits: 1783\n\n\n\nhttps://docs.python.org/3/library/io.html#io.StringIO\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html\nhttps://docs.python-requests.org/en/latest/api/#requests.get\n\n\ngranules = pd.read_csv(StringIO(response.text))\n\ngranules.head()\n\n\n\n\n  \n    \n      \n      Granule UR\n      Producer Granule ID\n      Start Time\n      End Time\n      Online Access URLs\n      Browse URLs\n      Cloud Cover\n      Day/Night\n      Size\n    \n  \n  \n    \n      0\n      S6A_P4_2__LR_RED__NR_022_215_20210622T065556_2...\n      NaN\n      2021-06-22T06:55:56.542Z\n      2021-06-22T08:51:49.469Z\n      https://archive.podaac.earthdata.nasa.gov/poda...\n      NaN\n      NaN\n      UNSPECIFIED\n      5.447547\n    \n    \n      1\n      S6A_P4_2__LR_RED__NR_022_217_20210622T085149_2...\n      NaN\n      2021-06-22T08:51:49.519Z\n      2021-06-22T10:47:27.453Z\n      https://archive.podaac.earthdata.nasa.gov/poda...\n      NaN\n      NaN\n      UNSPECIFIED\n      0.308941\n    \n    \n      2\n      S6A_P4_2__LR_RED__NR_022_219_20210622T104727_2...\n      NaN\n      2021-06-22T10:47:27.504Z\n      2021-06-22T12:43:06.457Z\n      https://archive.podaac.earthdata.nasa.gov/poda...\n      NaN\n      NaN\n      UNSPECIFIED\n      5.511004\n    \n    \n      3\n      S6A_P4_2__LR_RED__NR_022_221_20210622T124306_2...\n      NaN\n      2021-06-22T12:43:06.507Z\n      2021-06-22T14:21:12.461Z\n      https://archive.podaac.earthdata.nasa.gov/poda...\n      NaN\n      NaN\n      UNSPECIFIED\n      2.322583\n    \n    \n      4\n      S6A_P4_2__LR_RED__NR_022_223_20210622T142112_2...\n      NaN\n      2021-06-22T14:21:12.511Z\n      2021-06-22T16:14:50.491Z\n      https://archive.podaac.earthdata.nasa.gov/poda...\n      NaN\n      NaN\n      UNSPECIFIED\n      5.497045\n    \n  \n\n\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html\n\nDisplay the list of items created by splitting the a value in the Granule UR field.\n\ngranules['Granule UR'].iloc[0].split(\"_\")\n\n['S6A',\n 'P4',\n '2',\n '',\n 'LR',\n 'RED',\n '',\n 'NR',\n '022',\n '215',\n '20210622T065556',\n '20210622T085149',\n 'F02']\n\n\nReferences:\nhttps://docs.python.org/3/library/stdtypes.html#str.split\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html\nNote that cycle and pass are items 8 and 9, respectively, after splitting the Granule UR field by _. Add two columns containing the cycle/pass numbers for granules in the table.\n\ngranules = granules[['Granule UR', 'Start Time', 'End Time', 'Online Access URLs']].copy()\n\ngranules['cycle'] = granules['Granule UR'].apply(lambda x: x.split(\"_\")[8])\n\ngranules['pass'] = granules['Granule UR'].apply(lambda x: x.split(\"_\")[9])\n\ngranules.iloc[0]\n\nGranule UR            S6A_P4_2__LR_RED__NR_022_215_20210622T065556_2...\nStart Time                                     2021-06-22T06:55:56.542Z\nEnd Time                                       2021-06-22T08:51:49.469Z\nOnline Access URLs    https://archive.podaac.earthdata.nasa.gov/poda...\ncycle                                                               022\npass                                                                215\nName: 0, dtype: object\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.copy.html\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.apply.html\nhttps://docs.python.org/3/reference/expressions.html#lambda\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html\n\nNow create a table with one row per cycle and with these columns:\n\nstart time\nend time\ngranule names (list)\n\n\ntmp = granules.groupby(\"cycle\")\n\ncycles = tmp['pass'].count().to_frame(\"count\")\n\ncycles['start'] = tmp['Start Time'].apply(lambda x: x.tolist()) \\\n                                   .apply(sorted) \\\n                                   .apply(lambda x: x[0])  # index 0\n\ncycles['end']   = tmp['End Time'].apply(lambda x: x.tolist()) \\\n                                 .apply(sorted) \\\n                                 .apply(lambda x: x[-1])  # index -1\n\ncycles['grans'] = tmp['Granule UR'].apply(lambda x: x.tolist())\n\ndisplay(cycles)\n\n\n\n\n  \n    \n      \n      count\n      start\n      end\n      grans\n    \n    \n      cycle\n      \n      \n      \n      \n    \n  \n  \n    \n      022\n      20\n      2021-06-22T06:55:56.542Z\n      2021-06-23T20:29:40.464Z\n      [S6A_P4_2__LR_RED__NR_022_215_20210622T065556_...\n    \n    \n      023\n      126\n      2021-06-23T20:29:40.515Z\n      2021-07-03T18:28:12.477Z\n      [S6A_P4_2__LR_RED__NR_023_001_20210623T202940_...\n    \n    \n      024\n      122\n      2021-07-03T18:28:12.528Z\n      2021-07-13T16:26:44.463Z\n      [S6A_P4_2__LR_RED__NR_024_001_20210703T182812_...\n    \n    \n      025\n      125\n      2021-07-13T16:26:44.514Z\n      2021-07-23T14:25:14.452Z\n      [S6A_P4_2__LR_RED__NR_025_001_20210713T162644_...\n    \n    \n      026\n      126\n      2021-07-23T14:25:15.513Z\n      2021-08-02T12:23:46.465Z\n      [S6A_P4_2__LR_RED__NR_026_001_20210723T142515_...\n    \n    \n      027\n      126\n      2021-08-02T12:23:46.515Z\n      2021-08-12T10:22:45.463Z\n      [S6A_P4_2__LR_RED__NR_027_001_20210802T122346_...\n    \n    \n      028\n      125\n      2021-08-12T10:22:45.514Z\n      2021-08-22T08:21:16.466Z\n      [S6A_P4_2__LR_RED__NR_028_001_20210812T102245_...\n    \n    \n      029\n      125\n      2021-08-22T08:21:16.516Z\n      2021-09-01T06:19:48.489Z\n      [S6A_P4_2__LR_RED__NR_029_001_20210822T082116_...\n    \n    \n      030\n      118\n      2021-09-01T06:19:48.540Z\n      2021-09-11T04:18:20.452Z\n      [S6A_P4_2__LR_RED__NR_030_001_20210901T061948_...\n    \n    \n      031\n      111\n      2021-09-11T04:18:20.503Z\n      2021-09-21T02:16:52.490Z\n      [S6A_P4_2__LR_RED__NR_031_001_20210911T041820_...\n    \n    \n      032\n      126\n      2021-09-21T02:16:52.541Z\n      2021-10-01T00:15:23.477Z\n      [S6A_P4_2__LR_RED__NR_032_001_20210921T021652_...\n    \n    \n      033\n      127\n      2021-10-01T00:15:23.528Z\n      2021-10-10T22:13:54.473Z\n      [S6A_P4_2__LR_RED__NR_033_001_20211001T001523_...\n    \n    \n      034\n      127\n      2021-10-10T22:13:54.523Z\n      2021-10-20T20:12:26.484Z\n      [S6A_P4_2__LR_RED__NR_034_001_20211010T221354_...\n    \n    \n      035\n      127\n      2021-10-20T20:12:26.534Z\n      2021-10-30T18:10:57.471Z\n      [S6A_P4_2__LR_RED__NR_035_001_20211020T201226_...\n    \n    \n      036\n      127\n      2021-10-30T18:10:57.521Z\n      2021-11-09T16:09:28.454Z\n      [S6A_P4_2__LR_RED__NR_036_001_20211030T181057_...\n    \n    \n      037\n      25\n      2021-11-09T16:09:28.504Z\n      2021-11-11T14:58:45.468Z\n      [S6A_P4_2__LR_RED__NR_037_001_20211109T160928_...\n    \n  \n\n\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.to_frame.html\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html\n\n\n\nPick a cycle of interest\nPick one cycle that is nearly complete, >= 120 orbits/files. Limit options to cycles with at least 120 granules/files available (i.e. orbits in S6 context).\n\ncycles = cycles[cycles['count']>=120].copy()\n\ncycles.index.tolist()\n\n['023',\n '024',\n '025',\n '026',\n '027',\n '028',\n '029',\n '032',\n '033',\n '034',\n '035',\n '036']\n\n\nChoose from the nearly-complete cycles that remain in the table, which start with cycle number 023 for S6 data in the public domain (and start on June 22). Slice the table of granules to exclude all rows that are not from the cycle of interest.\n\nmy_cycle = 25\n\ngranules = granules[granules.cycle.astype(int)==my_cycle].copy()\n\ngranules.index.size\n\n125\n\n\n\n\nOPeNDAP Access Endpoints\nAll endpoints for granules/files in OPeNDAP/Hyrax start with the server hostname and path to the parent collection, followed by granules. The collection is specified by the concept-id given right after collections in a valid url. The next cell formats a string giving the base url to which we will append granule filenames (stored in the Granule UR column of the granules table) to get the full url/endpoint for each granule.\nFyi, the url printed by this cell will not be accessible from your web browser.\n\ncollection_opendap_endpoint = f\"https://opendap.earthdata.nasa.gov/collections/{concept_id}/granules\"\n\nprint(collection_opendap_endpoint)\n\nhttps://opendap.earthdata.nasa.gov/collections/C1968980576-POCLOUD/granules\n\n\n\nhttps://docs.python.org/3/library/string.html#format-string-syntax\n\nAppending the granule name (taken from the Granule UR column) to the end of the url above results in a valid endpoint. You can click the one printed by this cell to confirm. A new browser tab should open to the HTML access form served by Hyrax/OPeNDAP.\nMake a new column with the nc4 download url for all granules.\n\ngranules['nc4'] = granules['Granule UR'].apply(lambda x: f\"{collection_opendap_endpoint}/{x}.nc4\")\n\ngranules.info()\n\n<class 'pandas.core.frame.DataFrame'>\nInt64Index: 125 entries, 268 to 392\nData columns (total 7 columns):\n #   Column              Non-Null Count  Dtype \n---  ------              --------------  ----- \n 0   Granule UR          125 non-null    object\n 1   Start Time          125 non-null    object\n 2   End Time            125 non-null    object\n 3   Online Access URLs  125 non-null    object\n 4   cycle               125 non-null    object\n 5   pass                125 non-null    object\n 6   nc4                 125 non-null    object\ndtypes: object(7)\nmemory usage: 7.8+ KB\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html\n\n\nPick target data/coordinate variables\nDisplay the url to access the DDS file for the first granule:\n\ndds = f\"{collection_opendap_endpoint}/{granules['Granule UR'].iloc[0]}.dds\"\n\nwith requests.get(url=dds) as r:\n    print(r.text)\n\nDataset {\n    Int16 data_01_rad_tb_238[data_01_time = 6950];\n    Int16 data_01_rad_wet_tropo_cor[data_01_time = 6950];\n    Int16 data_01_wind_speed_mod_v[data_01_time = 6950];\n    Int32 data_01_rad_distance_to_land[data_01_time = 6950];\n    Int16 data_01_rad_tmb_340_qual[data_01_time = 6950];\n    Int16 data_01_iono_cor_alt_filtered_mle3[data_01_time = 6950];\n    Int16 data_01_rad_tmb_187_qual[data_01_time = 6950];\n    Int16 data_01_rad_water_vapor[data_01_time = 6950];\n    Int16 data_01_mean_sea_surface_sol1_qual[data_01_time = 6950];\n    Int16 data_01_climato_use_flag[data_01_time = 6950];\n    Int16 data_01_wind_speed_mod_u[data_01_time = 6950];\n    Int16 data_01_distance_to_coast[data_01_time = 6950];\n    Int16 data_01_pass_direction_flag[data_01_time = 6950];\n    Int32 data_01_altitude_rate_mean_sea_surface[data_01_time = 6950];\n    Int16 data_01_mean_sea_surface_sol2_acc[data_01_time = 6950];\n    Int16 data_01_model_dry_tropo_cor_measurement_altitude[data_01_time = 6950];\n    Int16 data_01_rad_tmb_187[data_01_time = 6950];\n    Int16 data_01_pole_tide[data_01_time = 6950];\n    Int16 data_01_rad_tmb_238[data_01_time = 6950];\n    Int16 data_01_mean_dynamic_topography_acc[data_01_time = 6950];\n    Int16 data_01_rad_land_frac_238[data_01_time = 6950];\n    Int16 data_01_load_tide_sol2[data_01_time = 6950];\n    Int16 data_01_ocean_tide_non_eq[data_01_time = 6950];\n    Int16 data_01_ocean_tide_sol1_qual[data_01_time = 6950];\n    Int16 data_01_iono_cor_alt_filtered[data_01_time = 6950];\n    Int16 data_01_rad_water_vapor_qual[data_01_time = 6950];\n    Int16 data_01_depth_or_elevation[data_01_time = 6950];\n    Int16 data_01_rad_tb_340[data_01_time = 6950];\n    Int32 data_01_off_nadir_roll_angle_pf[data_01_time = 6950];\n    Int16 data_01_rad_tb_187_qual[data_01_time = 6950];\n    Int16 data_01_rad_tb_238_qual[data_01_time = 6950];\n    Int32 data_01_longitude[data_01_time = 6950];\n    Int16 data_01_manoeuvre_flag[data_01_time = 6950];\n    Int32 data_01_latitude[data_01_time = 6950];\n    Int16 data_01_model_dry_tropo_cor_zero_altitude[data_01_time = 6950];\n    Int16 data_01_orbit_type_flag[data_01_time = 6950];\n    Int32 data_01_mean_sea_surface_sol1[data_01_time = 6950];\n    Int16 data_01_solid_earth_tide[data_01_time = 6950];\n    Int16 data_01_c_net_instr_cor_sig0_ocean[data_01_time = 6950];\n    Int32 data_01_c_net_instr_cor_range_ocean[data_01_time = 6950];\n    Int16 data_01_c_rad_atm_cor_sig0_qual[data_01_time = 6950];\n    Int16 data_01_c_sig0_ocean_numval[data_01_time = 6950];\n    Int32 data_01_c_range_ocean[data_01_time = 6950];\n    Int16 data_01_c_swh_ocean_rms[data_01_time = 6950];\n    Int16 data_01_c_sig0_ocean[data_01_time = 6950];\n    Int16 data_01_c_net_instr_cor_swh_ocean[data_01_time = 6950];\n    Int16 data_01_c_sig0_ocean_rms[data_01_time = 6950];\n    Int16 data_01_c_sea_state_bias[data_01_time = 6950];\n    Int16 data_01_c_range_ocean_rms[data_01_time = 6950];\n    Int16 data_01_c_swh_ocean_numval[data_01_time = 6950];\n    Int16 data_01_c_swh_ocean[data_01_time = 6950];\n    Int16 data_01_c_iono_cor_gim[data_01_time = 6950];\n    Int16 data_01_c_swh_ocean_qual[data_01_time = 6950];\n    Int32 data_01_c_index_first_20hz_measurement[data_01_time = 6950];\n    Int32 data_01_c_model_instr_cor_range_ocean[data_01_time = 6950];\n    Int16 data_01_c_range_ocean_qual[data_01_time = 6950];\n    Int16 data_01_c_sig0_ocean_qual[data_01_time = 6950];\n    Int16 data_01_c_model_instr_cor_swh_ocean[data_01_time = 6950];\n    Int16 data_01_c_atm_cor_sig0[data_01_time = 6950];\n    Int16 data_01_c_model_instr_cor_sig0_ocean[data_01_time = 6950];\n    Int16 data_01_c_range_ocean_numval[data_01_time = 6950];\n    Int32 data_01_c_range_cor_doppler[data_01_time = 6950];\n    Int16 data_01_c_numtotal_20hz_measurement[data_01_time = 6950];\n    Int16 data_01_dac[data_01_time = 6950];\n    Int16 data_01_surface_classification_flag[data_01_time = 6950];\n    Float64 data_01_time_tai[data_01_time = 6950];\n    Int32 data_01_altitude[data_01_time = 6950];\n    Int32 data_01_off_nadir_pitch_angle_pf[data_01_time = 6950];\n    Int16 data_01_rain_attenuation[data_01_time = 6950];\n    Int16 data_01_ocean_tide_eq[data_01_time = 6950];\n    Int16 data_01_mean_dynamic_topography_qual[data_01_time = 6950];\n    Int32 data_01_delta_ellipsoid_tp_wgs84[data_01_time = 6950];\n    Int16 data_01_rad_tmb_340[data_01_time = 6950];\n    Int16 data_01_rad_rain_flag[data_01_time = 6950];\n    Int16 data_01_rad_tb_340_qual[data_01_time = 6950];\n    Int16 data_01_mean_sea_surface_sol2_qual[data_01_time = 6950];\n    Int16 data_01_rad_surface_type_flag[data_01_time = 6950];\n    Int16 data_01_rad_land_frac_340[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_mle3_qual[data_01_time = 6950];\n    Int16 data_01_ku_net_instr_cor_sig0_ocean[data_01_time = 6950];\n    Int32 data_01_ku_net_instr_cor_range_ocean[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_mle3_rms[data_01_time = 6950];\n    Int16 data_01_ku_rad_atm_cor_sig0_qual[data_01_time = 6950];\n    Int16 data_01_ku_sea_state_bias_mle3[data_01_time = 6950];\n    Int16 data_01_ku_off_nadir_angle_wf_ocean_rms[data_01_time = 6950];\n    Int32 data_01_ku_net_instr_cor_range_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_net_instr_cor_swh_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_numval[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_mle3_qual[data_01_time = 6950];\n    Int32 data_01_ku_range_ocean[data_01_time = 6950];\n    Int32 data_01_ku_ssha_mle3[data_01_time = 6950];\n    Int16 data_01_ku_model_instr_cor_sig0_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_rms[data_01_time = 6950];\n    Int16 data_01_ku_net_instr_cor_sig0_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_mle3_numval[data_01_time = 6950];\n    Int16 data_01_ku_net_instr_cor_swh_ocean[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_mle3_numval[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_off_nadir_angle_wf_ocean_numval[data_01_time = 6950];\n    Int16 data_01_ku_model_instr_cor_off_nadir_angle_wf_ocean[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_rms[data_01_time = 6950];\n    Int16 data_01_ku_sea_state_bias[data_01_time = 6950];\n    Int32 data_01_ku_ocean_geo_corrections_mle3[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_rms[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_numval[data_01_time = 6950];\n    Int16 data_01_ku_off_nadir_angle_wf_ocean[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean[data_01_time = 6950];\n    Int16 data_01_ku_iono_cor_gim[data_01_time = 6950];\n    Int32 data_01_ku_ocean_geo_corrections[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_mle3_qual[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_qual[data_01_time = 6950];\n    Int32 data_01_ku_index_first_20hz_measurement[data_01_time = 6950];\n    Int32 data_01_ku_model_instr_cor_range_ocean[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_qual[data_01_time = 6950];\n    Int32 data_01_ku_model_instr_cor_range_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_qual[data_01_time = 6950];\n    Int32 data_01_ku_range_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_mle3_numval[data_01_time = 6950];\n    Int16 data_01_ku_net_instr_cor_off_nadir_angle_wf_ocean[data_01_time = 6950];\n    Int16 data_01_ku_off_nadir_angle_wf_ocean_qual[data_01_time = 6950];\n    Int32 data_01_ku_ssha[data_01_time = 6950];\n    Int16 data_01_ku_model_instr_cor_swh_ocean[data_01_time = 6950];\n    Int16 data_01_ku_model_instr_cor_swh_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_mle3_rms[data_01_time = 6950];\n    Int16 data_01_ku_atm_cor_sig0[data_01_time = 6950];\n    Int16 data_01_ku_model_instr_cor_sig0_ocean[data_01_time = 6950];\n    Int16 data_01_ku_swh_ocean_mle3[data_01_time = 6950];\n    Int16 data_01_ku_range_ocean_numval[data_01_time = 6950];\n    Int32 data_01_ku_range_cor_doppler[data_01_time = 6950];\n    Int16 data_01_ku_sig0_ocean_mle3_rms[data_01_time = 6950];\n    Int16 data_01_ku_numtotal_20hz_measurement[data_01_time = 6950];\n    Int16 data_01_iono_cor_alt_mle3[data_01_time = 6950];\n    Int16 data_01_load_tide_sol1[data_01_time = 6950];\n    Int16 data_01_rad_wet_tropo_cor_qual[data_01_time = 6950];\n    Int16 data_01_rad_land_frac_187[data_01_time = 6950];\n    Int16 data_01_rad_tb_187[data_01_time = 6950];\n    Int16 data_01_inv_bar_cor[data_01_time = 6950];\n    Int32 data_01_geoid[data_01_time = 6950];\n    Int16 data_01_internal_tide[data_01_time = 6950];\n    Int16 data_01_mean_dynamic_topography[data_01_time = 6950];\n    Int32 data_01_altitude_rate[data_01_time = 6950];\n    Int16 data_01_rad_sea_ice_flag[data_01_time = 6950];\n    Int16 data_01_rad_wind_speed[data_01_time = 6950];\n    Int16 data_01_total_electron_content[data_01_time = 6950];\n    Int16 data_01_ocean_tide_sol2[data_01_time = 6950];\n    Int16 data_01_angle_of_approach_to_coast[data_01_time = 6950];\n    Int16 data_01_meteo_map_availability_flag[data_01_time = 6950];\n    Int32 data_01_l2_record_counter[data_01_time = 6950];\n    Int16 data_01_wind_speed_alt[data_01_time = 6950];\n    Int16 data_01_rad_state_oper_flag[data_01_time = 6950];\n    Int16 data_01_wind_speed_alt_mle3[data_01_time = 6950];\n    Int16 data_01_rain_flag[data_01_time = 6950];\n    Int32 data_01_mean_sea_surface_sol2[data_01_time = 6950];\n    Int16 data_01_rad_wind_speed_qual[data_01_time = 6950];\n    Int16 data_01_rad_cloud_liquid_water_qual[data_01_time = 6950];\n    Int16 data_01_iono_cor_alt[data_01_time = 6950];\n    Int16 data_01_rad_tmb_238_qual[data_01_time = 6950];\n    Int16 data_01_ocean_tide_sol1[data_01_time = 6950];\n    Int16 data_01_ocean_tide_sol2_qual[data_01_time = 6950];\n    Int16 data_01_rad_cloud_liquid_water[data_01_time = 6950];\n    Int16 data_01_model_wet_tropo_cor_zero_altitude[data_01_time = 6950];\n    Int16 data_01_mean_sea_surface_sol1_acc[data_01_time = 6950];\n    Int32 data_01_off_nadir_yaw_angle_pf[data_01_time = 6950];\n    Int16 data_01_model_wet_tropo_cor_measurement_altitude[data_01_time = 6950];\n    Float64 data_01_time[data_01_time = 6950];\n} S6A_P4_2__LR_RED__NR_025_001_20210713T162644_20210713T182234_F02.nc;\n\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html\n\nAssemble the list of target variables that you will subset from each granule/file using OPeNDAP.\nvariables = ['data_01_time',\n             'data_01_longitude',\n             'data_01_latitude',\n             'data_01_ku_ssha', ]\n\nhttps://docs.python.org/3/library/stdtypes.html#list\n\nJoin the list of variables with commas and append the resulting string to the end of each opendap nc4 endpoint created during the steps above. The variables given after the ? will be subset from the source file on the server-side into a new netCDF4 file that OPeNDAP returns in response content which is downloaded over https.\nHere’s an example for the first granule in the selected cycle. Clicking this link should download a netCDF4 containing the target variables (4 of them, in my case). *You may be prompted to authenticate with your Earthdata Login account info.\n\ngranules['subset'] = granules['nc4'].apply(lambda url: f\"{url}?{','.join(variables)}\")\n\nprint(granules['subset'].iloc[0])\n\nhttps://opendap.earthdata.nasa.gov/collections/C1968980576-POCLOUD/granules/S6A_P4_2__LR_RED__NR_025_001_20210713T162644_20210713T182234_F02.nc4?data_01_time,data_01_longitude,data_01_latitude,data_01_ku_ssha\n\n\n\nhttps://opendap.github.io/documentation/UserGuideComprehensive.html#Constraint_Expressions (Hyrax/OPeNDAP docs)\n\n\n\n\nDownload subsets\nThis function downloads one granule from the remote url to a local target path, and will reliably manage simultaneous streaming downloads divided between multiple threads.\ndef download(url: str, target: str, force: bool=False):\n    if not os.path.isfile(target) or force is True:\n        with requests.get(url) as response, open(target, 'wb') as file:\n            if not response.status_code // 100 == 2: \n                raise Exception(response.text)\n            for chunk in response.iter_content(chunk_size=1024):\n                if chunk:\n                    file.write(chunk)\n    return target\n\nhttps://docs.python.org/3/library/os.path.html#os.path.isfile\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.text\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.status_code\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.iter_content\n\n#!ls data/subsets/*NR_025*.nc4 | wc -l\n#!rm data/subsets/*NR_025*.nc4\nThis next cell assembles a list of local paths for the subset downloads.\nCalling tolist on the resulting Series will convert it to a Python list (by way of the numpy method, tolist). Use zip merge the lists of subset urls and local paths, itemwise. The result will be a list of lists, each length two and containing a remote url and local path (corresponding to two positional arguments in the download function that will be defined in a subsequent cell).\n\ndownload_targets = granules['Granule UR'].apply(lambda x: f\"data/subsets/{x}.nc4\")\n\ndownload_arguments = list(zip(granules['subset'].tolist(), download_targets.tolist()))\n\ntype(download_arguments), len(download_arguments)\n\n(list, 125)\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.tolist.html\n\nThis next cell creates a pool of workers to divide the list of downloads between multiple threads.\nUse the ThreadPoolExecutor from concurrent.futures module (in the Python 3 standard library) to divide the 120+ download jobs between multiple threads and run them concurrently. This should take no more than a minute or two to process all subsets on the server side and download to the local host.\n\nwith ThreadPoolExecutor(max_workers=12) as pool:\n    \n    workers = pool.map(lambda x: download(*x), download_arguments)\n    \n    granules['local'] = list(tqdm(workers, total=len(download_arguments)))\n\n100%|██████████| 125/125 [00:00<00:00, 4377.71it/s]\n\n\n\nhttps://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor\n\nThe source files range from 2.5MB to 3.0MB. These OPeNDAP subsets are ~100KB apiece. (anecdote: it took less than 10 minutes to download subsets for >1700 granules/files when I ran this routine for all cycles going back to 2021-06-22.) Here we call the shell du and ls utilities to get the size of the directory:\n\n%%bash\n\ndu -sh data/subsets/\n\nls data/subsets/*.nc4 | wc -l\n\n184M    data/subsets/\n1758\n\n\n\nhttps://www.gnu.org/software/coreutils/manual/html_node/du-invocation.html\n\nConfirm that a netcdf file exists on disk for all the file paths in the local column.\n\ngranules['local'].apply(os.path.isfile).all()\n\nTrue\n\n\n\nhttps://docs.python.org/3/library/functions.html#sorted\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.all.html\n\n\n\nAggregate to cycle\nMake a dictionary to rename variables so that the data_01_ prefix is removed from each one.\n\nnew_variable_names = list(map(lambda x: x.split(\"_\")[-1], variables))\n\nmap_variable_names = dict(zip(variables, new_variable_names))\n\nmap_variable_names\n\n{'data_01_time': 'time',\n 'data_01_longitude': 'longitude',\n 'data_01_latitude': 'latitude',\n 'data_01_ku_ssha': 'ssha'}\n\n\nReferences:\nhttps://docs.python.org/3/library/functions.html#map\nhttps://docs.python.org/3/library/functions.html#zip\nSort the list of local paths to the downloaded subsets to ensure they concatenate in proper order. Call open_mfdataset on the list to open all the subsets in memory as one dataset in xarray.\n\nlocal = sorted(granules['local'].tolist())\n\ndataset = xr.open_mfdataset(local).rename(map_variable_names)\n\nprint(dataset)\n\n<xarray.Dataset>\nDimensions:    (time: 827001)\nCoordinates:\n  * time       (time) datetime64[ns] 2021-07-13T16:26:45 ... 2021-07-23T14:25:14\nData variables:\n    longitude  (time) float64 dask.array<chunksize=(6950,), meta=np.ndarray>\n    latitude   (time) float64 dask.array<chunksize=(6950,), meta=np.ndarray>\n    ssha       (time) float64 dask.array<chunksize=(6950,), meta=np.ndarray>\nAttributes: (12/63)\n    Convention:                             CF-1.7\n    institution:                            EUMETSAT\n    references:                             Sentinel-6_Jason-CS ALT Generic P...\n    contact:                                ops@eumetsat.int\n    radiometer_sensor_name:                 AMR-C\n    doris_sensor_name:                      DORIS\n    ...                                     ...\n    xref_solid_earth_tide:                  S6__P4_2__SETD_AX_20151008T000000...\n    xref_surface_classification:            S6__P4____SURF_AX_20151008T000000...\n    xref_wind_speed_alt:                    S6A_P4_2__WNDL_AX_20151008T000000...\n    product_name:                           S6A_P4_2__LR______20210713T162644...\n    history:                                2021-07-13 18:38:07 : Creation\\n2...\n    history_json:                           [{\"$schema\":\"https:\\/\\/harmony.ea...\n\n\n\nhttps://tqdm.github.io/docs/tqdm/#pandas\nhttps://xarray.pydata.org/en/stable/generated/xarray.open_mfdataset.html\nhttps://xarray.pydata.org/en/stable/generated/xarray.Dataset.rename.html\n\n\n\nRender along-track altimetry data to the ECCO grid\n\nAcknowledgement This approach using pyresample was shared to me by Ian Fenty, ECCO Lead.\n\nECCO V4r4 products are distributed in two spatial formats. One set of collections provides the ocean state estimates on the native model grid (LLC0090) and the other provides them after interpolating to a regular grid defined in geographic coordinates with horizontal cell size of 0.5-degrees.\n\nDownload the ECCO V4r4 0.5-Deg Grid Geometry and Mask\nIt’s distributed as its own dataset/collection containing just one file. We can access it over OPeNDAP like demonstrated above or simply download it from the HTTPS download endpoint – the file size is inconsequential. The next cell downloads the file into the data folder from the granule’s https endpoint.\n\necco_url = \"https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/ECCO_L4_GEOMETRY_05DEG_V4R4/GRID_GEOMETRY_ECCO_V4r4_latlon_0p50deg.nc\"\n\necco_file = download(ecco_url, target=f\"data/{os.path.basename(ecco_url)}\")\n\necco_grid = xr.open_dataset(ecco_file)\n\nprint(ecco_grid)\n\n<xarray.Dataset>\nDimensions:         (Z: 50, latitude: 360, longitude: 720, nv: 2)\nCoordinates:\n  * Z               (Z) float32 -5.0 -15.0 -25.0 ... -5.461e+03 -5.906e+03\n  * latitude        (latitude) float32 -89.75 -89.25 -88.75 ... 89.25 89.75\n  * longitude       (longitude) float32 -179.8 -179.2 -178.8 ... 179.2 179.8\n    latitude_bnds   (latitude, nv) float32 ...\n    longitude_bnds  (longitude, nv) float32 ...\n    Z_bnds          (Z, nv) float32 ...\nDimensions without coordinates: nv\nData variables:\n    hFacC           (Z, latitude, longitude) float64 ...\n    Depth           (latitude, longitude) float64 ...\n    area            (latitude, longitude) float64 ...\n    drF             (Z) float32 ...\n    maskC           (Z, latitude, longitude) bool ...\nAttributes: (12/57)\n    acknowledgement:                 This research was carried out by the Jet...\n    author:                          Ian Fenty and Ou Wang\n    cdm_data_type:                   Grid\n    comment:                         Fields provided on a regular lat-lon gri...\n    Conventions:                     CF-1.8, ACDD-1.3\n    coordinates_comment:             Note: the global 'coordinates' attribute...\n    ...                              ...\n    references:                      ECCO Consortium, Fukumori, I., Wang, O.,...\n    source:                          The ECCO V4r4 state estimate was produce...\n    standard_name_vocabulary:        NetCDF Climate and Forecast (CF) Metadat...\n    summary:                         This dataset provides geometric paramete...\n    title:                           ECCO Geometry Parameters for the 0.5 deg...\n    uuid:                            b4795c62-86e5-11eb-9c5f-f8f21e2ee3e0\n\n\n\nhttps://docs.python.org/3/library/os.path.html#os.path.basename\nhttps://xarray.pydata.org/en/stable/generated/xarray.open_dataset.html\n\nThe maskC variable contains a boolean mask representing the wet/dry state of the area contained in each cell of the 3d grid defined by Z and latitude and longitude.\nHere are the variable’s attributes:\n\necco_grid.maskC.attrs\n\n{'coverage_content_type': 'modelResult',\n 'long_name': 'wet/dry boolean mask for grid cell',\n 'comment': 'True for grid cells with nonzero open vertical fraction (hFacC > 0), otherwise False.'}\n\n\nSo, the mask derives from another variable hFacC that essentially describes 3d space/volume contained within each model grid cell by the fractional area representing the horizontal coverage (in the longitude,latitude dimensions) within each vertical/depth layer.\n\necco_grid.hFacC.attrs\n\n{'coverage_content_type': 'modelResult',\n 'long_name': 'vertical open fraction of grid cell',\n 'units': '1',\n 'comment': 'Grid cells may be fractionally closed in the vertical. The open vertical fraction is hFacC. The model allows for partially-filled cells to represent topographic variations more smoothly (hFacC < 1). Completely closed (dry) tracer grid cells have hFacC = 0. Note: the lat-lon gridded hFacC is spatially-averaged from the hFacC field on the lat-lon-cap (llc90) model native grid. The total ocean volume of the ECCO V4r4 lat-lon gridded fields is within 0.05% of the total ocean volume of the native grid fields.'}\n\n\nSelect the 2d array from maskC that corresponds to the depth layer at ocean surface (i.e. at index 0 on the Z axis/dimension) and then produce a boolean array where True represents cells with a value greater than 0. The resulting array/grid is our land/water mask for the 2d grids generated during the next few steps.\nPlot the land/water mask:\n\necco_mask = ecco_grid.maskC.isel(Z=0)>0\n\necco_mask.plot(figsize=(13, 6))\n\n<matplotlib.collections.QuadMesh at 0x7f3157ef2970>\n\n\n\n\n\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.isel.html\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.html\n\n\n\n\nGrid ssha or a similar variable\nJinbo’s recommendation: wrap this logic for parameterization by workshop attendees.\nGet a single timestamp to represent the midpoint of the cycle.\n\ntime = np.datetime64(dataset['time'].mean().data)\n\nprint(time)\n\n2021-07-18T15:11:35.073955170\n\n\nAccess the target variable, ssha in this case, and make a nan mask.\n\nssha = dataset.ssha\n\nnans = ~np.isnan(ssha.values)\n\nprint(ssha)\n\n<xarray.DataArray 'ssha' (time: 827001)>\ndask.array<concatenate, shape=(827001,), dtype=float64, chunksize=(6981,), chunktype=numpy.ndarray>\nCoordinates:\n  * time     (time) datetime64[ns] 2021-07-13T16:26:45 ... 2021-07-23T14:25:14\nAttributes:\n    long_name:      sea surface height anomaly\n    standard_name:  sea_surface_height_above_sea_level\n    units:          m\n    comment:        Sea surface height anomaly = altitude of satellite (altit...\n    coordinates:    /data_01/longitude /data_01/latitude\n    origname:       ssha\n    fullnamepath:   /data_01/ku/ssha\n\n\nDefine a simple function get_grid_defn to validate input arrays of longitudes/latitudes and return a pyresample.geometry.SwathDefinition object. (We use it twice to define source/target grids in the next steps.)\ndef get_grid_defn(lons: np.ndarray, lats: np.ndarray):\n    \n    if lats.min() <  -90. or lats.max() > 90.:  #1\n        raise ValueError('Found invalid latitudes, aborting - see if condition 1\\n')\n    \n    if lons.min() < -180. or lons.max() >= 180.:  #2\n        print('Found invalid longitudes, wrapping - see if condition 2\\n')\n        lons = (lons + 180) % 360 - 180\n    \n    return pr.SwathDefinition(lons, lats)\nDefine source grid/geometry for the input along-track data. (They are stored as 1-dimensional arrays.)\n\nlons = dataset.longitude.values\nlats = dataset.latitude.values\n\nalt_grid_defn = get_grid_defn(lons[nans], lats[nans])\n\ntype(alt_grid_defn)\n\nFound invalid longitudes, wrapping - see if condition 2\n\n\n\npyresample.geometry.SwathDefinition\n\n\nDefine target grid based on the longitudes and latitudes from the ECCO grid geometry dataset. This time define the grid using two 2-dimensional arrays that give positions of all SSHA values in geographic/longitude-latitude coordinates.\n\necco_lons = ecco_grid.longitude.values\necco_lats = ecco_grid.latitude.values\n\necco_lons_2d, ecco_lats_2d = np.meshgrid(ecco_lons, ecco_lats)\n\nprint(ecco_lons_2d.shape, ecco_lats_2d.shape)\n\n(360, 720) (360, 720)\n\n\nMake the pyresample object for the target grid and proceed.\necco_grid_defn = get_grid_defn(ecco_lons_2d, ecco_lats_2d)\nShow the help for pyresample.kdtree.resample_gauss to aid during the hackathon.\n#help(resample_gauss)\nGet the target grid definition defined by the 2d arrays of lons and lats created in the cell above. Apply gaussian resampling with some optional arguments (borrowed from Ian’s implementation).\n\nresult, stddev, counts = resample_gauss(\n    alt_grid_defn,      # source grid\n    ssha.values[nans],  # source data\n    ecco_grid_defn,     # target grid\n    radius_of_influence = 1.75e5,  \n    sigmas              = 25000,\n    fill_value          = np.nan, \n    neighbours          = 100, \n    with_uncert         = True,\n)\n\ntype(result), type(stddev), type(counts)\n\n(numpy.ndarray, numpy.ma.core.MaskedArray, numpy.ndarray)\n\n\nApply the land/water mask in the numpy array created from the ECCO layer in the steps above. Then, convert the masked numpy array to an xarray data array object named gridded. Print its header.\n\nmasked = np.where(ecco_mask, result, np.nan)\n\ngridded = xr.DataArray(masked, \n                       name=\"ssha\",\n                       dims=['latitude', 'longitude'], \n                       coords={'time': time, 'longitude': ecco_lons, 'latitude': ecco_lats})\n\nprint(gridded)\n\n<xarray.DataArray 'ssha' (latitude: 360, longitude: 720)>\narray([[nan, nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       ...,\n       [nan, nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan],\n       [nan, nan, nan, ..., nan, nan, nan]])\nCoordinates:\n    time       datetime64[ns] 2021-07-18T15:11:35.073955170\n  * longitude  (longitude) float32 -179.8 -179.2 -178.8 ... 178.8 179.2 179.8\n  * latitude   (latitude) float32 -89.75 -89.25 -88.75 ... 88.75 89.25 89.75\n\n\n\ngridded.sel(latitude=slice(-70.0, 70.0)).plot.pcolormesh(vmin=-0.4, vmax=0.4, cmap=\"jet\", figsize=(18,7))\n\n<matplotlib.collections.QuadMesh at 0x7f3157b58040>\n\n\n\n\n\n\nstddev = xr.DataArray(np.where(ecco_mask, stddev, np.nan), \n                      name=\"stddev\",\n                      dims=['latitude', 'longitude'], \n                      coords={'time': time, 'longitude': ecco_lons, 'latitude': ecco_lats})\n\nstddev.sel(latitude=slice(-70.0, 70.0)).plot.pcolormesh(vmax=0.4, cmap=\"jet\", figsize=(18, 7))\n\n<matplotlib.collections.QuadMesh at 0x7f3157d7c640>\n\n\n\n\n\n\ncounts = xr.DataArray(np.where(ecco_mask, counts, np.nan), \n                      name=\"counts\",\n                      dims=['latitude', 'longitude'], \n                      coords={'time': time, 'longitude': ecco_lons, 'latitude': ecco_lats})\n\ncounts.sel(latitude=slice(-70.0, 70.0)).plot.pcolormesh(cmap=\"jet\", figsize=(18, 7))\n\n<matplotlib.collections.QuadMesh at 0x7f31579966a0>\n\n\n\n\n\nAdditional References:\n\nnumpy (https://numpy.org/doc/stable/reference)\n\nnumpy.ndarray.data\n\nnumpy.ravel\n\nnumpy.where\n\nnumpy.isnan\n\ndatetimes\n\n\nxarray (https://xarray.pydata.org/en/stable)\n\nxarray.DataArray\n\nxarray.DataArray.values\n\nxarray.DataArray.mean\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.pcolormesh.html (matplotlib)\n\n\npyresample (https://pyresample.readthedocs.io/en/latest/api/pyresample)\n\npyresample.utils.check_and_wrap\n\npyresample.kd_tree.resample_gauss\n\npyresample.geometry.SwathDefinition\n\n\nBonus: generate a grid for every cycle and get mean/std over all the cycles\nstack = xr.concat(data['grid'].tolist(), dim=\"time\")\n\nmidlat = stack.sel(latitude=slice(-66.,66.0))\n\nstats = xr.concat(objs=[midlat.mean(\"time\"),\n                        midlat.std(\"time\") ], \n                  dim=pd.Index(['mean','std'], name=\"stat\"))\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.concat.html\n\nBonus: calculate area-weighted mean\ndef to_area_weighted_mean(x):\n    nonzero_mask = np.where(~np.isnan(x), 1, np.nan)            # mask where nans=0 & ~nans=1\n    nonzero_area = np.sum(nonzero_mask * ecco_grid.area)        # total area where data is nonzero\n    return float(np.nansum(x * ecco_grid.area) / nonzero_area)  # area-weighted global mean\n\nhttps://numpy.org/doc/stable/reference/generated/numpy.sum.html\nhttps://numpy.org/doc/stable/reference/generated/numpy.nansum.html"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#timing",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#timing",
    "title": "",
    "section": "Timing",
    "text": "Exercise: 30 min"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#summary",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In this example we will access the NASA’s Harmonized Landsat Sentinel-2 (HLS) version 2 assets, which are archived in cloud optimized geoTIFF (COG) format in the LP DAAC Cumulus cloud space. The COGs can be used like any other geoTIFF file, but have some added features that make them more efficient within the cloud data access paradigm. These features include: overviews and internal tiling. Below we will demonstrate how to leverage these features.\n\nBut first, what is STAC?\nSpatioTemporal Asset Catalog (STAC) is a specification that provides a common language for interpreting geospatial information in order to standardize indexing and discovering data.\nThe STAC specification is made up of a collection of related, yet independent specifications that when used together provide search and discovery capabilities for remove assets.\n\nFour STAC Specifications\nSTAC Item (aka Granule)\nSTAC Catalog (aka DAAC Archive)\nSTAC Collection (aka Data Product)\nSTAC API\nIn the following sections, we will explore each of STAC element using NASA’s Common Metadata Repository (CMR) STAC application programming interface (API), or CMR-STAC API for short.\n\n\n\nCMR-STAC API\nThe CMR-STAC API is NASA’s implementation of the STAC API specification for all NASA data holdings within EOSDIS. The current implementation does not allow for querries accross the entire NASA catalog. Users must execute searches within provider catalogs (e.g., LPCLOUD) to find the STAC Items they are searching for. All the providers can be found at the CMR-STAC endpoint here: https://cmr.earthdata.nasa.gov/stac/.\nIn this exercise, we will query the LPCLOUD provider to identify STAC Items from the Harmonized Landsat Sentinel-2 (HLS) collection that fall within our region of interest (ROI) and within our specified time range."
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "how to connect to NASA CMR-STAC API using Python’s pystac-client\n\nhow to navigate CMR-STAC records\n\nhow to read in a geojson file using geopandas to specify your region of interest\nhow to use the CMR-STAC API to search for data\nhow to perform post-search filtering of CMR-STAC API search result in Python\n\nhow to extract and save data access URLs for geospatial assets\n\nThis exercise can be found in the 2021 Cloud Hackathon Book"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#import-required-packages",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "from pystac_client import Client       # https://pystac-client.readthedocs.io/en/latest/index.html  \nfrom collections import defaultdict    \nimport json\nimport geopandas\nimport geoviews as gv\nfrom cartopy import crs\ngv.extension('bokeh', 'matplotlib')"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#explored-available-nasa-providers",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#explored-available-nasa-providers",
    "title": "",
    "section": "Explored available NASA Providers",
    "text": "STAC_URL = 'https://cmr.earthdata.nasa.gov/stac'\n\nConnect to the CMR-STAC API\nprovider_cat = Client.open(STAC_URL)\nWe’ll create a providers variable so we can take a deeper look into available data providers - subcategories are referred to as “children”. We can then print them as a for loop.\n\nproviders = [p for p in provider_cat.get_children()]\n\nfor count, provider in enumerate(providers):\n    print(f'{count} - {provider.title}')\n\n0 - LARC_ASDC\n1 - USGS_EROS\n2 - ESA\n3 - GHRC\n4 - LAADS\n5 - OBPG\n6 - OB_DAAC\n7 - ECHO\n8 - ISRO\n9 - LPCUMULUS\n10 - EDF_DEV04\n11 - GES_DISC\n12 - ASF\n13 - OMINRT\n14 - EUMETSAT\n15 - NCCS\n16 - NSIDCV0\n17 - PODAAC\n18 - LARC\n19 - USGS\n20 - SCIOPS\n21 - LANCEMODIS\n22 - CDDIS\n23 - JAXA\n24 - AU_AADC\n25 - ECHO10_OPS\n26 - LPDAAC_ECS\n27 - NSIDC_ECS\n28 - ORNL_DAAC\n29 - LM_FIRMS\n30 - SEDAC\n31 - LANCEAMSR2\n32 - NOAA_NCEI\n33 - USGS_LTA\n34 - GESDISCCLD\n35 - GHRSSTCWIC\n36 - ASIPS\n37 - ESDIS\n38 - POCLOUD\n39 - NSIDC_CPRD\n40 - ORNL_CLOUD\n41 - FEDEO\n42 - XYZ_PROV\n43 - GHRC_DAAC\n44 - CSDA\n45 - NRSCC\n46 - CEOS_EXTRA\n47 - MOPITT\n48 - GHRC_CLOUD\n49 - LPCLOUD\n50 - CCMEO"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#connect-to-the-lpcloud-providerstac-catalog",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#connect-to-the-lpcloud-providerstac-catalog",
    "title": "",
    "section": "Connect to the LPCLOUD Provider/STAC Catalog",
    "text": "For this next step we need the provider title (e.g., LPCLOUD) from above. We will add the provider to the end of the CMR-STAC API URL (i.e., https://cmr.earthdata.nasa.gov/stac/) to connect to the LPCLOUD STAC Catalog.\ncatalog = Client.open(f'{STAC_URL}/LPCLOUD/')\nSince we are using a dedicated client (i.e., pystac-client.Client) to connect to our STAC Provider Catalog, we will have access to some useful internal methods and functions we can use to get information from these objects."
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#list-stac-collections",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#list-stac-collections",
    "title": "",
    "section": "List STAC Collections",
    "text": "We’ll create a products variable to view deeper in the STAC Catalog.\nproducts = [c for c in catalog.get_children()]\n\nPrint one of the STAC Collection records\nTo view the products variable we just created, let’s look at one entry as a dictionary.\n\nproducts[1].to_dict()\n\n{'type': 'Collection',\n 'id': 'HLSL30.v2.0',\n 'stac_version': '1.0.0',\n 'description': 'The Harmonized Landsat and Sentinel-2 (HLS) project provides consistent surface reflectance (SR) and top of atmosphere (TOA) brightness data from the Operational Land Imager (OLI) aboard the joint NASA/USGS Landsat 8 satellite and the Multi-Spectral Instrument (MSI) aboard Europe’s Copernicus Sentinel-2A and Sentinel-2B satellites. The combined measurement enables global observations of the land every 2–3 days at 30-meter (m) spatial resolution. The HLS project uses a set of algorithms to obtain seamless products from OLI and MSI that include atmospheric correction, cloud and cloud-shadow masking, spatial co-registration and common gridding, illumination and view angle normalization, and spectral bandpass adjustment.\\r\\n\\r\\nThe HLSL30 product provides 30-m Nadir Bidirectional Reflectance Distribution Function (BRDF)-Adjusted Reflectance (NBAR) and is derived from Landsat 8 OLI data products. The HLSS30 and HLSL30 products are gridded to the same resolution and Military Grid Reference System ([MGRS](https://hls.gsfc.nasa.gov/products-description/tiling-system/)) tiling system, and thus are “stackable” for time series analysis.\\r\\n\\r\\nThe HLSL30 product is provided in Cloud Optimized GeoTIFF (COG) format, and each band is distributed as a separate file. There are 11 bands included in the HLSL30 product along with one quality assessment (QA) band and four angle bands. See the User Guide for a more detailed description of the individual bands provided in the HLSL30 product.',\n 'links': [{'rel': <RelType.ROOT: 'root'>,\n   'href': 'https://cmr.earthdata.nasa.gov/stac/',\n   'type': <MediaType.JSON: 'application/json'>},\n  {'rel': 'items',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v2.0/items',\n   'type': 'application/json',\n   'title': 'Granules in this collection'},\n  {'rel': 'about',\n   'href': 'https://cmr.earthdata.nasa.gov/search/concepts/C2021957657-LPCLOUD.html',\n   'type': 'text/html',\n   'title': 'HTML metadata for collection'},\n  {'rel': 'via',\n   'href': 'https://cmr.earthdata.nasa.gov/search/concepts/C2021957657-LPCLOUD.json',\n   'type': 'application/json',\n   'title': 'CMR JSON metadata for collection'},\n  {'rel': 'child',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v2.0/2020',\n   'type': 'application/json',\n   'title': '2020 catalog'},\n  {'rel': 'child',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v2.0/2021',\n   'type': 'application/json',\n   'title': '2021 catalog'},\n  {'rel': <RelType.SELF: 'self'>,\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v2.0',\n   'type': <MediaType.JSON: 'application/json'>},\n  {'rel': <RelType.PARENT: 'parent'>,\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/',\n   'type': <MediaType.JSON: 'application/json'>}],\n 'stac_extensions': [],\n 'title': 'HLS Landsat Operational Land Imager Surface Reflectance and TOA Brightness Daily Global 30m v2.0',\n 'extent': {'spatial': {'bbox': [[-180, -90, 180, 90]]},\n  'temporal': {'interval': [['2013-05-01T00:00:00Z', None]]}},\n 'license': 'not-provided'}\n\n\n\n\nPrint the STAC Collection ids with their title\nIn the above output, id and title are two elements of interest that we can print for all products using a for loop.\n\nfor p in products: \n    print(f\"{p.id}: {p.title}\")\n\nASTGTM.v003: ASTER Global Digital Elevation Model V003\nHLSL30.v2.0: HLS Landsat Operational Land Imager Surface Reflectance and TOA Brightness Daily Global 30m v2.0\nHLSL30.v1.5: HLS Operational Land Imager Surface Reflectance and TOA Brightness Daily Global 30 m V1.5\nHLSS30.v1.5: HLS Sentinel-2 Multi-spectral Instrument Surface Reflectance Daily Global 30 m V1.5\nHLSS30.v2.0: HLS Sentinel-2 Multi-spectral Instrument Surface Reflectance Daily Global 30m v2.0"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#search-for-granulesstac-items---set-up-query-parameters-to-submit-to-the-cmr-stac-api",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#search-for-granulesstac-items---set-up-query-parameters-to-submit-to-the-cmr-stac-api",
    "title": "",
    "section": "Search for Granules/STAC Items - Set up query parameters to submit to the CMR-STAC API",
    "text": "We will define our ROI using the geojson file from the previous exercise, while also specifying the data collections and time range of needed for our example.\n\nRead in a geojson file\nReading in a geojson file with geopandas will return the geometry of our polygon (our ROI).\n\nfield = geopandas.read_file('./data/ne_w_agfields.geojson')\nfield\n\n\n\n\n  \n    \n      \n      geometry\n    \n  \n  \n    \n      0\n      POLYGON ((-101.67272 41.04754, -101.65345 41.0...\n    \n  \n\n\n\n\n\n\nVisualize contents of geojson file\nWe can use that geometry to visualize the polygon: here, a square. But wait for it –\n\nfieldShape = field['geometry'][0]\nfieldShape\n\n\n\n\nWe can plot the polygon using the geoviews package that we imported as gv with ‘bokeh’ and ‘matplotlib’ extensions. The following has reasonable width, height, color, and line widths to view our polygon when it is overlayed on a base tile map.\n\nbase = gv.tile_sources.EsriImagery.opts(width=650, height=500)\nfarmField = gv.Polygons(fieldShape).opts(line_color='yellow', line_width=10, color=None)\nbase * farmField\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\nWe will now start to specify the search criteria we are interested in, i.e, the date range, the ROI, and the data collections, that we will pass to the STAC API.\n\n\nExtract the coordinates for the ROI\n\nroi = json.loads(field.to_json())['features'][0]['geometry']\nroi\n\n{'type': 'Polygon',\n 'coordinates': [[[-101.67271614074707, 41.04754380304359],\n   [-101.65344715118408, 41.04754380304359],\n   [-101.65344715118408, 41.06213891056728],\n   [-101.67271614074707, 41.06213891056728],\n   [-101.67271614074707, 41.04754380304359]]]}\n\n\nSo, what just happen there? Let’s take a quick detour to break it down.\n\n\n\nSpecify date range\nNext up is to specify our date range using ISO_8601 date formatting.\n#date_range = \"2021-05-01T00:00:00Z/2021-08-30T23:59:59Z\"    # closed interval\n#date_range = \"2021-05-01T00:00:00Z/..\"                      # open interval - does not currently work with the CMR-STAC API\ndate_range = \"2021-05/2021-08\"\n\n\nSpecify the STAC Collections\nSTAC Collection is synonomous with what we usually consider a NASA data product. Desired STAC Collections are submitted to the search API as a list containing the collection id. We can use the ids that we printed from our products for loop above. Let’s focus on S30 and L30 collections.\n\ncollections = ['HLSL30.v1.5', 'HLSS30.v1.5']\ncollections\n\n['HLSL30.v1.5', 'HLSS30.v1.5']"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#search-the-cmr-stac-api-with-our-search-criteria",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#search-the-cmr-stac-api-with-our-search-criteria",
    "title": "",
    "section": "Search the CMR-STAC API with our search criteria",
    "text": "Now we can put all our search criteria together using catalog.search from the pystac_client package.\nsearch = catalog.search(\n    collections=collections,\n    intersects=roi,\n    datetime=date_range,\n    limit=100\n)\n\nPrint out how many STAC Items match our search query\n\nsearch.matched()\n\n77\n\n\nWe now have a search object containing the STAC Items that matched our query. Now, let’s pull out all of the STAC Items (as a PySTAC ItemCollection object) and explore the contents (i.e., the STAC Items)\nitem_collection = search.get_all_items()\nLet’s list some of the Items from our pystac item_collection:\n\nlist(item_collection)[0:5]\n\n[<Item id=HLS.L30.T14TKL.2021124T173013.v1.5>,\n <Item id=HLS.L30.T13TGF.2021124T173013.v1.5>,\n <Item id=HLS.S30.T14TKL.2021125T172901.v1.5>,\n <Item id=HLS.S30.T13TGF.2021125T172901.v1.5>,\n <Item id=HLS.S30.T14TKL.2021128T173901.v1.5>]\n\n\nWe can view a single Item as a dictionary, as we did above with STAC Collections/products.\n\nitem_collection[0].to_dict()\n\n{'type': 'Feature',\n 'stac_version': '1.0.0',\n 'id': 'HLS.L30.T14TKL.2021124T173013.v1.5',\n 'properties': {'datetime': '2021-05-04T17:30:13.428000Z',\n  'start_datetime': '2021-05-04T17:30:13.428Z',\n  'end_datetime': '2021-05-04T17:30:37.319Z',\n  'eo:cloud_cover': 35},\n 'geometry': {'type': 'Polygon',\n  'coordinates': [[[-102.5408226, 40.5084628],\n    [-101.5339397, 40.5349543],\n    [-101.2721766, 41.3037739],\n    [-101.2800519, 41.5292355],\n    [-102.5941245, 41.4956464],\n    [-102.5408226, 40.5084628]]]},\n 'links': [{'rel': 'self',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v1.5/items/HLS.L30.T14TKL.2021124T173013.v1.5'},\n  {'rel': 'parent',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v1.5'},\n  {'rel': 'collection',\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/collections/HLSL30.v1.5'},\n  {'rel': <RelType.ROOT: 'root'>,\n   'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD/',\n   'type': <MediaType.JSON: 'application/json'>},\n  {'rel': 'provider', 'href': 'https://cmr.earthdata.nasa.gov/stac/LPCLOUD'},\n  {'rel': 'via',\n   'href': 'https://cmr.earthdata.nasa.gov/search/concepts/G2047834723-LPCLOUD.json'},\n  {'rel': 'via',\n   'href': 'https://cmr.earthdata.nasa.gov/search/concepts/G2047834723-LPCLOUD.umm_json'}],\n 'assets': {'Fmask': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.Fmask.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.Fmask.tif'},\n  'B10': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B10.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B10.tif'},\n  'B03': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B03.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B03.tif'},\n  'B01': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B01.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B01.tif'},\n  'B09': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B09.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B09.tif'},\n  'SZA': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.SZA.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.SZA.tif'},\n  'B07': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B07.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B07.tif'},\n  'B04': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B04.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B04.tif'},\n  'VZA': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.VZA.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.VZA.tif'},\n  'B02': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B02.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B02.tif'},\n  'VAA': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.VAA.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.VAA.tif'},\n  'SAA': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.SAA.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.SAA.tif'},\n  'B06': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B06.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B06.tif'},\n  'B11': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B11.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B11.tif'},\n  'B05': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.B05.tif',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.B05.tif'},\n  'browse': {'href': 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-public/HLSL30.015/HLS.L30.T14TKL.2021124T173013.v1.5.jpg',\n   'type': 'image/jpeg',\n   'title': 'Download HLS.L30.T14TKL.2021124T173013.v1.5.jpg'},\n  'metadata': {'href': 'https://cmr.earthdata.nasa.gov/search/concepts/G2047834723-LPCLOUD.xml',\n   'type': 'application/xml'}},\n 'bbox': [-102.594124, 40.508463, -101.272177, 41.529236],\n 'stac_extensions': ['https://stac-extensions.github.io/eo/v1.0.0/schema.json'],\n 'collection': 'HLSL30.v1.5'}"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#filtering-stac-items",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#filtering-stac-items",
    "title": "",
    "section": "Filtering STAC Items",
    "text": "While the CMR-STAC API is a powerful search and discovery utility, it is still maturing and currently does not have the full gamut of filtering capabilities that the STAC API specification allows for. Hence, additional filtering is required if we want to filter by a property, for example cloud cover. Below we will loop through and filter the item_collection by a specified cloud cover as well as extract the band we’d need to do an Enhanced Vegetation Index (EVI) calculation for a future analysis.\nWe’ll make a cloudcover variable where we will set the maximum allowable cloud cover and extract the band links for those Items that match or are less than the max cloud cover.\ncloudcover = 25\nWe will also specify the STAC Assets (i.e., bands/layers) of interest for both the S30 and L30 collections (also in our collections variable above).\nIn this hypothetical workflow, we’ll extract the bands needed to calculate an enhanced vegetation index (EVI). Thus, the band needed include red, near infrared (NIR), and blue. We’ll also extract a quality band (i.e., Fmask) that we’d eventually use to perform per-pixel quality filtering.\nNotice that the band ids are in some case not one-to-one between the S30 and the L30 product. This is evident in the NIR band for each product where S30’s NIR band id is B8A and L30’s is B05. Note, the S30 product has an additional NIR band with a band id of B08, but the spectral ranges between B8A and B05 are more closely aligned. Visit the HLS Overview page to learn more about HLS spectral bands.\ns30_bands = ['B8A', 'B04', 'B02', 'Fmask']    # S30 bands for EVI calculation and quality filtering -> NIR, RED, BLUE, Quality \nl30_bands = ['B05', 'B04', 'B02', 'Fmask']    # L30 bands for EVI calculation and quality filtering -> NIR, RED, BLUE, Quality \nAnd now to loop through and filter the item_collection by cloud cover and bands:\nevi_band_links = []\n\nfor i in item_collection:\n    if i.properties['eo:cloud_cover'] <= cloudcover:\n        if i.collection_id == 'HLSS30.v1.5':\n            #print(i.properties['eo:cloud_cover'])\n            evi_bands = s30_bands\n        elif i.collection_id == 'HLSL30.v1.5':\n            #print(i.properties['eo:cloud_cover'])\n            evi_bands = l30_bands\n\n        for a in i.assets:\n            if any(b==a for b in evi_bands):\n                evi_band_links.append(i.assets[a].href)\nThe filtering done in the previous steps produces a list of links to STAC Assets. Let’s print out the first ten links.\n\nevi_band_links[:10]\n\n['https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021133T172406.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021133T172406.v1.5.B02.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021133T172406.v1.5.Fmask.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T14TKL.2021133T172406.v1.5.B05.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.Fmask.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B02.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B05.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T14TKL.2021133T173859.v1.5.Fmask.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T14TKL.2021133T173859.v1.5.B04.tif']\n\n\nNOTE that HLS data is mapped to the Universal Transverse Mercator (UTM) projection and is tiled using the Sentinel-2 Military Grid Reference System (MGRS) UTM grid. Notice that in the list of links we have multiple tiles, i.e. T14TKL & T13TGF, that intersect with our region of interest. In this case, these two tiles represent neighboring UTM zones. The tiles can be discern from the file name, which is the last element in a link (far right) following the last forward slash (/) - e.g., HLS.L30.T14TKL.2021133T172406.v1.5.B04.tif. The figure below explains where to find the tile/UTM zone from the file name.\n\nWe will now split the list of links into separate logical sub-lists."
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#split-data-links-list-into-logical-groupings",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#split-data-links-list-into-logical-groupings",
    "title": "",
    "section": "Split Data Links List into Logical Groupings",
    "text": "We have a list of links to data assets that meet our search and filtering criteria. Below we’ll split our list from above into lists first by tile/UTM zone and then further by individual bands bands. The commands that follow will do the splitting with python routines.\n\nSplit by UTM tile specified in the file name (e.g., T14TKL & T13TGF)\ntile_dicts = defaultdict(list)    # https://stackoverflow.com/questions/26367812/appending-to-list-in-python-dictionary\nfor l in evi_band_links:\n    tile = l.split('.')[-6]\n    tile_dicts[tile].append(l)\n\nPrint dictionary keys and values, i.e. the data links\n\ntile_dicts.keys()\n\ndict_keys(['T14TKL', 'T13TGF'])\n\n\n\ntile_dicts['T13TGF'][:5]\n\n['https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.Fmask.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B02.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B05.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B02.tif']\n\n\nNow we will create a separate list of data links for each tile\ntile_links_T14TKL = tile_dicts['T14TKL']\ntile_links_T13TGF = tile_dicts['T13TGF']\n\n\nPrint band/layer links for HLS tile T13TGF\n# tile_links_T13TGF[:10]\n\n\n\nSplit the links by band\nbands_dicts = defaultdict(list)\nfor b in tile_links_T13TGF:\n    band = b.split('.')[-2]\n    bands_dicts[band].append(b)\n\nbands_dicts.keys()\n\ndict_keys(['Fmask', 'B02', 'B05', 'B04', 'B8A'])\n\n\n\nbands_dicts['B04']\n\n['https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#save-links-to-a-text-file",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#save-links-to-a-text-file",
    "title": "",
    "section": "Save links to a text file",
    "text": "To complete this exercise, we will save the individual link lists as separate text files with descriptive names.\n\nWrite links from CMR-STAC API to a file\nfor k, v in bands_dicts.items():\n    name = (f'HTTPS_T13TGF_{k}_Links.txt')\n    with open(f'./data/{name}', 'w') as f:\n        for l in v:\n            f.write(f\"{l}\" + '\\n')\n\n\nWrite links to file for S3 access\nfor k, v in bands_dicts.items():\n    name = (f'S3_T13TGF_{k}_Links.txt')\n    with open(f'./data/{name}', 'w') as f:\n        for l in v:\n            s3l = l.replace('https://data.lpdaac.earthdatacloud.nasa.gov/', 's3://')\n            f.write(f\"{s3l}\" + '\\n')"
  },
  {
    "objectID": "tutorials/02_Data_Discovery_CMR-STAC_API.html#resources",
    "href": "tutorials/02_Data_Discovery_CMR-STAC_API.html#resources",
    "title": "",
    "section": "Resources",
    "text": "STAC Specification Webpage\nSTAC API Documentation\nCMR-STAC API Github\nhttps://stackoverflow.com/questions/26367812/appending-to-list-in-python-dictionary\nGeopandas\nHLS Overview"
  },
  {
    "objectID": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#summary",
    "href": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This tutorial will combine several workflow steps and components from the previous days, demonstrating the process of using the geolocation of data available outside of the Earthdata Cloud to then access coincident variables of cloud-accessible data. This may be a common use case as NASA Earthdata continues to migrate to the cloud, producing a “hybrid” data archive across Amazon Web Services (AWS) and original on-premise data storage systems. Additionally, you may also want to combine field measurements with remote sensing data available on the Earthdata Cloud.\nThis specific example explores the harmonization of the ICESat-2 ATL03 data product, currently (as of November 2021) available publicly via direct download at the NSIDC DAAC, with Sea Surface Temperature variables available from PO.DAAC on the Earthdata Cloud.\n\nObjectives\n\n\n\nImport packages\nimport os\nfrom pathlib import Path\nfrom pprint import pprint\n\nimport warnings  # Temporary!!!\n\n# Access EDS\nimport netrc\nimport requests\n\n# Access AWS S3\nimport s3fs\n\n# Read and work with datasets\nimport xarray as xr\n\n# For plotting\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom shapely.geometry import box\n\n\nDetermine storage location of datasets of interest\nFirst, let’s see whether our datasets of interest reside in the Earthdata Cloud or whether they reside on premise, or “on prem” at a local data center.\nWe are building off of the CMR introductory tutorial, beginning with a collection search.\ncmr_search_url = 'https://cmr.earthdata.nasa.gov/search'\nWe want to search by collection to inspect the access and service options that exist:\ncmr_collection_url = f'{cmr_search_url}/{\"collections\"}'\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given dataset id (also referred to as a short_name). Here we’ll start with two datasets that we want to explore over a coincident area and time:\nmodis_name = 'MODIS_A-JPL-L2P-v2019.0'\nicesat2_name = 'ATL03'\nLike in the intro tutorial, we’re going to first determine what concept-ids are returned for the MODIS dataset. First, retrieve collection results based on the MODIS short_name:\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': modis_name,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\nFor each collection result, print out the CMR concept-id and version:\n\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\n\nC1940473819-POCLOUD version:2019.0\nC1693233348-PODAAC version:2019.0\n\n\nTwo collections are returned, both at version 2019.0. We can see from the suffix of the id that one is associated with “POCLOUD” versus “PODAAC”. That gives us a clue in terms of where the data are hosted, but we can also use the cloud_hosted parameter set to True to confirm.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': modis_name,\n                            'cloud_hosted': 'True',\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\n\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\n\nC1940473819-POCLOUD version:2019.0\n\n\nWe will save this concept-id to use later on when we access the data granules.\nmodis_concept_id = collections[0][\"id\"]\nNow we will try our ICESat-2 dataset to see what id’s are returned for a given dataset name.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': icesat2_name,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\n\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\n\nC1705401930-NSIDC_ECS version:003\nC1997321091-NSIDC_ECS version:004\n\n\nTwo separate datasets exist in the CMR, one at version 3 and one at version 4. Let’s see if these are cloud_hosted:\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'short_name': icesat2_name,\n                            'cloud_hosted': 'False',\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\n\ncollections = response['feed']['entry']\n\nfor collection in collections:\n    print(f'{collection[\"id\"]} {\"version:\"}{collection[\"version_id\"]}')\n\nC1997321091-NSIDC_ECS version:004\nC1705401930-NSIDC_ECS version:003\n\n\nWhen set to False, we get our collections back. We have now determined that we have a copy of the MODIS dataset in the cloud, whereas the ICESat-2 dataset (both versions) remains “on premise”, residing in a local data center.\nSave the ATL03 concept ID:\nicesat2_concept_id = collections[0][\"id\"]\n\nSpecify time range and area of interest\nWe are going to focus on getting data for an area north of Greenland for a single day in June.\nThese bounding_box and temporal variables will be used for data search, subset, and access below\n# Bounding Box spatial parameter in decimal degree 'W,S,E,N' format.\nbounding_box = '-62.8,81.7,-56.4,83'\n\n# Each date in yyyy-MM-ddTHH:mm:ssZ format; date range in start,end format\ntemporal = '2019-06-22T00:00:00Z,2019-06-22T23:59:59Z'\nPerform a granule search over our time and area of interest. How many granules are returned?\ngranule_url = f'{cmr_search_url}/{\"granules\"}'\n\nresponse = requests.get(granule_url, \n                        params={\n                            'concept_id': icesat2_concept_id,\n                            'temporal': temporal,\n                            'bounding_box': bounding_box,\n                            'page_size': 200,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nprint(response.headers['CMR-Hits'])\n\n2\n\n\nPrint the file names, size, and links:\n\ngranules = response.json()['feed']['entry']\nfor granule in granules:\n    print(f'{granule[\"producer_granule_id\"]} {granule[\"granule_size\"]} {granule[\"links\"][0][\"href\"]}')\n\nATL03_20190622061415_12980304_004_01.h5 1825.3746356964 https://n5eil01u.ecs.nsidc.org/DP9/ATLAS/ATL03.004/2019.06.22/ATL03_20190622061415_12980304_004_01.h5\nATL03_20190622202251_13070304_004_01.h5 3035.5987443924 https://n5eil01u.ecs.nsidc.org/DP9/ATLAS/ATL03.004/2019.06.22/ATL03_20190622202251_13070304_004_01.h5\n\n\n\n\n\nDownload ICESat-2 ATL03 granule\n[TODO] Describe what services are available, including icepyx (provide references), but just direct download for simplicity. Describe that this is being “downloaded” to our cloud environment - what does that mean in terms of cost, etc.\nWe’ve found 2 granules. We’ll download the first one and write it to a file with the same name as the producer_granule_id.\nWe need the url for the granule as well. This is href links we printed out above.\nicesat_id = granules[0][\"producer_granule_id\"]\nicesat_url = granules[0]['links'][0]['href']\nTo retrieve the granule data, we use the requests.get() method, which will utilize the .netrc file on the backend to authenticate the request against Earthdata Login.\n\n%time\nr = requests.get(icesat_url)\n\nCPU times: user 2 µs, sys: 0 ns, total: 2 µs\nWall time: 6.44 µs\n\n\nThe response returned by requests has the same structure as all the other responses: a header and contents. The header information has information about the response, including the size of the data we downloaded in bytes.\n\nfor k, v in r.headers.items():\n    print(f'{k}: {v}')\n\nDate: Fri, 12 Nov 2021 23:56:56 GMT\nServer: Apache\nVary: User-Agent\nContent-Disposition: attachment\nContent-Length: 1914044034\nKeep-Alive: timeout=15, max=100\nConnection: Keep-Alive\n\n\nThe contents needs to be saved to a file. To keep the directory clean, we will create a downloads directory to store the file. We can use a shell command to do this or use the mkdir method from the os package.\nos.makedirs(\"downloads\", exist_ok=True)\nYou should see a downloads directory in the file browser.\nTo write the data to a file, we use open to open a file. We need to specify that the file is open for writing by using the write-mode w. We also need to specify that we want to write bytes by setting the binary-mode b. This is important because the response contents are bytes. The default mode for open is text-mode. So make sure you use b.\nWe’ll use the with statement context-manager to open the file, write the contents of the response, and then close the file. Once the data in r.content is written sucessfully to the file, or if there is an error, the file is closed by the context-manager.\nWe also need to prepend the downloads path to the filename. We do this using Path from the pathlib package in the standard library.\noutfile = Path('downloads', icesat_id)\nif not outfile.exists():\n    with open(outfile, 'wb') as f:\n        f.write(r.content)\nCheck to make sure it is downloaded.\n\nls -l ./downloads\n\ntotal 1890256\n-rw-r--r-- 1 jovyan jovyan   21576707 Nov  4 22:48 20190622231000-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc\n-rw-r--r-- 1 jovyan jovyan 1914044034 Nov 12 17:03 ATL03_20190622061415_12980304_004_01.h5\n\n\nATL03_20190622061415_12980304_004_01.h5 is an HDF5 file. xarray can open this but you need to tell it which group to read the data from. In this case we read the height data for ground-track 1 left-beam.\n\nds = xr.open_dataset(outfile, group='/gt1l/heights')\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:         (delta_time: 19219882, ds_surf_type: 5)\nCoordinates:\n  * delta_time      (delta_time) datetime64[ns] 2019-06-22T06:14:14.882866488...\n    lat_ph          (delta_time) float64 ...\n    lon_ph          (delta_time) float64 ...\nDimensions without coordinates: ds_surf_type\nData variables:\n    dist_ph_across  (delta_time) float32 ...\n    dist_ph_along   (delta_time) float32 ...\n    h_ph            (delta_time) float32 ...\n    pce_mframe_cnt  (delta_time) uint32 ...\n    ph_id_channel   (delta_time) uint8 ...\n    ph_id_count     (delta_time) int8 ...\n    ph_id_pulse     (delta_time) uint8 ...\n    quality_ph      (delta_time) int8 ...\n    signal_conf_ph  (delta_time, ds_surf_type) int8 ...\nAttributes:\n    Description:  Contains arrays of the parameters for each received photon.\n    data_rate:    Data are stored at the photon detection rate.xarray.DatasetDimensions:delta_time: 19219882ds_surf_type: 5Coordinates: (3)delta_time(delta_time)datetime64[ns]2019-06-22T06:14:14.882866488 .....long_name :Elapsed GPS secondsstandard_name :timesource :OperationscontentType :referenceInformationdescription :The transmit time of a given photon, measured in seconds from the ATLAS Standard Data Product Epoch. Note that multiple received photons associated with a single transmit pulse will have the same delta_time. The ATLAS Standard Data Products (SDP) epoch offset is defined within /ancillary_data/atlas_sdp_gps_epoch as the number of GPS seconds between the GPS epoch (1980-01-06T00:00:00.000000Z UTC) and the ATLAS SDP epoch. By adding the offset contained within atlas_sdp_gps_epoch to delta time parameters, the time in gps_seconds relative to the GPS epoch can be computed.array(['2019-06-22T06:14:14.882866488', '2019-06-22T06:14:14.882866488',\n       '2019-06-22T06:14:14.882866488', ..., '2019-06-22T06:19:24.064273608',\n       '2019-06-22T06:19:24.064273608', '2019-06-22T06:19:24.064273608'],\n      dtype='datetime64[ns]')lat_ph(delta_time)float64...long_name :Latitudestandard_name :latitudeunits :degrees_northsource :ATL03g ATBD, Section 3.4valid_min :-90.0valid_max :90.0contentType :modelResultdescription :Latitude of each received photon. Computed from the ECF Cartesian coordinates of the bounce point.[19219882 values with dtype=float64]lon_ph(delta_time)float64...long_name :Longitudestandard_name :longitudeunits :degrees_eastsource :ATL03g ATBD, Section 3.4valid_min :-180.0valid_max :180.0contentType :modelResultdescription :Longitude of each received photon. Computed from the ECF Cartesian coordinates of the bounce point.[19219882 values with dtype=float64]Data variables: (9)dist_ph_across(delta_time)float32...long_name :Distance off RGT.units :meterssource :ATL03 ATBD, Section 3.1contentType :modelResultdescription :Across-track distance projected to the ellipsoid of the received photon from the reference ground track.  This is based on the Along-Track Segment algorithm described in Section 3.1.[19219882 values with dtype=float32]dist_ph_along(delta_time)float32...long_name :Distance from equator crossing.units :meterssource :ATL03 ATBD, Section 3.1contentType :modelResultdescription :Along-track distance in a segment projected to the ellipsoid of the received photon, based on the Along-Track Segment algorithm.  Total along track distance can be found by adding this value to the sum of segment lengths measured from the start of the most recent reference groundtrack.[19219882 values with dtype=float32]h_ph(delta_time)float32...long_name :Photon WGS84 Heightstandard_name :heightunits :meterssource :ATL03g ATBD, Section 3.4contentType :physicalMeasurementdescription :Height of each received photon, relative to the WGS-84 ellipsoid including the geophysical corrections noted in Section 6. Please note that neither the geoid, ocean tide nor the dynamic atmosphere (DAC) corrections are applied to the ellipsoidal heights.[19219882 values with dtype=float32]pce_mframe_cnt(delta_time)uint32...long_name :PCE Major frame counterunits :countssource :Retained from prior a_alt_science_ph packetcontentType :referenceInformationdescription :The major frame counter is read from the digital flow controller in a given PCE card.  The counter identifies individual major frames across diag and science packets. Used as part of the photon ID.[19219882 values with dtype=uint32]ph_id_channel(delta_time)uint8...long_name :Receive channel idunits :1source :Derived as part of Photon IDvalid_min :1valid_max :120contentType :referenceInformationdescription :Channel number assigned for each received photon event. This is part of the photon ID. Values range from 1 to 120 to span all channels and rise/fall edges. Values 1 to 60 are for falling edge; PCE1 (1 to 20), PCE 2 (21 to 40) and PCE3 (41 to 60). Values 61 to 120 are for rising edge; PCE1 (61 to 80), PCE 2 (81 to 100) and PC3 (101 to 120).[19219882 values with dtype=uint8]ph_id_count(delta_time)int8...long_name :photon event counterunits :countssource :Derived as part of Photon IDcontentType :referenceInformationdescription :The photon event counter is part of photon ID and counts from 1 for each channel until reset by laser pulse counter.[19219882 values with dtype=int8]ph_id_pulse(delta_time)uint8...long_name :laser pulse counterunits :countssource :Derived as part of Photon IDcontentType :referenceInformationdescription :The laser pulse counter is part of photon ID and counts from 1 to 200 and is reset for each new major frame.[19219882 values with dtype=uint8]quality_ph(delta_time)int8...long_name :Photon Qualityunits :1source :ATL03 ATBDvalid_min :0valid_max :3contentType :qualityInformationdescription :Indicates the quality of the associated photon. 0=nominal, 1=possible_afterpulse, 2=possible_impulse_response_effect, 3=possible_tep. Use this flag in conjunction with signal_conf_ph to identify those photons that are likely noise or likely signal.flag_meanings :nominal possible_afterpulse possible_impulse_response_effect possible_tepflag_values :[0 1 2 3][19219882 values with dtype=int8]signal_conf_ph(delta_time, ds_surf_type)int8...long_name :Photon Signal Confidenceunits :1source :ATL03 ATBD, Section 5, Confvalid_min :-2valid_max :4contentType :qualityInformationdescription :Confidence level associated with each photon event selected as signal. 0=noise. 1=added to allow for buffer but algorithm classifies as background; 2=low; 3=med; 4=high).  This parameter is a 5xN array where N is the number of photons in the granule, and the 5 rows indicate signal finding for each surface type (in order: land, ocean, sea ice, land ice and inland water). Events not associated with a specific surface type have a confidence level of -1. Events evaluated as TEP returns have a confidence level of -2.flag_meanings :possible_tep not_considered noise buffer low medium highflag_values :[-2 -1  0  1  2  3  4][96099410 values with dtype=int8]Attributes: (2)Description :Contains arrays of the parameters for each received photon.data_rate :Data are stored at the photon detection rate.\n\n\n\nFirst, we need to determine the granules returned from our time and area of interest\n\nresponse = requests.get(granule_url, \n                        params={\n                            # 'concept_id': 'C1940475563-POCLOUD',\n                            'concept_id': modis_concept_id,\n                            'temporal': temporal,\n                            'bounding_box': bounding_box,\n                            'page_size': 200,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nprint(response.headers['CMR-Hits'])\n\n14\n\n\n\ngranules = response.json()['feed']['entry']\n\nfor i, granule in enumerate(granules):\n    print(f'{i} {granule[\"title\"]}')\n    print(granule['boxes'])\n\n0 20190622000501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['68.972 -68.622 89.99 111.998']\n1 20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['67.505 -92.071 89.99 87.113']\n2 20190622032501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['65.037 -117.358 89.988 62.455']\n3 20190622050001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['65.673 -142.512 89.989 37.796']\n4 20190622050501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['62.203 -97.787 87.561 30.113']\n5 20190622064001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['68.031 -166.037 89.987 12.922']\n6 20190622064501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0\n['59.101 -98.694 83.559 -6.594']\n7 20190622064501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['59.101 -98.694 83.559 -6.594']\n8 20190622082001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['68.515 176.605 89.987 180', '68.515 -180 89.987 -19.769']\n9 20190622100001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['66.272 152.489 89.986 180', '66.272 -180 89.986 -45.947']\n10 20190622113501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['64.393 128.518 89.987 180', '64.393 -180 89.987 120.43']\n11 20190622114001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['63.599 130.464 89.481 180', '63.599 -180 89.481 -62.731']\n12 20190622163001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['60.019 -118.832 84.664 -19.808']\n13 20190622181001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0\n['63.055 -155.844 88.671 -8.036']\n\n\ndef bbox_geometry(boxs, t_crs=ccrs.NorthPolarStereo(), coord_order='swne', sep=' '):\n    '''Generates a shapely.geometry.box object from boxes metadata'''\n    if coord_order == 'swne':\n        lat_min, lon_min, lat_max, lon_max = [float(v) for v in boxs.split(sep)]\n    elif coord_order == 'wsen':\n        lon_min, lat_min, lon_max, lat_max = [float(v) for v in boxs.split(sep)]\n    x_min, y_min = t_crs.transform_point(lon_min, lat_min, ccrs.PlateCarree())\n    x_max, y_max = t_crs.transform_point(lon_max, lat_max, ccrs.PlateCarree())\n    return box(x_min, y_min, x_max, y_max)\nbbox_list = []\nfor granule in granules:\n    for bbox in granule['boxes']:\n        bbox_list.append(bbox_geometry(bbox))\n\nwarnings.simplefilter(\"ignore\")\n\nmap_proj = ccrs.NorthPolarStereo()\n\nfig = plt.figure(figsize=(7,7))\nax = fig.add_subplot(projection=map_proj)\nax.set_extent([-180., 180., 60., 90.], ccrs.PlateCarree())\nax.coastlines()\nax.gridlines()\n\nax.add_geometries([bbox_geometry(bounding_box, coord_order='wsen', sep=',')], crs=map_proj)\nax.add_geometries([bbox_list[0]], crs=map_proj, facecolor='none')\n\n<cartopy.mpl.feature_artist.FeatureArtist at 0x7face03db8b0>\n\n\n\n\n\n\n\n\nPull MODIS granules into xarray “in place”\nAlternative section heading ### Load granule into xarray via S3 direct access\nOur CMR granule search returned 14 files for our time and area of interest. However, not all granules will be suitable for analysis.\nI’ve identified the image with granule id G1956158784-POCLOUD as a good candidate, this is the 9th granule. In this image, our area of interest is close to nadir. This means that the instantaneous field of view over the area of interest cover a smaller area than at the edge of the image.\nWe can use pprint to look at the metadata.\nWe are looking for the link for direct download access via s3. This is a url but with a prefix s3://. This happens to be the first href link in the metadata.\n\npprint(granules[9])\n\n{'boxes': ['67.505 -92.071 89.99 87.113'],\n 'browse_flag': False,\n 'collection_concept_id': 'C1940473819-POCLOUD',\n 'coordinate_system': 'CARTESIAN',\n 'data_center': 'POCLOUD',\n 'dataset_id': 'GHRSST Level 2P Global Sea Surface Skin Temperature from the '\n               'Moderate Resolution Imaging Spectroradiometer (MODIS) on the '\n               'NASA Aqua satellite (GDS2)',\n 'day_night_flag': 'UNSPECIFIED',\n 'granule_size': '9.34600830078125E-5',\n 'id': 'G1956158784-POCLOUD',\n 'links': [{'href': 's3://podaac-ops-cumulus-protected/MODIS_A-JPL-L2P-v2019.0/20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/s3#',\n            'title': 'This link provides direct download access via S3 to the '\n                     'granule.'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MODIS_A-JPL-L2P-v2019.0/20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n            'title': 'Download '\n                     '20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-public/MODIS_A-JPL-L2P-v2019.0/20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc.md5',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n            'title': 'Download '\n                     '20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc.md5'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-public/MODIS_A-JPL-L2P-v2019.0/20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.cmr.json',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n            'title': 'Download '\n                     '20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.cmr.json'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/s3credentials',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n            'title': 'api endpoint to retrieve temporary credentials valid for '\n                     'same-region direct s3 access'},\n           {'href': 'https://opendap.earthdata.nasa.gov/providers/POCLOUD/collections/GHRSST%20Level%202P%20Global%20Sea%20Surface%20Skin%20Temperature%20from%20the%20Moderate%20Resolution%20Imaging%20Spectroradiometer%20(MODIS)%20on%20the%20NASA%20Aqua%20satellite%20(GDS2)/granules/20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n            'title': 'OPeNDAP request URL'},\n           {'href': 'https://github.com/podaac/data-readers',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://podaac-tools.jpl.nasa.gov/drive/files/OceanTemperature/ghrsst/docs/GDS20r5.pdf',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://ghrsst.jpl.nasa.gov',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/flag/',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://oceancolor.gsfc.nasa.gov/reprocessing/r2019/sst/',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst4/',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://modis.gsfc.nasa.gov/data/atbd/atbd_mod25.pdf',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'http://www.ghrsst.org',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://podaac.jpl.nasa.gov/forum/viewforum.php?f=18&sid=e2d67e5a01815fc6e39fcd2087ed8bc8',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://podaac.jpl.nasa.gov/CitingPODAAC',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://cmr.earthdata.nasa.gov/virtual-directory/collections/C1940473819-POCLOUD',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'length': '75.0MB',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'},\n           {'href': 'https://github.com/podaac/tutorials/blob/master/notebooks/MODIS_L2P_SST_DataCube.ipynb',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://search.earthdata.nasa.gov/search/granules?p=C1940473819-POCLOUD',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n 'online_access_flag': True,\n 'original_format': 'UMM_JSON',\n 'time_end': '2019-06-22T01:49:59.000Z',\n 'time_start': '2019-06-22T01:45:01.000Z',\n 'title': '20190622014501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0',\n 'updated': '2020-10-23T01:10:19.509Z'}\n\n\nFor a single granule we can cut and paste the s3 link. If we have several granules, the s3 links can be extracted with some simple code.\n\ngranule = granules[9]\n\nfor link in granule['links']:\n    if link['href'].startswith('s3://'):\n        s3_link = link['href']\ns3_link\n\n's3://podaac-ops-cumulus-protected/MODIS_A-JPL-L2P-v2019.0/20190622100001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc'\n\n\n\n\nGet S3 credentials\nAs with the previous S3 download tutorials we need credentials to access data from s3: access keys and tokens.\ns3_credentials = requests.get('https://archive.podaac.earthdata.nasa.gov/s3credentials').json()\nEssentially, what we are doing in this step is to “mount” the s3 bucket as a file system. This allows us to treat the S3 bucket in a similar way to a local file system. We can list data using ls, copy data, and write data - assuming we have the permissions to do this.\ns3_fs = s3fs.S3FileSystem(\n    key=s3_credentials[\"accessKeyId\"],\n    secret=s3_credentials[\"secretAccessKey\"],\n    token=s3_credentials[\"sessionToken\"],\n)"
  },
  {
    "objectID": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#find-suitable-granule",
    "href": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#find-suitable-granule",
    "title": "",
    "section": "Find suitable granule",
    "text": "I’ll move this section an ancillary notebook\ndef get_s3_link(granule):\n    for link in granule['links']:\n        if link['href'].startswith('s3://'):\n            return link['href']\n        else:\n            raise FileNotFoundError('No s3 link found')\n            \n\ndef convert_attributes(da):\n    for attr, value in da.attrs.items():\n        if isinstance(value[0], bytes):\n            da.attrs[attr] = value[0].decode()\n        else:\n            da.attrs[attr] = value[0]\n    return\n\n\ndef fix_attributes(ds):\n    '''Converts string attributes from bytes to str'''\n    # Fix variable attributes\n    for var in ds.variables:\n        da = ds[var]\n        convert_attributes(da)\n    # Fix global attributes\n    convert_attributes(ds)\n    return\n\n\ndef fix_and_decode_cf(ds):\n    '''Fixes variable attributes and decodes cf'''\n    fix_attributes(ds)\n    ds = xr.decode_cf(ds)\n    return ds\n\n\ndef plot_modis_sst(ds, ax, title=None):\n    map_proj = ccrs.NorthPolarStereo()\n\n    ax.set_extent([-180., 180., 60., 90.], ccrs.PlateCarree())\n    ax.coastlines()\n    ax.gridlines()\n\n    #ax.add_geometries([bbox_geometry(bounding_box, t_crs=map_proj)], crs=map_proj)\n    ax.scatter([-62.8, -56.4], [81.7, 83.], transform=ccrs.PlateCarree(),\n              zorder=5)\n    every =30\n    ax.scatter(ds.lon[::every,::every], ds.lat[::every,::every], 2,\n               transform=ccrs.PlateCarree())\n    if title: ax.set_title(title)\n\n    return ax\ndef open_and_plot_one_granule(granule, ax):\n    try:\n        s3_link = get_s3_link(granule)\n    except FileNotFoundError as err:\n        print(f'{err} for {granule[\"id\"]}')\n        raise\n        \n    f = s3_fs.open(s3_link, mode='rb')\n    ds = xr.open_dataset(f, decode_cf=False)\n    ds = fix_and_decode_cf(ds)\n    \n    ax = plot_modis_sst(ds, ax, granule['id'])\n    \n    f.close()\n\nwarnings.simplefilter('ignore')\n\nnrows = 5\nncols = 3\n\nfig = plt.figure(figsize=(10, 15))\nax = fig.add_subplot(projection=map_proj)\n\nopen_and_plot_one_granule(granules[9], ax)\n#for idx, granule in enumerate(granules, start=1):\n    \nfig.savefig('modis_l2_ss2_location.png')   \n    #break\n\n\n\n\n\nOpen a s3 file\nNow we have the S3FileSystem set up, we can access the granule. xarray cannot open a S3File directly, so we use the open method for the S3FileSystem to open the granule using the endpoint url we extracted from the metadata. We also have to set the mode='rb'. This opens the granule in read-only mode and in byte-mode. Byte-mode is important. By default, open opens a file as text - in this case it would just be a string of characters - and xarray doesn’t know what to do with that.\nWe then pass the S3File object f to xarray.open_dataset. For this dataset, we also have to set decode_cf=False. This switch tells xarray not to use information contained in variable attributes to generate human readable coordinate variables. Normally, this should work for netcdf files but for this particular cloud-hosted dataset, variable attribute data is not in the form expected by xarray. We’ll fix this.\nf = s3_fs.open(s3_link, mode='rb')\nds = xr.open_dataset(f, decode_cf=False)\nIf you click on the Show/Hide Attributes icon (the first document-like icon to the right of coordinate variable metadata) you can see that attributes are one-element arrays containing bytestrings.\n\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:                  (nj: 2030, ni: 1354, time: 1)\nCoordinates:\n  * time                     (time) int32 1214042401\nDimensions without coordinates: nj, ni\nData variables:\n    lat                      (nj, ni) float32 ...\n    lon                      (nj, ni) float32 ...\n    sea_surface_temperature  (time, nj, ni) int16 ...\n    sst_dtime                (time, nj, ni) int16 ...\n    quality_level            (time, nj, ni) int8 ...\n    sses_bias                (time, nj, ni) int8 ...\n    sses_standard_deviation  (time, nj, ni) int8 ...\n    l2p_flags                (time, nj, ni) int16 ...\n    chlorophyll_a            (time, nj, ni) float32 ...\n    K_490                    (time, nj, ni) int16 ...\n    wind_speed               (time, nj, ni) int8 ...\n    dt_analysis              (time, nj, ni) int8 ...\nAttributes: (12/49)\n    Conventions:                [b'CF-1.7, ACDD-1.3']\n    title:                      [b'MODIS Aqua L2P SST']\n    summary:                    [b'Sea surface temperature retrievals produce...\n    references:                 [b'GHRSST Data Processing Specification v2r5']\n    institution:                [b'NASA/JPL/OBPG/RSMAS']\n    history:                    [b'MODIS L2P created at JPL PO.DAAC']\n    ...                         ...\n    publisher_email:            [b'ghrsst-po@nceo.ac.uk']\n    processing_level:           [b'L2P']\n    cdm_data_type:              [b'swath']\n    startDirection:             [b'Ascending']\n    endDirection:               [b'Descending']\n    day_night_flag:             [b'Day']xarray.DatasetDimensions:nj: 2030ni: 1354time: 1Coordinates: (1)time(time)int321214042401long_name :[b'reference time of sst file']standard_name :[b'time']units :[b'seconds since 1981-01-01 00:00:00']comment :[b'time of first sensor observation']coverage_content_type :[b'coordinate']array([1214042401], dtype=int32)Data variables: (12)lat(nj, ni)float32...long_name :[b'latitude']standard_name :[b'latitude']units :[b'degrees_north']_FillValue :[-999.]valid_min :[-90.]valid_max :[90.]comment :[b'geographical coordinates, WGS84 projection']coverage_content_type :[b'coordinate'][2748620 values with dtype=float32]lon(nj, ni)float32...long_name :[b'longitude']standard_name :[b'longitude']units :[b'degrees_east']_FillValue :[-999.]valid_min :[-180.]valid_max :[180.]comment :[b'geographical coordinates, WGS84 projection']coverage_content_type :[b'coordinate'][2748620 values with dtype=float32]sea_surface_temperature(time, nj, ni)int16...long_name :[b'sea surface temperature']standard_name :[b'sea_surface_skin_temperature']units :[b'kelvin']_FillValue :[-32767]valid_min :[-1000]valid_max :[10000]comment :[b'sea surface temperature from thermal IR (11 um) channels']scale_factor :[0.005]add_offset :[273.15]source :[b'NASA and University of Miami']coordinates :[b'lon lat']coverage_content_type :[b'physicalMeasurement'][2748620 values with dtype=int16]sst_dtime(time, nj, ni)int16...long_name :[b'time difference from reference time']units :[b'seconds']_FillValue :[-32768]valid_min :[-32767]valid_max :[32767]comment :[b'time plus sst_dtime gives seconds after 00:00:00 UTC January 1, 1981']coordinates :[b'lon lat']coverage_content_type :[b'referenceInformation'][2748620 values with dtype=int16]quality_level(time, nj, ni)int8...long_name :[b'quality level of SST pixel']_FillValue :[-128]valid_min :[0]valid_max :[5]comment :[b'thermal IR SST proximity confidence value; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value']coordinates :[b'lon lat']flag_values :[0 1 2 3 4 5]flag_meanings :[b'no_data bad_data worst_quality low_quality acceptable_quality best_quality']coverage_content_type :[b'qualityInformation'][2748620 values with dtype=int8]sses_bias(time, nj, ni)int8...long_name :[b'SSES bias error based on proximity confidence flags']units :[b'kelvin']_FillValue :[-128]valid_min :[-127]valid_max :[127]comment :[b'thermal IR SST bias error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value']scale_factor :[0.15748031]add_offset :[0.]coordinates :[b'lon lat']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=int8]sses_standard_deviation(time, nj, ni)int8...long_name :[b'SSES standard deviation error based on proximity confidence flags']units :[b'kelvin']_FillValue :[-128]valid_min :[-127]valid_max :[127]comment :[b'thermal IR SST standard deviation error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value']scale_factor :[0.07874016]add_offset :[10.]coordinates :[b'lon lat']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=int8]l2p_flags(time, nj, ni)int16...long_name :[b'L2P flags']valid_min :[0]valid_max :[16]comment :[b'These flags can be used to further filter data variables']coordinates :[b'lon lat']flag_meanings :[b'microwave land ice lake river']flag_masks :[ 1  2  4  8 16]coverage_content_type :[b'qualityInformation'][2748620 values with dtype=int16]chlorophyll_a(time, nj, ni)float32...long_name :[b'Chlorophyll Concentration, OC3 Algorithm']units :[b'mg m^-3']_FillValue :[-32767.]valid_min :[0.001]valid_max :[100.]comment :[b'non L2P core field']coordinates :[b'lon lat']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=float32]K_490(time, nj, ni)int16...long_name :[b'Diffuse attenuation coefficient at 490 nm (OBPG)']units :[b'm^-1']_FillValue :[-32767]valid_min :[50]valid_max :[30000]comment :[b'non L2P core field']scale_factor :[0.0002]add_offset :[0.]coordinates :[b'lon lat']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=int16]wind_speed(time, nj, ni)int8...long_name :[b'10m wind speed']standard_name :[b'wind_speed']units :[b'm s-1']_FillValue :[-128]valid_min :[-127]valid_max :[127]comment :[b'Wind at 10 meters above the sea surface']scale_factor :[0.2]add_offset :[25.]source :[b'TBD.  Placeholder.  Currently empty']coordinates :[b'lon lat']grid_mapping :[b'TBD']time_offset :[2.]height :[b'10 m']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=int8]dt_analysis(time, nj, ni)int8...long_name :[b'deviation from SST reference climatology']units :[b'kelvin']_FillValue :[-128]valid_min :[-127]valid_max :[127]comment :[b'TBD']scale_factor :[0.1]add_offset :[0.]source :[b'TBD. Placeholder.  Currently empty']coordinates :[b'lon lat']coverage_content_type :[b'auxiliaryInformation'][2748620 values with dtype=int8]Attributes: (49)Conventions :[b'CF-1.7, ACDD-1.3']title :[b'MODIS Aqua L2P SST']summary :[b'Sea surface temperature retrievals produced at the NASA OBPG for the MODIS Aqua sensor.  These have been reformatted to GHRSST GDS specifications by the JPL PO.DAAC']references :[b'GHRSST Data Processing Specification v2r5']institution :[b'NASA/JPL/OBPG/RSMAS']history :[b'MODIS L2P created at JPL PO.DAAC']comment :[b'L2P Core without DT analysis or other ancillary fields; Day, Start Node:Ascending, End Node:Descending; WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value; Refined']license :[b'GHRSST and PO.DAAC protocol allow data use as free and open.']id :[b'MODIS_A-JPL-L2P-v2019.0']naming_authority :[b'org.ghrsst']product_version :[b'2019.0']uuid :[b'f6e1f61d-c4a4-4c17-8354-0c15e12d688b']gds_version_id :[b'2.0']netcdf_version_id :[b'4.1']date_created :[b'20200221T085224Z']file_quality_level :[3]spatial_resolution :[b'1km']start_time :[b'20190622T100001Z']time_coverage_start :[b'20190622T100001Z']stop_time :[b'20190622T100459Z']time_coverage_end :[b'20190622T100459Z']northernmost_latitude :[89.9862]southernmost_latitude :[66.2723]easternmost_longitude :[-45.9467]westernmost_longitude :[152.489]source :[b'MODIS sea surface temperature observations for the OBPG']platform :[b'Aqua']sensor :[b'MODIS']metadata_link :[b'http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MODIS_A-JPL-L2P-v2019.0']keywords :[b'Oceans > Ocean Temperature > Sea Surface Temperature']keywords_vocabulary :[b'NASA Global Change Master Directory (GCMD) Science Keywords']standard_name_vocabulary :[b'NetCDF Climate and Forecast (CF) Metadata Convention']geospatial_lat_units :[b'degrees_north']geospatial_lat_resolution :[0.01]geospatial_lon_units :[b'degrees_east']geospatial_lon_resolution :[0.01]acknowledgment :[b'The MODIS L2P sea surface temperature data are sponsored by NASA']creator_name :[b'Ed Armstrong, JPL PO.DAAC']creator_email :[b'edward.m.armstrong@jpl.nasa.gov']creator_url :[b'http://podaac.jpl.nasa.gov']project :[b'Group for High Resolution Sea Surface Temperature']publisher_name :[b'The GHRSST Project Office']publisher_url :[b'http://www.ghrsst.org']publisher_email :[b'ghrsst-po@nceo.ac.uk']processing_level :[b'L2P']cdm_data_type :[b'swath']startDirection :[b'Ascending']endDirection :[b'Descending']day_night_flag :[b'Day']\n\n\nTo fix this, we need to extract array elements as scalars, and convert those scalars from bytestrings to strings. I use the decode method to do this. The bytestrings are encoded as utf-8, which is a unicode character format. This is the default encoding for decode but I’ve included it as an argument to be explicit.\nNot all attributes are bytestrings. Some are floats. Take a look at _FillValue, and valid_min and valid_max. To avoid an error, I use the isinstance function to check if the value of an attributes is type bytes - a bytestring. If it is, I decode it. If not, I just extract the scalar and do nothing else.\nI also fix the global attributes.\ndef fix_attributes(da):\n    '''Decodes bytestring attributes to strings'''\n    for attr, value in da.attrs.items():\n        if isinstance(value[0], bytes):\n            da.attrs[attr] = value[0].decode('utf-8')\n        else:\n            da.attrs[attr] = value[0]\n    return\n\n# Fix variable attributes\nfor var in ds.variables:\n    da = ds[var]\n    fix_attributes(da)\n            \n# Fix global attributes\nfix_attributes(ds)\nWith this done, we can use the xarray function decode_cf to convert the attributes.\nds = xr.decode_cf(ds)\n\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:                  (nj: 2030, ni: 1354, time: 1)\nCoordinates:\n    lat                      (nj, ni) float32 ...\n    lon                      (nj, ni) float32 ...\n  * time                     (time) datetime64[ns] 2019-06-22T10:00:01\nDimensions without coordinates: nj, ni\nData variables:\n    sea_surface_temperature  (time, nj, ni) float32 ...\n    sst_dtime                (time, nj, ni) timedelta64[ns] ...\n    quality_level            (time, nj, ni) float32 ...\n    sses_bias                (time, nj, ni) float32 ...\n    sses_standard_deviation  (time, nj, ni) float32 ...\n    l2p_flags                (time, nj, ni) int16 ...\n    chlorophyll_a            (time, nj, ni) float32 ...\n    K_490                    (time, nj, ni) float32 ...\n    wind_speed               (time, nj, ni) float32 ...\n    dt_analysis              (time, nj, ni) float32 ...\nAttributes: (12/49)\n    Conventions:                CF-1.7, ACDD-1.3\n    title:                      MODIS Aqua L2P SST\n    summary:                    Sea surface temperature retrievals produced a...\n    references:                 GHRSST Data Processing Specification v2r5\n    institution:                NASA/JPL/OBPG/RSMAS\n    history:                    MODIS L2P created at JPL PO.DAAC\n    ...                         ...\n    publisher_email:            ghrsst-po@nceo.ac.uk\n    processing_level:           L2P\n    cdm_data_type:              swath\n    startDirection:             Ascending\n    endDirection:               Descending\n    day_night_flag:             Dayxarray.DatasetDimensions:nj: 2030ni: 1354time: 1Coordinates: (3)lat(nj, ni)float32...long_name :latitudestandard_name :latitudeunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geographical coordinates, WGS84 projectioncoverage_content_type :coordinate[2748620 values with dtype=float32]lon(nj, ni)float32...long_name :longitudestandard_name :longitudeunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geographical coordinates, WGS84 projectioncoverage_content_type :coordinate[2748620 values with dtype=float32]time(time)datetime64[ns]2019-06-22T10:00:01long_name :reference time of sst filestandard_name :timecomment :time of first sensor observationcoverage_content_type :coordinatearray(['2019-06-22T10:00:01.000000000'], dtype='datetime64[ns]')Data variables: (10)sea_surface_temperature(time, nj, ni)float32...long_name :sea surface temperaturestandard_name :sea_surface_skin_temperatureunits :kelvinvalid_min :-1000valid_max :10000comment :sea surface temperature from thermal IR (11 um) channelssource :NASA and University of Miamicoverage_content_type :physicalMeasurement[2748620 values with dtype=float32]sst_dtime(time, nj, ni)timedelta64[ns]...long_name :time difference from reference timevalid_min :-32767valid_max :32767comment :time plus sst_dtime gives seconds after 00:00:00 UTC January 1, 1981coverage_content_type :referenceInformation[2748620 values with dtype=timedelta64[ns]]quality_level(time, nj, ni)float32...long_name :quality level of SST pixelvalid_min :0valid_max :5comment :thermal IR SST proximity confidence value; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valueflag_values :0flag_meanings :no_data bad_data worst_quality low_quality acceptable_quality best_qualitycoverage_content_type :qualityInformation[2748620 values with dtype=float32]sses_bias(time, nj, ni)float32...long_name :SSES bias error based on proximity confidence flagsunits :kelvinvalid_min :-127valid_max :127comment :thermal IR SST bias error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valuecoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]sses_standard_deviation(time, nj, ni)float32...long_name :SSES standard deviation error based on proximity confidence flagsunits :kelvinvalid_min :-127valid_max :127comment :thermal IR SST standard deviation error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valuecoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]l2p_flags(time, nj, ni)int16...long_name :L2P flagsvalid_min :0valid_max :16comment :These flags can be used to further filter data variablesflag_meanings :microwave land ice lake riverflag_masks :1coverage_content_type :qualityInformation[2748620 values with dtype=int16]chlorophyll_a(time, nj, ni)float32...long_name :Chlorophyll Concentration, OC3 Algorithmunits :mg m^-3valid_min :0.001valid_max :100.0comment :non L2P core fieldcoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]K_490(time, nj, ni)float32...long_name :Diffuse attenuation coefficient at 490 nm (OBPG)units :m^-1valid_min :50valid_max :30000comment :non L2P core fieldcoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]wind_speed(time, nj, ni)float32...long_name :10m wind speedstandard_name :wind_speedunits :m s-1valid_min :-127valid_max :127comment :Wind at 10 meters above the sea surfacesource :TBD.  Placeholder.  Currently emptygrid_mapping :TBDtime_offset :2.0height :10 mcoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]dt_analysis(time, nj, ni)float32...long_name :deviation from SST reference climatologyunits :kelvinvalid_min :-127valid_max :127comment :TBDsource :TBD. Placeholder.  Currently emptycoverage_content_type :auxiliaryInformation[2748620 values with dtype=float32]Attributes: (49)Conventions :CF-1.7, ACDD-1.3title :MODIS Aqua L2P SSTsummary :Sea surface temperature retrievals produced at the NASA OBPG for the MODIS Aqua sensor.  These have been reformatted to GHRSST GDS specifications by the JPL PO.DAACreferences :GHRSST Data Processing Specification v2r5institution :NASA/JPL/OBPG/RSMAShistory :MODIS L2P created at JPL PO.DAACcomment :L2P Core without DT analysis or other ancillary fields; Day, Start Node:Ascending, End Node:Descending; WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value; Refinedlicense :GHRSST and PO.DAAC protocol allow data use as free and open.id :MODIS_A-JPL-L2P-v2019.0naming_authority :org.ghrsstproduct_version :2019.0uuid :f6e1f61d-c4a4-4c17-8354-0c15e12d688bgds_version_id :2.0netcdf_version_id :4.1date_created :20200221T085224Zfile_quality_level :3spatial_resolution :1kmstart_time :20190622T100001Ztime_coverage_start :20190622T100001Zstop_time :20190622T100459Ztime_coverage_end :20190622T100459Znorthernmost_latitude :89.9862southernmost_latitude :66.2723easternmost_longitude :-45.9467westernmost_longitude :152.489source :MODIS sea surface temperature observations for the OBPGplatform :Aquasensor :MODISmetadata_link :http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MODIS_A-JPL-L2P-v2019.0keywords :Oceans > Ocean Temperature > Sea Surface Temperaturekeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordsstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Metadata Conventiongeospatial_lat_units :degrees_northgeospatial_lat_resolution :0.01geospatial_lon_units :degrees_eastgeospatial_lon_resolution :0.01acknowledgment :The MODIS L2P sea surface temperature data are sponsored by NASAcreator_name :Ed Armstrong, JPL PO.DAACcreator_email :edward.m.armstrong@jpl.nasa.govcreator_url :http://podaac.jpl.nasa.govproject :Group for High Resolution Sea Surface Temperaturepublisher_name :The GHRSST Project Officepublisher_url :http://www.ghrsst.orgpublisher_email :ghrsst-po@nceo.ac.ukprocessing_level :L2Pcdm_data_type :swathstartDirection :AscendingendDirection :Descendingday_night_flag :Day\n\n\nLet’s make a quick plot to take a look at the sea_surface_temperature variable.\n\nds.sea_surface_temperature.plot()\n\n<matplotlib.collections.QuadMesh at 0x7fac5dbf0250>\n\n\n\n\n\n\n\nResample swath data to a grid\nTBD\n\n\nPlot MODIS L2 data\nmodis = xr.open_dataset('downloads/20190622231000-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc',\n                        decode_cf=True)\nmodis\n\nGet corners of modis image\ndata_proj = ccrs.NorthPolarStereo()\nx = []\nfor lat, lon in zip(modis.lat.isel(nj=[0,-1], ni=[0,-1]).values.flatten(),\n                    modis.lon.isel(nj=[0,-1], ni=[0,-1]).values.flatten()):\n    print(lat, lon)\nmodis.sea_surface_temperature.plot()\n`bounding_box is W,S,E,N\ndef bbox_geometry(boxs, t_crs=ccrs.NorthPolarStereo()):\n     '''Generates a shapely.geometry.box object from boxes metadata'''\n     lon_min, lat_min, lon_max, lat_max = [float(v) for v in boxs.split(',')]\n     x_min, y_min = t_crs.transform_point(lon_min, lat_min, ccrs.PlateCarree())\n     x_max, y_max = t_crs.transform_point(lon_max, lat_max, ccrs.PlateCarree())\n     return box(x_min, y_min, x_max, y_max)\nbounding_box\nmap_proj = ccrs.NorthPolarStereo()\n\nfig = plt.figure(figsize=(7,7))\nax = fig.add_subplot(projection=map_proj)\nax.set_extent([-180., 180., 60., 90.], ccrs.PlateCarree())\nax.coastlines()\nax.gridlines()\n\n#ax.add_geometries([bbox_geometry(bounding_box, t_crs=map_proj)], crs=map_proj)\nax.scatter([-62.8, -56.4], [81.7, 83.], transform=ccrs.PlateCarree())\n\nevery =30\nax.scatter(modis.lon[::every,::every], modis.lat[::every,::every], 2,\n           transform=ccrs.PlateCarree())\n\nfig.savefig(f'{modis_name}_lat_lon_plot.png')\nplt.imshow?\n\n\n\nUse geolocation of ICESat-2 to define the single transect used to pull coincident ocean data out from array\n\n\nCreate a plot of the single transect of gridded data\n(bonus: time series) - describe what this means to egress out of the cloud versus pulling the original data down (benefit to processing in the cloud)"
  },
  {
    "objectID": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#additional-plotting-code",
    "href": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#additional-plotting-code",
    "title": "",
    "section": "Additional plotting code",
    "text": "# from shapely.geometry import box\n# map_proj = ccrs.PlateCarree()\n# def bbox_geometry(boxs, t_crs=ccrs.NorthPolarStereo()):\n#     '''Generates a shapely.geometry.box object from boxes metadata'''\n#     lat_min, lon_min, lat_max, lon_max = [float(v) for v in bbox.split()]\n#     x_min, y_min = t_crs.transform_point(lon_min, lat_min, ccrs.PlateCarree())\n#     x_max, y_max = t_crs.transform_point(lon_max, lat_max, ccrs.PlateCarree())\n#     return box(x_min, y_min, x_max, y_max)\n\n# bbox_features = []\n# for granule in modis_granules_meta:\n#     for bbox in granule['boxes']:\n#         bbox_features.append(bbox_geometry(bbox))\n# fig = plt.figure(figsize=(7,7))\n# ax = fig.add_subplot(projection=ccrs.NorthPolarStereo())\n# ax.set_extent([-180.,180.,60.,90.], ccrs.PlateCarree())\n# ax.coastlines()\n# ax.add_geometries([bbox_features[0]], crs=map_proj, alpha=0.3)"
  },
  {
    "objectID": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#resources-optional",
    "href": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#resources-optional",
    "title": "",
    "section": "Resources (optional)",
    "text": ""
  },
  {
    "objectID": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#conclusion",
    "href": "tutorials/Data_Access__Harmonize-cloud-non-cloud.html#conclusion",
    "title": "",
    "section": "Conclusion",
    "text": ""
  },
  {
    "objectID": "tutorials/09_Zarr_Access.html#summary",
    "href": "tutorials/09_Zarr_Access.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Zarr is an open source library for storing N-dimensional array data. It supports multidimensional arrays with attributes and dimensions similar to NetCDF4, and it can be read by XArray. Zarr is often used for data held in cloud object storage (like Amazon S3), because it is better optimized for these situations than NetCDF4.\nThe zarr-eosdis-store library allows NASA EOSDIS NetCDF4 files to be read more efficiently by transferring only file metadata and data needed for computation in a small number of requests, rather than moving the whole file or making many small requests. It works by making the files directly readable by the Zarr Python library and XArray across a network. To use it, files must have a corresponding metadata file ending in .dmrpp, which increasingly true for cloud-accessible EOSDIS data. https://github.com/nasa/zarr-eosdis-store\nThe zarr-eosdis-store library provides several benefits over downloading EOSDIS data files and accessing them using XArray, NetCDF4, or HDF5 Python libraries:\n\nIt only downloads the chunks of data you actually read, so if you don’t read all variables or the full spatiotemporal extent of a file, you usually won’t spend time downloading those portions of the file\nIt parallelizes and optimizes downloads for the portions of files you do read, so download speeds can be faster in general\nIt automatically interoperates with Earthdata Login if you have a .netrc file set up\nIt is aware of some EOSDIS cloud implementation quirks and provides caching that can save time for repeated requests to individual files\n\nIt can also be faster than using XArray pointing NetCDF4 files with s3:// URLs, depending on the file’s internal structure, and is often more convenient.\nConsider using this library when: 1. The portion of the data file you need to use is much smaller than the full file, e.g. in cases of spatial subsets or reading a single variable from a file containing several 1. s3:// URLs are not readily available 1. Code need to run outside of the AWS cloud or us-west-2 region or in a hybrid cloud / non-cloud manner 1. s3:// access using XArray seems slower than you would expect (possibly due to unoptimized internal file structure) 1. No readily-available, public, cloud-optimized version of the data exists already. The example we show is also available as an AWS Public Dataset: https://registry.opendata.aws/mur/ 1. Adding “.dmrpp” to the end of a data URL returns a file\n\nObjectives\n\nBuild on prior knowledge from CMR and Earthdata Login tutorials\nWork through an example of using the EOSDIS Zarr Store to access data using XArray\nLearn about the Zarr format and library for accessing data in the cloud ___"
  },
  {
    "objectID": "tutorials/09_Zarr_Access.html#exercise",
    "href": "tutorials/09_Zarr_Access.html#exercise",
    "title": "",
    "section": "Exercise",
    "text": "In this exercise, we will be using the eosdis-zarr-store library to aggregate and analyze a month of sea surface temperature for the Great Lakes region\n\nSet up\n\nImport Required Packages\n# Core libraries for this tutorial\n# Available via `pip install zarr zarr-eosdis-store`\nfrom eosdis_store import EosdisStore\nimport xarray as xr\n\n# Other Python libraries\nimport numpy as np\nimport requests\nfrom pqdm.threads import pqdm\nfrom matplotlib import animation, pyplot as plt\nfrom IPython.core.display import display, HTML\n\n# Python standard library imports\nfrom pprint import pprint\nAlso set the width / height for plots we show\nplt.rcParams['figure.figsize'] = 12, 6\n\n\nSet Dataset, Time, and Region of Interest\nLook in PO.DAAC’s cloud archive for Group for High Resolution Sea Surface Temperature (GHRSST) Level 4 Multiscale Ultrahigh Resolution (MUR) data\ndata_provider = 'POCLOUD'\nmur_ShortName = 'MUR-JPL-L4-GLOB-v4.1'\nLooking for data from the month of September over the Great Lakes\nstart_time = '2021-09-01T21:00:00Z'\nend_time = '2021-09-30T20:59:59Z'\n\n# Bounding box around the Great Lakes\nlats = slice(41, 49)\nlons = slice(-93, -76)\n\n# Some other possibly interesting bounding boxes:\n\n# Hawaiian Islands\n# lats = slice(18, 22.5)\n# lons = slice(-161, -154)\n\n# Mediterranean Sea\n# lats = slice(29, 45)\n# lons = slice(-7, 37)\n\n\n\nFind URLs for the dataset and AOI\nSet up a CMR granules search for our area of interest, as we saw in prior tutorials\nCMR_OPS = 'https://cmr.earthdata.nasa.gov/search'\nurl = f'{CMR_OPS}/{\"granules\"}'\nSearch for granules in our area of interest, expecting one granule per day of September\nresponse = requests.get(url, \n                        params={\n                            'provider': data_provider,\n                            'short_name': mur_ShortName, \n                            'temporal': f'{start_time},{end_time}',\n                            'bounding_box': f'{lons.start},{lats.start},{lons.stop},{lats.stop}',\n                            'page_size': 2000,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\n\ngranules = response.json()['feed']['entry']\n\nfor granule in granules:\n    print(granule[\"title\"])\n\n20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210902090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210903090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210904090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210905090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210906090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210907090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210908090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210909090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210910090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210911090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210912090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210913090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210914090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210915090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210916090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210917090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210918090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210919090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210920090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210921090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210922090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210923090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210924090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210925090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210926090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210927090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210928090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210929090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n20210930090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1\n\n\n\npprint(granules[0])\n\n{'boxes': ['-90 -180 90 180'],\n 'browse_flag': False,\n 'collection_concept_id': 'C1996881146-POCLOUD',\n 'coordinate_system': 'CARTESIAN',\n 'data_center': 'POCLOUD',\n 'dataset_id': 'GHRSST Level 4 MUR Global Foundation Sea Surface Temperature '\n               'Analysis (v4.1)',\n 'day_night_flag': 'UNSPECIFIED',\n 'granule_size': '9.059906005859375E-5',\n 'id': 'G2113241213-POCLOUD',\n 'links': [{'href': 's3://podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/s3#',\n            'title': 'This link provides direct download access via S3 to the '\n                     'granule.'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#',\n            'title': 'Download '\n                     '20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-public/MUR-JPL-L4-GLOB-v4.1/20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc.md5',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n            'title': 'Download '\n                     '20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc.md5'},\n           {'href': 'https://archive.podaac.earthdata.nasa.gov/s3credentials',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#',\n            'title': 'api endpoint to retrieve temporary credentials valid for '\n                     'same-region direct s3 access'},\n           {'href': 'https://opendap.earthdata.nasa.gov/collections/C1996881146-POCLOUD/granules/20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1',\n            'hreflang': 'en-US',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/service#',\n            'title': 'OPeNDAP request URL'},\n           {'href': 'https://github.com/nasa/podaac_tools_and_services/tree/master/subset_opendap',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://ghrsst.jpl.nasa.gov',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://earthdata.nasa.gov/esds/competitive-programs/measures/mur-sst',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#'},\n           {'href': 'http://journals.ametsoc.org/doi/abs/10.1175/1520-0426%281998%29015%3C0741:BSHWSS%3E2.0.CO;2',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://podaac-tools.jpl.nasa.gov/drive/files/OceanTemperature/ghrsst/docs/GDS20r5.pdf',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://github.com/podaac/data-readers',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://doi.org/10.1016/j.rse.2017.07.029',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://registry.opendata.aws/mur/#usageexa',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/metadata#'},\n           {'href': 'http://www.ghrsst.org',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://podaac.jpl.nasa.gov/CitingPODAAC',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://cmr.earthdata.nasa.gov/virtual-directory/collections/C1996881146-POCLOUD ',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'length': '300.0MB',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'},\n           {'href': ' '\n                    'https://search.earthdata.nasa.gov/search/granules?p=C1996881146-POCLOUD ',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'length': '700.0MB',\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'},\n           {'href': 'https://podaac.jpl.nasa.gov/MEaSUREs-MUR',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n           {'href': 'https://github.com/podaac/tutorials/blob/master/notebooks/SWOT-EA-2021/Colocate_satellite_insitu_ocean.ipynb',\n            'hreflang': 'en-US',\n            'inherited': True,\n            'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'}],\n 'online_access_flag': True,\n 'original_format': 'UMM_JSON',\n 'time_end': '2021-09-01T21:00:00.000Z',\n 'time_start': '2021-08-31T21:00:00.000Z',\n 'title': '20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1',\n 'updated': '2021-09-10T07:29:40.511Z'}\n\n\n\nurls = []\nfor granule in granules:\n    for link in granule['links']:\n        if link['rel'].endswith('/data#'):\n            urls.append(link['href'])\n            break\npprint(urls)\n\n['https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210901090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210902090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210903090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210904090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210905090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210906090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210907090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210908090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210909090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210910090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210911090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210912090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210913090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210914090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210915090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210916090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210917090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210918090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210919090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210920090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210921090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210922090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210923090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210924090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210925090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210926090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210927090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210928090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210929090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc',\n 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210930090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc']\n\n\n\n\nOpen and view our AOI without downloading a whole file\n\nCheck to see if we can use an efficient partial-access technique\n\nresponse = requests.head(f'{urls[0]}.dmrpp')\n\nprint('Can we use EosdisZarrStore and XArray to access these files more efficiently?')\nprint('Yes' if response.ok else 'No')\n\nCan we use EosdisZarrStore and XArray to access these files more efficiently?\nYes\n\n\nOpen our first URL using the Zarr library\nurl = urls[0]\n\nds = xr.open_zarr(EosdisStore(url), consolidated=False)\nThat’s it! No downloads, temporary credentials, or S3 filesystems. Hereafter, we interact with the ds variable as with any XArray dataset. We need not worry about the EosdisStore anymore.\nView the file’s variable structure\n\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:           (time: 1, lat: 17999, lon: 36000)\nCoordinates:\n  * lat               (lat) float32 -89.99 -89.98 -89.97 ... 89.97 89.98 89.99\n  * lon               (lon) float32 -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time              (time) datetime64[ns] 2021-09-01T09:00:00\nData variables:\n    analysed_sst      (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    analysis_error    (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    dt_1km_data       (time, lat, lon) timedelta64[ns] dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    mask              (time, lat, lon) float32 dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    sea_ice_fraction  (time, lat, lon) float32 dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    sst_anomaly       (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\nAttributes: (12/47)\n    Conventions:                CF-1.7\n    title:                      Daily MUR SST, Final product\n    summary:                    A merged, multi-sensor L4 Foundation SST anal...\n    references:                 http://podaac.jpl.nasa.gov/Multi-scale_Ultra-...\n    institution:                Jet Propulsion Laboratory\n    history:                    created at nominal 4-day latency; replaced nr...\n    ...                         ...\n    project:                    NASA Making Earth Science Data Records for Us...\n    publisher_name:             GHRSST Project Office\n    publisher_url:              http://www.ghrsst.org\n    publisher_email:            ghrsst-po@nceo.ac.uk\n    processing_level:           L4\n    cdm_data_type:              gridxarray.DatasetDimensions:time: 1lat: 17999lon: 36000Coordinates: (3)lat(lat)float32-89.99 -89.98 ... 89.98 89.99long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000'], dtype='datetime64[ns]')Data variables: (6)analysed_sst(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         325 Tasks \n                         324 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nanalysis_error(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :estimated error standard deviation of analysed_sstunits :kelvinvalid_min :0valid_max :32767comment :uncertainty in \\\"analysed_sst\\\"\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         325 Tasks \n                         324 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \ndt_1km_data(time, lat, lon)timedelta64[ns]dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :time to most recent 1km datavalid_min :-127valid_max :127source :MODIS and VIIRS pixels ingested by MURcomment :The grid value is hours between the analysis time and the most recent MODIS or VIIRS 1km L2P datum within 0.01 degrees from the grid point.  \\\"Fill value\\\" indicates absence of such 1km data at the grid point.\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         4.83 GiB \n                         31.96 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         170 Tasks \n                         169 Chunks \n                    \n                    \n                     Type \n                     timedelta64[ns] \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nmask(time, lat, lon)float32dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :sea/land field composite maskvalid_min :1valid_max :31flag_masks :[1, 2, 4, 8, 16]flag_meanings :open_sea land open_lake open_sea_with_ice_in_the_grid open_lake_with_ice_in_the_gridcomment :mask can be used to further filter the data.source :GMT \\\"grdlandmask\\\", ice flag from sea_ice_fraction data\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         15.98 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         170 Tasks \n                         169 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nsea_ice_fraction(time, lat, lon)float32dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :sea ice area fractionstandard_name :sea_ice_area_fractionvalid_min :0valid_max :100source :EUMETSAT OSI-SAF, copyright EUMETSATcomment :ice fraction is a dimensionless quantity between 0 and 1; it has been interpolated by a nearest neighbor approach.\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         15.98 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         170 Tasks \n                         169 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nsst_anomaly(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :SST anomaly from a seasonal SST climatology based on the MUR data over 2003-2014 periodunits :kelvinvalid_min :-32767valid_max :32767comment :anomaly reference to the day-of-year average between 2003 and 2014\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         325 Tasks \n                         324 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nAttributes: (47)Conventions :CF-1.7title :Daily MUR SST, Final productsummary :A merged, multi-sensor L4 Foundation SST analysis product from JPL.references :http://podaac.jpl.nasa.gov/Multi-scale_Ultra-high_Resolution_MUR-SSTinstitution :Jet Propulsion Laboratoryhistory :created at nominal 4-day latency; replaced nrt (1-day latency) version.comment :MUR = \\\"Multi-scale Ultra-high Resolution\\\"license :These data are available free of charge under data policy of JPL PO.DAAC.id :MUR-JPL-L4-GLOB-v04.1naming_authority :org.ghrsstproduct_version :04.1uuid :27665bc0-d5fc-11e1-9b23-0800200c9a66gds_version_id :2.0netcdf_version_id :4.1date_created :20210910T072132Zstart_time :20210901T090000Zstop_time :20210901T090000Ztime_coverage_start :20210831T210000Ztime_coverage_end :20210901T210000Zfile_quality_level :3source :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAFplatform :Terra, Aqua, GCOM-W, MetOp-A, MetOp-B, Buoys/Shipssensor :MODIS, AMSR2, AVHRR, in-situMetadata_Conventions :Unidata Observation Dataset v1.0metadata_link :http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MUR-JPL-L4-GLOB-v04.1keywords :Oceans > Ocean Temperature > Sea Surface Temperaturekeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordsstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Metadata Conventionsouthernmost_latitude :-90.0northernmost_latitude :90.0westernmost_longitude :-180.0easternmost_longitude :180.0spatial_resolution :0.01 degreesgeospatial_lat_units :degrees northgeospatial_lat_resolution :0.009999999776geospatial_lon_units :degrees eastgeospatial_lon_resolution :0.009999999776acknowledgment :Please acknowledge the use of these data with the following statement:  These data were provided by JPL under support by NASA MEaSUREs program.creator_name :JPL MUR SST projectcreator_email :ghrsst@podaac.jpl.nasa.govcreator_url :http://mur.jpl.nasa.govproject :NASA Making Earth Science Data Records for Use in Research Environments (MEaSUREs) Programpublisher_name :GHRSST Project Officepublisher_url :http://www.ghrsst.orgpublisher_email :ghrsst-po@nceo.ac.ukprocessing_level :L4cdm_data_type :grid\n\n\n\nds.analysed_sst\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'analysed_sst' (time: 1, lat: 17999, lon: 36000)>\ndask.array<open_dataset-48ddff3b8205f4aeeebe5735c22fc854analysed_sst, shape=(1, 17999, 36000), dtype=float32, chunksize=(1, 1023, 2047), chunktype=numpy.ndarray>\nCoordinates:\n  * lat      (lat) float32 -89.99 -89.98 -89.97 -89.96 ... 89.97 89.98 89.99\n  * lon      (lon) float32 -180.0 -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time     (time) datetime64[ns] 2021-09-01T09:00:00\nAttributes:\n    long_name:      analysed sea surface temperature\n    standard_name:  sea_surface_foundation_temperature\n    units:          kelvin\n    valid_min:      -32767\n    valid_max:      32767\n    comment:        \\\"Final\\\" version using Multi-Resolution Variational Anal...\n    source:         MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, A...xarray.DataArray'analysed_sst'time: 1lat: 17999lon: 36000dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         2.41 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         325 Tasks \n                         324 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  1\n\n        \n    \nCoordinates: (3)lat(lat)float32-89.99 -89.98 ... 89.98 89.99long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000'], dtype='datetime64[ns]')Attributes: (7)long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n\n\n\nsst = ds.analysed_sst.sel(lat=lats, lon=lons)\nsst\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'analysed_sst' (time: 1, lat: 801, lon: 1701)>\ndask.array<getitem, shape=(1, 801, 1701), dtype=float32, chunksize=(1, 601, 1536), chunktype=numpy.ndarray>\nCoordinates:\n  * lat      (lat) float32 41.0 41.01 41.02 41.03 ... 48.97 48.98 48.99 49.0\n  * lon      (lon) float32 -93.0 -92.99 -92.98 -92.97 ... -76.02 -76.01 -76.0\n  * time     (time) datetime64[ns] 2021-09-01T09:00:00\nAttributes:\n    long_name:      analysed sea surface temperature\n    standard_name:  sea_surface_foundation_temperature\n    units:          kelvin\n    valid_min:      -32767\n    valid_max:      32767\n    comment:        \\\"Final\\\" version using Multi-Resolution Variational Anal...\n    source:         MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, A...xarray.DataArray'analysed_sst'time: 1lat: 801lon: 1701dask.array<chunksize=(1, 200, 1536), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         5.20 MiB \n                         3.52 MiB \n                    \n                    \n                    \n                         Shape \n                         (1, 801, 1701) \n                         (1, 601, 1536) \n                    \n                    \n                         Count \n                         329 Tasks \n                         4 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  \n  \n\n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n\n  \n  \n  \n  \n\n  \n  \n\n  \n  1701\n  801\n  1\n\n        \n    \nCoordinates: (3)lat(lat)float3241.0 41.01 41.02 ... 48.99 49.0long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([41.  , 41.01, 41.02, ..., 48.98, 48.99, 49.  ], dtype=float32)lon(lon)float32-93.0 -92.99 ... -76.01 -76.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-93.  , -92.99, -92.98, ..., -76.02, -76.01, -76.  ], dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000'], dtype='datetime64[ns]')Attributes: (7)long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n\n\n\nsst.plot()\n\n<matplotlib.collections.QuadMesh at 0x7fc2979b5c40>\n\n\n\n\n\n\n\n\nAggregate and analyze 30 files\nSet up a function to open all of our URLs as XArrays in parallel\n\ndef open_as_zarr_xarray(url):\n    return xr.open_zarr(EosdisStore(url), consolidated=False)\n\ndatasets = pqdm(urls, open_as_zarr_xarray, n_jobs=30)\n\n\n\n\n\n\n\n\n\n\nCombine the individual file-based datasets into a single xarray dataset with a time axis\n\nds = xr.concat(datasets, 'time')\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:           (time: 30, lat: 17999, lon: 36000)\nCoordinates:\n  * lat               (lat) float32 -89.99 -89.98 -89.97 ... 89.97 89.98 89.99\n  * lon               (lon) float32 -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time              (time) datetime64[ns] 2021-09-01T09:00:00 ... 2021-09-3...\nData variables:\n    analysed_sst      (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    analysis_error    (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    dt_1km_data       (time, lat, lon) timedelta64[ns] dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    mask              (time, lat, lon) float32 dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    sea_ice_fraction  (time, lat, lon) float32 dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>\n    sst_anomaly       (time, lat, lon) float32 dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\nAttributes: (12/47)\n    Conventions:                CF-1.7\n    title:                      Daily MUR SST, Final product\n    summary:                    A merged, multi-sensor L4 Foundation SST anal...\n    references:                 http://podaac.jpl.nasa.gov/Multi-scale_Ultra-...\n    institution:                Jet Propulsion Laboratory\n    history:                    created at nominal 4-day latency; replaced nr...\n    ...                         ...\n    project:                    NASA Making Earth Science Data Records for Us...\n    publisher_name:             GHRSST Project Office\n    publisher_url:              http://www.ghrsst.org\n    publisher_email:            ghrsst-po@nceo.ac.uk\n    processing_level:           L4\n    cdm_data_type:              gridxarray.DatasetDimensions:time: 30lat: 17999lon: 36000Coordinates: (3)lat(lat)float32-89.99 -89.98 ... 89.98 89.99long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00 ... 2021-09-...long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000', '2021-09-02T09:00:00.000000000',\n       '2021-09-03T09:00:00.000000000', '2021-09-04T09:00:00.000000000',\n       '2021-09-05T09:00:00.000000000', '2021-09-06T09:00:00.000000000',\n       '2021-09-07T09:00:00.000000000', '2021-09-08T09:00:00.000000000',\n       '2021-09-09T09:00:00.000000000', '2021-09-10T09:00:00.000000000',\n       '2021-09-11T09:00:00.000000000', '2021-09-12T09:00:00.000000000',\n       '2021-09-13T09:00:00.000000000', '2021-09-14T09:00:00.000000000',\n       '2021-09-15T09:00:00.000000000', '2021-09-16T09:00:00.000000000',\n       '2021-09-17T09:00:00.000000000', '2021-09-18T09:00:00.000000000',\n       '2021-09-19T09:00:00.000000000', '2021-09-20T09:00:00.000000000',\n       '2021-09-21T09:00:00.000000000', '2021-09-22T09:00:00.000000000',\n       '2021-09-23T09:00:00.000000000', '2021-09-24T09:00:00.000000000',\n       '2021-09-25T09:00:00.000000000', '2021-09-26T09:00:00.000000000',\n       '2021-09-27T09:00:00.000000000', '2021-09-28T09:00:00.000000000',\n       '2021-09-29T09:00:00.000000000', '2021-09-30T09:00:00.000000000'],\n      dtype='datetime64[ns]')Data variables: (6)analysed_sst(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         19470 Tasks \n                         9720 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nanalysis_error(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :estimated error standard deviation of analysed_sstunits :kelvinvalid_min :0valid_max :32767comment :uncertainty in \\\"analysed_sst\\\"\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         19470 Tasks \n                         9720 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \ndt_1km_data(time, lat, lon)timedelta64[ns]dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :time to most recent 1km datavalid_min :-127valid_max :127source :MODIS and VIIRS pixels ingested by MURcomment :The grid value is hours between the analysis time and the most recent MODIS or VIIRS 1km L2P datum within 0.01 degrees from the grid point.  \\\"Fill value\\\" indicates absence of such 1km data at the grid point.\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         144.83 GiB \n                         31.96 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         10170 Tasks \n                         5070 Chunks \n                    \n                    \n                     Type \n                     timedelta64[ns] \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nmask(time, lat, lon)float32dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :sea/land field composite maskvalid_min :1valid_max :31flag_masks :[1, 2, 4, 8, 16]flag_meanings :open_sea land open_lake open_sea_with_ice_in_the_grid open_lake_with_ice_in_the_gridcomment :mask can be used to further filter the data.source :GMT \\\"grdlandmask\\\", ice flag from sea_ice_fraction data\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         15.98 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         10170 Tasks \n                         5070 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nsea_ice_fraction(time, lat, lon)float32dask.array<chunksize=(1, 1447, 2895), meta=np.ndarray>long_name :sea ice area fractionstandard_name :sea_ice_area_fractionvalid_min :0valid_max :100source :EUMETSAT OSI-SAF, copyright EUMETSATcomment :ice fraction is a dimensionless quantity between 0 and 1; it has been interpolated by a nearest neighbor approach.\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         15.98 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1447, 2895) \n                    \n                    \n                         Count \n                         10170 Tasks \n                         5070 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nsst_anomaly(time, lat, lon)float32dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>long_name :SST anomaly from a seasonal SST climatology based on the MUR data over 2003-2014 periodunits :kelvinvalid_min :-32767valid_max :32767comment :anomaly reference to the day-of-year average between 2003 and 2014\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         19470 Tasks \n                         9720 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nAttributes: (47)Conventions :CF-1.7title :Daily MUR SST, Final productsummary :A merged, multi-sensor L4 Foundation SST analysis product from JPL.references :http://podaac.jpl.nasa.gov/Multi-scale_Ultra-high_Resolution_MUR-SSTinstitution :Jet Propulsion Laboratoryhistory :created at nominal 4-day latency; replaced nrt (1-day latency) version.comment :MUR = \\\"Multi-scale Ultra-high Resolution\\\"license :These data are available free of charge under data policy of JPL PO.DAAC.id :MUR-JPL-L4-GLOB-v04.1naming_authority :org.ghrsstproduct_version :04.1uuid :27665bc0-d5fc-11e1-9b23-0800200c9a66gds_version_id :2.0netcdf_version_id :4.1date_created :20210910T072132Zstart_time :20210901T090000Zstop_time :20210901T090000Ztime_coverage_start :20210831T210000Ztime_coverage_end :20210901T210000Zfile_quality_level :3source :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAFplatform :Terra, Aqua, GCOM-W, MetOp-A, MetOp-B, Buoys/Shipssensor :MODIS, AMSR2, AVHRR, in-situMetadata_Conventions :Unidata Observation Dataset v1.0metadata_link :http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MUR-JPL-L4-GLOB-v04.1keywords :Oceans > Ocean Temperature > Sea Surface Temperaturekeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordsstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Metadata Conventionsouthernmost_latitude :-90.0northernmost_latitude :90.0westernmost_longitude :-180.0easternmost_longitude :180.0spatial_resolution :0.01 degreesgeospatial_lat_units :degrees northgeospatial_lat_resolution :0.009999999776geospatial_lon_units :degrees eastgeospatial_lon_resolution :0.009999999776acknowledgment :Please acknowledge the use of these data with the following statement:  These data were provided by JPL under support by NASA MEaSUREs program.creator_name :JPL MUR SST projectcreator_email :ghrsst@podaac.jpl.nasa.govcreator_url :http://mur.jpl.nasa.govproject :NASA Making Earth Science Data Records for Use in Research Environments (MEaSUREs) Programpublisher_name :GHRSST Project Officepublisher_url :http://www.ghrsst.orgpublisher_email :ghrsst-po@nceo.ac.ukprocessing_level :L4cdm_data_type :grid\n\n\nLook at the Analysed SST variable metadata\n\nall_sst = ds.analysed_sst\nall_sst\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'analysed_sst' (time: 30, lat: 17999, lon: 36000)>\ndask.array<concatenate, shape=(30, 17999, 36000), dtype=float32, chunksize=(1, 1023, 2047), chunktype=numpy.ndarray>\nCoordinates:\n  * lat      (lat) float32 -89.99 -89.98 -89.97 -89.96 ... 89.97 89.98 89.99\n  * lon      (lon) float32 -180.0 -180.0 -180.0 -180.0 ... 180.0 180.0 180.0\n  * time     (time) datetime64[ns] 2021-09-01T09:00:00 ... 2021-09-30T09:00:00\nAttributes:\n    long_name:      analysed sea surface temperature\n    standard_name:  sea_surface_foundation_temperature\n    units:          kelvin\n    valid_min:      -32767\n    valid_max:      32767\n    comment:        \\\"Final\\\" version using Multi-Resolution Variational Anal...\n    source:         MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, A...xarray.DataArray'analysed_sst'time: 30lat: 17999lon: 36000dask.array<chunksize=(1, 1023, 2047), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         72.42 GiB \n                         7.99 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 17999, 36000) \n                         (1, 1023, 2047) \n                    \n                    \n                         Count \n                         19470 Tasks \n                         9720 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  36000\n  17999\n  30\n\n        \n    \nCoordinates: (3)lat(lat)float32-89.99 -89.98 ... 89.98 89.99long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([-89.99, -89.98, -89.97, ...,  89.97,  89.98,  89.99], dtype=float32)lon(lon)float32-180.0 -180.0 ... 180.0 180.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-179.99, -179.98, -179.97, ...,  179.98,  179.99,  180.  ],\n      dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00 ... 2021-09-...long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000', '2021-09-02T09:00:00.000000000',\n       '2021-09-03T09:00:00.000000000', '2021-09-04T09:00:00.000000000',\n       '2021-09-05T09:00:00.000000000', '2021-09-06T09:00:00.000000000',\n       '2021-09-07T09:00:00.000000000', '2021-09-08T09:00:00.000000000',\n       '2021-09-09T09:00:00.000000000', '2021-09-10T09:00:00.000000000',\n       '2021-09-11T09:00:00.000000000', '2021-09-12T09:00:00.000000000',\n       '2021-09-13T09:00:00.000000000', '2021-09-14T09:00:00.000000000',\n       '2021-09-15T09:00:00.000000000', '2021-09-16T09:00:00.000000000',\n       '2021-09-17T09:00:00.000000000', '2021-09-18T09:00:00.000000000',\n       '2021-09-19T09:00:00.000000000', '2021-09-20T09:00:00.000000000',\n       '2021-09-21T09:00:00.000000000', '2021-09-22T09:00:00.000000000',\n       '2021-09-23T09:00:00.000000000', '2021-09-24T09:00:00.000000000',\n       '2021-09-25T09:00:00.000000000', '2021-09-26T09:00:00.000000000',\n       '2021-09-27T09:00:00.000000000', '2021-09-28T09:00:00.000000000',\n       '2021-09-29T09:00:00.000000000', '2021-09-30T09:00:00.000000000'],\n      dtype='datetime64[ns]')Attributes: (7)long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n\n\nCreate a dataset / variable that is only our area of interest and view its metadata\n\nsst = ds.analysed_sst.sel(lat=lats, lon=lons)\nsst\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'analysed_sst' (time: 30, lat: 801, lon: 1701)>\ndask.array<getitem, shape=(30, 801, 1701), dtype=float32, chunksize=(1, 601, 1536), chunktype=numpy.ndarray>\nCoordinates:\n  * lat      (lat) float32 41.0 41.01 41.02 41.03 ... 48.97 48.98 48.99 49.0\n  * lon      (lon) float32 -93.0 -92.99 -92.98 -92.97 ... -76.02 -76.01 -76.0\n  * time     (time) datetime64[ns] 2021-09-01T09:00:00 ... 2021-09-30T09:00:00\nAttributes:\n    long_name:      analysed sea surface temperature\n    standard_name:  sea_surface_foundation_temperature\n    units:          kelvin\n    valid_min:      -32767\n    valid_max:      32767\n    comment:        \\\"Final\\\" version using Multi-Resolution Variational Anal...\n    source:         MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, A...xarray.DataArray'analysed_sst'time: 30lat: 801lon: 1701dask.array<chunksize=(1, 200, 1536), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         155.93 MiB \n                         3.52 MiB \n                    \n                    \n                    \n                         Shape \n                         (30, 801, 1701) \n                         (1, 601, 1536) \n                    \n                    \n                         Count \n                         19590 Tasks \n                         120 Chunks \n                    \n                    \n                     Type \n                     float32 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n\n  \n  \n  \n  \n\n  \n  \n\n  \n  1701\n  801\n  30\n\n        \n    \nCoordinates: (3)lat(lat)float3241.0 41.01 41.02 ... 48.99 49.0long_name :latitudestandard_name :latitudeaxis :Yunits :degrees_northvalid_min :-90.0valid_max :90.0comment :geolocations inherited from the input data without correctionarray([41.  , 41.01, 41.02, ..., 48.98, 48.99, 49.  ], dtype=float32)lon(lon)float32-93.0 -92.99 ... -76.01 -76.0long_name :longitudestandard_name :longitudeaxis :Xunits :degrees_eastvalid_min :-180.0valid_max :180.0comment :geolocations inherited from the input data without correctionarray([-93.  , -92.99, -92.98, ..., -76.02, -76.01, -76.  ], dtype=float32)time(time)datetime64[ns]2021-09-01T09:00:00 ... 2021-09-...long_name :reference time of sst fieldstandard_name :timeaxis :Tcomment :Nominal time of analyzed fieldsarray(['2021-09-01T09:00:00.000000000', '2021-09-02T09:00:00.000000000',\n       '2021-09-03T09:00:00.000000000', '2021-09-04T09:00:00.000000000',\n       '2021-09-05T09:00:00.000000000', '2021-09-06T09:00:00.000000000',\n       '2021-09-07T09:00:00.000000000', '2021-09-08T09:00:00.000000000',\n       '2021-09-09T09:00:00.000000000', '2021-09-10T09:00:00.000000000',\n       '2021-09-11T09:00:00.000000000', '2021-09-12T09:00:00.000000000',\n       '2021-09-13T09:00:00.000000000', '2021-09-14T09:00:00.000000000',\n       '2021-09-15T09:00:00.000000000', '2021-09-16T09:00:00.000000000',\n       '2021-09-17T09:00:00.000000000', '2021-09-18T09:00:00.000000000',\n       '2021-09-19T09:00:00.000000000', '2021-09-20T09:00:00.000000000',\n       '2021-09-21T09:00:00.000000000', '2021-09-22T09:00:00.000000000',\n       '2021-09-23T09:00:00.000000000', '2021-09-24T09:00:00.000000000',\n       '2021-09-25T09:00:00.000000000', '2021-09-26T09:00:00.000000000',\n       '2021-09-27T09:00:00.000000000', '2021-09-28T09:00:00.000000000',\n       '2021-09-29T09:00:00.000000000', '2021-09-30T09:00:00.000000000'],\n      dtype='datetime64[ns]')Attributes: (7)long_name :analysed sea surface temperaturestandard_name :sea_surface_foundation_temperatureunits :kelvinvalid_min :-32767valid_max :32767comment :\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolationsource :MODIS_T-JPL, MODIS_A-JPL, AMSR2-REMSS, AVHRRMTA_G-NAVO, AVHRRMTB_G-NAVO, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\n\n\nXArray reads data lazily, i.e. only when our code actually needs it. Up to this point, we haven’t read any data values, only metadata. The next line will force XArray to read the portions of the source files containing our area of interest. Behind the scenes, the eosdis-zarr-store library is ensuring data is fetched as efficiently as possible.\nNote: This line isn’t strictly necessary, since XArray will automatically read the data we need the first time our code tries to use it, but calling this will make sure that we can read the data multiple times later on without re-fetching anything from the source files.\nThis line will take several seconds to complete, but since it is retrieving only about 50 MB of data from 22 GB of source files, several seconds constitutes a significant time, bandwidth, and disk space savings.\nsst.load();\nNow we can start looking at aggregations across the time dimension. In this case, plot the standard deviation of the temperature at each point to get a visual sense of how much temperatures fluctuate over the course of the month.\n\n# We expect a warning here, from finding the standard deviation of arrays that contain all N/A values.\n# numpy produces N/A for these points, though, which is exactly what we want.\nstdev_sst = sst.std('time')\nstdev_sst.name = 'stdev of analyzed_sst [Kelvin]'\nstdev_sst.plot();\n\n/srv/conda/envs/notebook/lib/python3.9/site-packages/numpy/lib/nanfunctions.py:1670: RuntimeWarning: Degrees of freedom <= 0 for slice.\n  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n\n\n\n\n\n\nInteractive animation of a month of data\nThis section isn’t as important to fully understand. It shows us a way to get an interactive animation to see what we have retrieved so far\nDefine an animation function to plot the ith time step. We need to make sure each plot is using the same color scale, set by vmin and vmax so the animation is consistent\nsst_min = sst.min()\nsst_max = sst.max()\n\ndef show_time_step(i):\n    plt.clf()\n    res = sst[i].plot.imshow(vmin=sst_min, vmax=sst_max)\n    return (res,)\nRender each time slice once and show it as an HTML animation with interactive controls\n\nanim = animation.FuncAnimation(plt.gcf(), func=show_time_step, frames=len(sst))\ndisplay(HTML(anim.to_jshtml()))\nplt.close()\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\n\nSupplemental: What’s happening here?\nFor EOSDIS data in the cloud, we have begun producing a metadata sidecar file in a format called DMR++ that extracts all of the information about arrays, variables, and dimensions from data files, as well as the byte offsets in the NetCDF4 file where data can be found. This information is sufficient to let the Zarr library read data from our NetCDF4 files, but it’s in the wrong format. zarr-eosdis-store knows how to fetch the sidecar file and transform it into something the Zarr library understands. Passing it when reading Zarr using XArray or the Zarr library lets these libraries interact with EOSDIS data exactly as if they were Zarr stores in a way that’s more optimal for reading data in the cloud. Beyond this, the zarr-eosdis-store library makes some optimizations in the way it reads data to help make up for situations where the NetCDF4 file is not internally arranged well for cloud-based access patterns."
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#summary",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In the previous exercises we searched for and discovered cloud data assets that met certain search criteria (i.e., intersects with our region of interest and for a specified date range). The end goal was to find and save web links to the data assets we want to use in our workflow. The links we found allow us to download data via HTTPS (Hypertext Transfer Protocol Secure). However, NASA allows for direct in-region S3 bucket access for the same assets. In addition to saving the HTTPS links, we also created and saved the S3 links for those same cloud assets and we will use them here. In this exercise we will demonstrate how to perform direction in-region S3 bucket access for Harmonized Landsat Sentinel-2 (HLS) cloud data assets.\n\nDirect S3 Access\nNASA Eartdata Cloud provides two pathways for accessing data from the cloud. The first is via HTTPS. The other is through direct S3 bucket access. Below are some benefits and considerations when choosing to use direct S3 bucket access for NASA cloud assets.\n\nBenefits\n\nRetrieve data is very quickly\nNo need to download data! Work with data in a more efficient manner\nIncreased capacity to do parallel processing\nYou are working completely with the AWS cloud ecosystem and thus have access to the might of all AWS offerings (e.g., infrastructure, S3 API, services, etc.)\n\n\n\nConsiderations\n\nAccess only works within AWS us-west-2 region\nNeed an AWS S3 “token” to access S3 Bucket\nToken expires after 1 hour\nToken only works at the DAAC that generates it, e.g.,\n\nPO.DAAC token generator: https://archive.podaac.earthdata.nasa.gov/s3credentials\nLP DAAC token generator: https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials\n\nS3 on its own does not solve ‘cloud’ problems, but it is one key technology in solving big data problems\nStill have to load things in to memory, parallelize the computation, if working with really large data volumes. There are a lot of tool that allow you to do that, not discussed in this tutorial\n\n\n\n\nObjective\n\nConfigure our notebook environment and retrieve temporary S3 credentials for in-region direct S3 bucket access\nAccess a single HLS file\nAccess and clip an HLS file to a region of interest\nCreate an HLS time series data array\n\nLet’s get started!\n\n\n\nImport Required Packages\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nimport os\nimport subprocess\nimport requests\nimport boto3\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nimport rasterio as rio\nfrom rasterio.session import AWSSession\nfrom rasterio.plot import show\nimport rioxarray\nimport geopandas\nimport pyproj\nfrom pyproj import Proj\nfrom shapely.ops import transform\nimport geoviews as gv\nfrom cartopy import crs\nimport hvplot.xarray\nimport holoviews as hv\ngv.extension('bokeh', 'matplotlib')"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#configure-local-environment-and-get-temporary-credentials",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#configure-local-environment-and-get-temporary-credentials",
    "title": "",
    "section": "Configure Local Environment and Get Temporary Credentials",
    "text": "To perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME. A netrc file is required to aquire these credentials. Use the NASA Earthdata Authentication to create a netrc file in your home directory.\ns3_cred_endpoint = 'https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials'\ndef get_temp_creds():\n    temp_creds_url = s3_cred_endpoint\n    return requests.get(temp_creds_url).json()\ntemp_creds_req = get_temp_creds()\n#temp_creds_req                      # !!! BEWARE, removing the # on this line will print your temporary S3 credentials.\n\nInsert the credentials into our boto3 session and configure our rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session is used to pass credentials and configuration to AWS so we can interact wit S3 objects from applicable buckets.\nsession = boto3.Session(aws_access_key_id=temp_creds_req['accessKeyId'], \n                        aws_secret_access_key=temp_creds_req['secretAccessKey'],\n                        aws_session_token=temp_creds_req['sessionToken'],\n                        region_name='us-west-2')\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n\nrio_env = rio.Env(AWSSession(session),\n                  GDAL_DISABLE_READDIR_ON_OPEN='EMPTY_DIR',\n                  GDAL_HTTP_COOKIEFILE=os.path.expanduser('~/cookies.txt'),\n                  GDAL_HTTP_COOKIEJAR=os.path.expanduser('~/cookies.txt'))\nrio_env.__enter__()\n\n<rasterio.env.Env at 0x7fe992047490>"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-s3-links",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-s3-links",
    "title": "",
    "section": "Read in S3 Links",
    "text": "In the CMR-STAC API tutorial we saved off multiple text file containing links, both HTTPS and S3 links, to Harmonized Landsat Sentinel-2 (HLS) cloud data assets. We will now read in one of those file and show how to access those data assets.\n\nList the available files in the data directory\n\nfor f in os.listdir('./data'):\n    print(f)\n\nHTTPS_T13TGF_B02_Links.txt\nS3_T13TGF_B05_Links.txt\nne_w_agfields.geojson\nHTTPS_T13TGF_Fmask_Links.txt\n.ipynb_checkpoints\nS3_T13TGF_B8A_Links.txt\nHTTPS_T13TGF_B04_Links.txt\nS3_T13TGF_B04_Links.txt\nS3_T13TGF_Fmask_Links.txt\nHTTPS_T13TGF_B8A_Links.txt\ndataset-diagram.png\nHTTPS_T13TGF_B05_Links.txt\nS3_T13TGF_B02_Links.txt\n\n\nWe will safe our list of links and a single link as Python objects for use later.\n\ns3_links = open('./data/S3_T13TGF_B04_Links.txt').read().splitlines()\ns3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']\n\n\n\ns3_link = s3_links[0]\ns3_link\n\n's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif'"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-a-single-hls-file",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-a-single-hls-file",
    "title": "",
    "section": "Read in a single HLS file",
    "text": "We’ll access the HLS S3 object using the rioxarray Python package. The package is an extension of xarray and rasterio, allowing users to read in and interact with geospatial data using xarray data structures. We will also be leveraging the tight integration between xarray and dask to lazily read in data via the chunks parameter. This allows us to connect to the HLS S3 object, reading only metadata, an not load the data into memory until we request it via the loads() function.\n\nhls_da = rioxarray.open_rasterio(s3_link, chuncks=True)\nhls_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (band: 1, y: 3660, x: 3660)>\n[13395600 values with dtype=int16]\nCoordinates:\n  * band         (band) int64 1\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayband: 1y: 3660x: 3660...[13395600 values with dtype=int16]Coordinates: (4)band(band)int641array([1])x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\nWhen GeoTIFFS/Cloud Optimized GeoTIFFS are read in, a band coordinate variable is automatically created (see the print out above). In this exercise we will not use that coordinate variable, so we will remove it using the squeeze() function to avoid confusion.\n\nhls_da = hls_da.squeeze('band', drop=True)\nhls_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (y: 3660, x: 3660)>\n[13395600 values with dtype=int16]\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayy: 3660x: 3660...[13395600 values with dtype=int16]Coordinates: (3)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\n\nPlot the HLS S3 object\n\nhls_da.hvplot.image(x='x', y='y', cmap='fire', rasterize=True, width=800, height=600, colorbar=True)    # colormaps -> https://holoviews.org/user_guide/Colormaps.html\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\nWe can print out the data value as a numpy array by typing .values\n\nhls_da.values\n\narray([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)\n\n\nUp to this point, we have not saved anything but metadata into memory. To save or load the data into memory we can call the .load() function.\n\nhls_da_data = hls_da.load()\nhls_da_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (y: 3660, x: 3660)>\narray([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayy: 3660x: 3660-9999 -9999 -9999 -9999 -9999 -9999 ... 1676 1486 1112 954 1127 1133array([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)Coordinates: (3)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\ndel(hls_da_data)"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-a-single-hls-file",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-a-single-hls-file",
    "title": "",
    "section": "Read in and clip a single HLS file",
    "text": "To clip the HLS file, our feature representing our region of interest must be in the same coordinate reference system (CRS) or projection coordinate system as the HLS file. The map projection for our HLS file is Universal Transverse Mercator (UTM) zone 13N. Our feature is mapped to WGS84 geographic coordinate system grid space. We need to transform the geographic coordinate reference system (CRS) of our feature to the UTM projected coordinate system (i.e., UTM Zone 13N)\n\nRead in our geojson file and transform its CRS\nfield = geopandas.read_file('./data/ne_w_agfields.geojson')\nLet’s take a look at the bounding coordinate values.\n\nfield_shape = field.geometry[0]\nfield_shape.bounds\n\n(-101.67271614074707,\n 41.04754380304359,\n -101.65344715118408,\n 41.06213891056728)\n\n\nNote, the values above are in decimal degrees and represent the longitude and latitude for the lower left corner (-101.67271614074707, 41.04754380304359) and upper right corner (-101.65344715118408, 41.06213891056728) respectively.\n\n\nGet the projection information from the HLS file\n\nhls_proj = hls_da.rio.crs\nhls_proj\n\nCRS.from_epsg(32613)\n\n\n\n\nTransform coordinates from lat lon (units = dd) to UTM (units = m)\ngeo_CRS = Proj('+proj=longlat +datum=WGS84 +no_defs', preserve_units=True)   # Source coordinate system of the ROI\nproject = pyproj.Transformer.from_proj(geo_CRS, hls_proj)                    # Set up the transformation\n\nfsUTM = transform(project.transform, field_shape)\nfsUTM.bounds\n\n(779588.4994601272, 4549370.366049466, 781270.1479326887, 4551052.979639321)\n\n\nThe coordinates for our feature have now been converted to UTM Zone 13N whether meters is the designated unit. Note the difference in the values between field_shape.bounds (in geographic) and fsUTM.bounds (in UTM projection).\nNow we can clip our HLS file to our region of insterest!\n\n\nAccess and clip the HLS file\nWe can now use our transformed ROI bounding box to clip the HLS S3 object we accessed before. We’ll use the `rio.clip\nhls_da_clip = rioxarray.open_rasterio(s3_link, chunks=True).squeeze('band', drop=True).rio.clip([fsUTM])\n\nhls_da_clip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (y: 56, x: 56)>\ndask.array<astype, shape=(56, 56), dtype=int16, chunksize=(56, 56), chunktype=numpy.ndarray>\nCoordinates:\n  * y            (y) float64 4.551e+06 4.551e+06 ... 4.549e+06 4.549e+06\n  * x            (x) float64 7.796e+05 7.796e+05 ... 7.812e+05 7.812e+05\n    spatial_ref  int64 0\nAttributes:\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Red\n    _FillValue:    -9999xarray.DataArrayy: 56x: 56dask.array<chunksize=(56, 56), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         6.12 kiB \n                         6.12 kiB \n                    \n                    \n                    \n                         Shape \n                         (56, 56) \n                         (56, 56) \n                    \n                    \n                         Count \n                         12 Tasks \n                         1 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n\n  \n  \n  \n\n  \n  \n\n  \n  56\n  56\n\n        \n    \nCoordinates: (3)y(y)float644.551e+06 4.551e+06 ... 4.549e+06axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([4551045., 4551015., 4550985., 4550955., 4550925., 4550895., 4550865.,\n       4550835., 4550805., 4550775., 4550745., 4550715., 4550685., 4550655.,\n       4550625., 4550595., 4550565., 4550535., 4550505., 4550475., 4550445.,\n       4550415., 4550385., 4550355., 4550325., 4550295., 4550265., 4550235.,\n       4550205., 4550175., 4550145., 4550115., 4550085., 4550055., 4550025.,\n       4549995., 4549965., 4549935., 4549905., 4549875., 4549845., 4549815.,\n       4549785., 4549755., 4549725., 4549695., 4549665., 4549635., 4549605.,\n       4549575., 4549545., 4549515., 4549485., 4549455., 4549425., 4549395.])x(x)float647.796e+05 7.796e+05 ... 7.812e+05axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([779595., 779625., 779655., 779685., 779715., 779745., 779775., 779805.,\n       779835., 779865., 779895., 779925., 779955., 779985., 780015., 780045.,\n       780075., 780105., 780135., 780165., 780195., 780225., 780255., 780285.,\n       780315., 780345., 780375., 780405., 780435., 780465., 780495., 780525.,\n       780555., 780585., 780615., 780645., 780675., 780705., 780735., 780765.,\n       780795., 780825., 780855., 780885., 780915., 780945., 780975., 781005.,\n       781035., 781065., 781095., 781125., 781155., 781185., 781215., 781245.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :779580.0 30.0 0.0 4551060.0 0.0 -30.0array(0)Attributes: (4)scale_factor :0.0001add_offset :0.0long_name :Red_FillValue :-9999\n\n\n\nhls_da_clip.hvplot.image(x = 'x', y = 'y', crs = 'EPSG:32613', cmap='fire', rasterize=True, width=800, height=600, colorbar=True)\n\nUnable to display output for mime type(s):"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-an-hls-time-series",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-an-hls-time-series",
    "title": "",
    "section": "Read in and clip an HLS time series",
    "text": "Now we’ll read in multiple HLS S3 objects as a time series xarray. Let’s print the links list again to see what we’re working with.\n\ns3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']\n\n\nCurrently, the utilities and packages used in Python to read in GeoTIFF/COG file do not recognize associated dates stored in the internal metadata. To account for the dates for each file we must create a time variable and add it as a dimension in our final time series xarray. We’ll create a function that extracts the date from the file link and create an xarray variable with a time array of datetime objects.\ndef time_index_from_filenames(file_links):\n    '''\n    Helper function to create a pandas DatetimeIndex\n    '''\n    return [datetime.strptime(f.split('.')[-5], '%Y%jT%H%M%S') for f in file_links]\ntime = xr.Variable('time', time_index_from_filenames(s3_links))\nWe’ll now specify a chunk size to use that matches the internal tiling of HLS files. This will help improve performance.\nchunks=dict(band=1, x=1024, y=1024)\nNow, we will create our time series.\n\nhls_ts_da = xr.concat([rioxarray.open_rasterio(f, chunks=chunks).squeeze('band', drop=True) for f in s3_links], dim=time)\nhls_ts_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 3660, x: 3660)>\ndask.array<concatenate, shape=(19, 3660, 3660), dtype=int16, chunksize=(1, 1024, 1024), chunktype=numpy.ndarray>\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArraytime: 19y: 3660x: 3660dask.array<chunksize=(1, 1024, 1024), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         2.00 MiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 1024, 1024) \n                    \n                    \n                         Count \n                         1235 Tasks \n                         304 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nCoordinates: (4)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:30:21.000000000', '2021-05-20T17:28:59.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\nSince we used the chunks parameter while reading the data, the hls_ts_da object is read into memory. To do that we’ll use the load() function. But, before that, we’ll clip the hls_ts_da object to our roi using our transformed roi coordinates.\n\nhls_ts_da_clip = hls_ts_da.rio.clip([fsUTM]).load()\nhls_ts_da_clip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 56, x: 56)>\narray([[[-9999, -9999, -9999, ...,   980, -9999, -9999],\n        [-9999, -9999, -9999, ...,   287, -9999, -9999],\n        [ 1573,  1692,  1708, ...,   410, -9999, -9999],\n        ...,\n        [-9999, -9999,  1165, ...,  1808,  1869,  1906],\n        [-9999, -9999,   989, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1085, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,   860, -9999, -9999],\n        [-9999, -9999, -9999, ...,   496, -9999, -9999],\n        [ 2681,  2773,  2496, ...,   550, -9999, -9999],\n        ...,\n        [-9999, -9999,  3847, ...,  1997,  1914,  1831],\n        [-9999, -9999,  4062, ..., -9999, -9999, -9999],\n        [-9999, -9999,  4313, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,   808, -9999, -9999],\n        [-9999, -9999, -9999, ...,   230, -9999, -9999],\n        [ 1802,  1828,  1863, ...,   306, -9999, -9999],\n        ...,\n...\n        ...,\n        [-9999, -9999,  1124, ...,   804,   934,  1008],\n        [-9999, -9999,  1003, ..., -9999, -9999, -9999],\n        [-9999, -9999,   904, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,  1313, -9999, -9999],\n        [-9999, -9999, -9999, ...,  1327, -9999, -9999],\n        [ 1091,  1094,  1179, ...,  1223, -9999, -9999],\n        ...,\n        [-9999, -9999,  1145, ...,  1005,  1097,  1197],\n        [-9999, -9999,  1037, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1114, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,  1272, -9999, -9999],\n        [-9999, -9999, -9999, ...,  1231, -9999, -9999],\n        [ 1086,  1105,  1193, ...,  1205, -9999, -9999],\n        ...,\n        [-9999, -9999,  1045, ...,  1049,  1142,  1219],\n        [-9999, -9999,   926, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1076, ..., -9999, -9999, -9999]]], dtype=int16)\nCoordinates:\n  * y            (y) float64 4.551e+06 4.551e+06 ... 4.549e+06 4.549e+06\n  * x            (x) float64 7.796e+05 7.796e+05 ... 7.812e+05 7.812e+05\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\n    spatial_ref  int64 0\nAttributes:\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Red\n    _FillValue:    -9999xarray.DataArraytime: 19y: 56x: 56-9999 -9999 -9999 -9999 -9999 -9999 ... -9999 -9999 -9999 -9999 -9999array([[[-9999, -9999, -9999, ...,   980, -9999, -9999],\n        [-9999, -9999, -9999, ...,   287, -9999, -9999],\n        [ 1573,  1692,  1708, ...,   410, -9999, -9999],\n        ...,\n        [-9999, -9999,  1165, ...,  1808,  1869,  1906],\n        [-9999, -9999,   989, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1085, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,   860, -9999, -9999],\n        [-9999, -9999, -9999, ...,   496, -9999, -9999],\n        [ 2681,  2773,  2496, ...,   550, -9999, -9999],\n        ...,\n        [-9999, -9999,  3847, ...,  1997,  1914,  1831],\n        [-9999, -9999,  4062, ..., -9999, -9999, -9999],\n        [-9999, -9999,  4313, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,   808, -9999, -9999],\n        [-9999, -9999, -9999, ...,   230, -9999, -9999],\n        [ 1802,  1828,  1863, ...,   306, -9999, -9999],\n        ...,\n...\n        ...,\n        [-9999, -9999,  1124, ...,   804,   934,  1008],\n        [-9999, -9999,  1003, ..., -9999, -9999, -9999],\n        [-9999, -9999,   904, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,  1313, -9999, -9999],\n        [-9999, -9999, -9999, ...,  1327, -9999, -9999],\n        [ 1091,  1094,  1179, ...,  1223, -9999, -9999],\n        ...,\n        [-9999, -9999,  1145, ...,  1005,  1097,  1197],\n        [-9999, -9999,  1037, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1114, ..., -9999, -9999, -9999]],\n\n       [[-9999, -9999, -9999, ...,  1272, -9999, -9999],\n        [-9999, -9999, -9999, ...,  1231, -9999, -9999],\n        [ 1086,  1105,  1193, ...,  1205, -9999, -9999],\n        ...,\n        [-9999, -9999,  1045, ...,  1049,  1142,  1219],\n        [-9999, -9999,   926, ..., -9999, -9999, -9999],\n        [-9999, -9999,  1076, ..., -9999, -9999, -9999]]], dtype=int16)Coordinates: (4)y(y)float644.551e+06 4.551e+06 ... 4.549e+06axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([4551045., 4551015., 4550985., 4550955., 4550925., 4550895., 4550865.,\n       4550835., 4550805., 4550775., 4550745., 4550715., 4550685., 4550655.,\n       4550625., 4550595., 4550565., 4550535., 4550505., 4550475., 4550445.,\n       4550415., 4550385., 4550355., 4550325., 4550295., 4550265., 4550235.,\n       4550205., 4550175., 4550145., 4550115., 4550085., 4550055., 4550025.,\n       4549995., 4549965., 4549935., 4549905., 4549875., 4549845., 4549815.,\n       4549785., 4549755., 4549725., 4549695., 4549665., 4549635., 4549605.,\n       4549575., 4549545., 4549515., 4549485., 4549455., 4549425., 4549395.])x(x)float647.796e+05 7.796e+05 ... 7.812e+05axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([779595., 779625., 779655., 779685., 779715., 779745., 779775., 779805.,\n       779835., 779865., 779895., 779925., 779955., 779985., 780015., 780045.,\n       780075., 780105., 780135., 780165., 780195., 780225., 780255., 780285.,\n       780315., 780345., 780375., 780405., 780435., 780465., 780495., 780525.,\n       780555., 780585., 780615., 780645., 780675., 780705., 780735., 780765.,\n       780795., 780825., 780855., 780885., 780915., 780945., 780975., 781005.,\n       781035., 781065., 781095., 781125., 781155., 781185., 781215., 781245.])time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:30:21.000000000', '2021-05-20T17:28:59.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :779580.0 30.0 0.0 4551060.0 0.0 -30.0array(0)Attributes: (4)scale_factor :0.0001add_offset :0.0long_name :Red_FillValue :-9999\n\n\nNow, we’ll see what we have. Use hvplot to plot the clipped time series\n\nhls_ts_da_clip.hvplot.image(x='x', y='y', width=800, height=600, colorbar=True, cmap='fire').opts(clim=(hls_ts_da_clip.values.min(), hls_ts_da_clip.values.max()))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\n# Exit our context\nrio_env.__exit__()"
  },
  {
    "objectID": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#resourses",
    "href": "tutorials/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#resourses",
    "title": "",
    "section": "Resourses",
    "text": "Build time series from multiple GeoTIFF files\nHvplot/Holoview Colormap\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/lpdaac_cloud_data_access/browse\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/hls-tutorial/browse"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#timing",
    "href": "tutorials/05_Data_Access_Direct_S3.html#timing",
    "title": "",
    "section": "Timing",
    "text": "Exercise: 20 minutes"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#summary",
    "href": "tutorials/05_Data_Access_Direct_S3.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In the previous exercises we searched for and discovered cloud data assets that met certain search criteria (i.e., intersects with our region of interest and for a specified date range). The end goal was to find and save web links to the data assets we want to use in our workflow. The links we found allow us to download data via HTTPS (Hypertext Transfer Protocol Secure). However, NASA allows for direct in-region S3 bucket access for the same assets. In addition to saving the HTTPS links, we also created and saved the S3 links for those same cloud assets and we will use them here. In this exercise we will demonstrate how to perform direction in-region S3 bucket access for Harmonized Landsat Sentinel-2 (HLS) cloud data assets.\n\nDirect S3 Access\nNASA Eartdata Cloud provides two pathways for accessing data from the cloud. The first is via HTTPS. The other is through direct S3 bucket access. Below are some benefits and considerations when choosing to use direct S3 bucket access for NASA cloud assets.\n\nBenefits\n\nRetrieve data is very quickly\n\nNo need to download data! Work with data in a more efficient manner\n\nIncreased capacity to do parallel processing\n\nYou are working completely with the AWS cloud ecosystem and thus have access to the might of all AWS offerings (e.g., infrastructure, S3 API, services, etc.)\n\n\n\nConsiderations\n\nIf you’re workflow is in the cloud, choose S3 over HTTPS\n\nAccess only works within AWS us-west-2 region\n\nNeed an AWS S3 “token” to access S3 Bucket\n\nToken expires after 1 hour\n\nToken only works at the DAAC that generates it, e.g.,\n\nPO.DAAC token generator: https://archive.podaac.earthdata.nasa.gov/s3credentials\n\nLP DAAC token generator: https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials\n\n\nS3 on its own does not solve ‘cloud’ problems, but it is one key technology in solving big data problems\n\nStill have to load things in to memory, parallelize the computation, if working with really large data volumes. There are a lot of tool that allow you to do that, not discussed in this tutorial"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials/05_Data_Access_Direct_S3.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "how to retrieve temporary S3 credentials for in-region direct S3 bucket access\n\nhow to configure our notebook environment for in-region direct S3 bucket access\n\nhow to access a single HLS file via in-region direct S3 bucket access\n\nhow to create an HLS time series data array from cloud assets via in-region direct S3 bucket access\n\nhow to plot results\n\nThis exercise can be found in the 2021 Cloud Hackathon Book"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#import-required-packages",
    "href": "tutorials/05_Data_Access_Direct_S3.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\nimport os\nimport subprocess\nimport requests\nimport boto3\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nimport rasterio as rio\nfrom rasterio.session import AWSSession\nfrom rasterio.plot import show\nimport rioxarray\nimport geopandas\nimport pyproj\nfrom pyproj import Proj\nfrom shapely.ops import transform\nimport geoviews as gv\nfrom cartopy import crs\nimport hvplot.xarray\nimport holoviews as hv\ngv.extension('bokeh', 'matplotlib')"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#configure-local-environment-and-get-temporary-credentials",
    "href": "tutorials/05_Data_Access_Direct_S3.html#configure-local-environment-and-get-temporary-credentials",
    "title": "",
    "section": "Configure Local Environment and Get Temporary Credentials",
    "text": "To perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME. A netrc file is required to aquire these credentials. Use the NASA Earthdata Authentication to create a netrc file in your home directory.\ns3_cred_endpoint = 'https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials'\ndef get_temp_creds():\n    temp_creds_url = s3_cred_endpoint\n    return requests.get(temp_creds_url).json()\ntemp_creds_req = get_temp_creds()\n#temp_creds_req                      # !!! BEWARE, removing the # on this line will print your temporary S3 credentials.\n\nInsert the credentials into our boto3 session and configure our rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session is used to pass credentials and configuration to AWS so we can interact wit S3 objects from applicable buckets.\nsession = boto3.Session(aws_access_key_id=temp_creds_req['accessKeyId'], \n                        aws_secret_access_key=temp_creds_req['secretAccessKey'],\n                        aws_session_token=temp_creds_req['sessionToken'],\n                        region_name='us-west-2')\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n\nrio_env = rio.Env(AWSSession(session),\n                  GDAL_DISABLE_READDIR_ON_OPEN='EMPTY_DIR',\n                  GDAL_HTTP_COOKIEFILE=os.path.expanduser('~/cookies.txt'),\n                  GDAL_HTTP_COOKIEJAR=os.path.expanduser('~/cookies.txt'))\nrio_env.__enter__()\n\n<rasterio.env.Env at 0x7f1e4336f460>"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#read-in-s3-links",
    "href": "tutorials/05_Data_Access_Direct_S3.html#read-in-s3-links",
    "title": "",
    "section": "Read in S3 Links",
    "text": "In the CMR-STAC API tutorial we saved off multiple text file containing links, both HTTPS and S3 links, to Harmonized Landsat Sentinel-2 (HLS) cloud data assets. We will now read in one of those file and show how to access those data assets.\n\nList the available files in the data directory\n\n[f for f in os.listdir('./data') if '.txt' in f]\n\n['HTTPS_T13TGF_B02_Links.txt',\n 'S3_T13TGF_B05_Links.txt',\n 'HTTPS_T13TGF_Fmask_Links.txt',\n 'S3_T13TGF_B8A_Links.txt',\n 'HTTPS_T13TGF_B04_Links.txt',\n 'S3_T13TGF_B04_Links.txt',\n 'S3_T13TGF_Fmask_Links.txt',\n 'HTTPS_T13TGF_B8A_Links.txt',\n 'HTTPS_T13TGF_B05_Links.txt',\n 'S3_T13TGF_B02_Links.txt']\n\n\nWe will safe our list of links and a single link as Python objects for use later.\n\ns3_links = open('./data/S3_T13TGF_B04_Links.txt').read().splitlines()\ns3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']\n\n\n\ns3_link = s3_links[0]\ns3_link\n\n's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif'"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#read-in-a-single-hls-file",
    "href": "tutorials/05_Data_Access_Direct_S3.html#read-in-a-single-hls-file",
    "title": "",
    "section": "Read in a single HLS file",
    "text": "We’ll access the HLS S3 object using the rioxarray Python package. The package is an extension of xarray and rasterio, allowing users to read in and interact with geospatial data using xarray data structures. We will also be leveraging the tight integration between xarray and dask to lazily read in data via the chunks parameter. This allows us to connect to the HLS S3 object, reading only metadata, an not load the data into memory until we request it via the loads() function.\n\nhls_da = rioxarray.open_rasterio(s3_link, chuncks=True)\nhls_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (band: 1, y: 3660, x: 3660)>\n[13395600 values with dtype=int16]\nCoordinates:\n  * band         (band) int64 1\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayband: 1y: 3660x: 3660...[13395600 values with dtype=int16]Coordinates: (4)band(band)int641array([1])x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\nWhen GeoTIFFS/Cloud Optimized GeoTIFFS are read in, a band coordinate variable is automatically created (see the print out above). In this exercise we will not use that coordinate variable, so we will remove it using the squeeze() function to avoid confusion.\n\nhls_da = hls_da.squeeze('band', drop=True)\nhls_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (y: 3660, x: 3660)>\n[13395600 values with dtype=int16]\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayy: 3660x: 3660...[13395600 values with dtype=int16]Coordinates: (3)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\n\nPlot the HLS S3 object\n\nhls_da.hvplot.image(x='x', y='y', cmap='fire', rasterize=True, width=800, height=600, colorbar=True)    # colormaps -> https://holoviews.org/user_guide/Colormaps.html\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\nWe can print out the data value as a numpy array by typing .values\n\nhls_da.values\n\narray([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)\n\n\nUp to this point, we have not saved anything but metadata into memory. To save or load the data into memory we can call the .load() function.\n\nhls_da_data = hls_da.load()\nhls_da_data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (y: 3660, x: 3660)>\narray([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArrayy: 3660x: 3660-9999 -9999 -9999 -9999 -9999 -9999 ... 1676 1486 1112 954 1127 1133array([[-9999, -9999, -9999, ...,  1527,  1440,  1412],\n       [-9999, -9999, -9999, ...,  1493,  1476,  1407],\n       [-9999, -9999, -9999, ...,  1466,  1438,  1359],\n       ...,\n       [-9999, -9999, -9999, ...,  1213,  1295,  1159],\n       [-9999, -9999, -9999, ...,  1042,  1232,  1185],\n       [-9999, -9999, -9999, ...,   954,  1127,  1133]], dtype=int16)Coordinates: (3)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\ndel(hls_da_data)"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#read-in-hls-as-a-time-series",
    "href": "tutorials/05_Data_Access_Direct_S3.html#read-in-hls-as-a-time-series",
    "title": "",
    "section": "Read in HLS as a time series",
    "text": "Now we’ll read in multiple HLS S3 objects as a time series xarray. Let’s print the links list again to see what we’re working with.\n\ns3_links\n\n['s3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021133T172406.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021133T173859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021140T173021.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021140T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021145T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021156T173029.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021163T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021165T172422.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021165T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021185T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021188T173037.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021190T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021198T173911.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021200T172859.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021203T173909.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021204T173042.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2021215T172901.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021220T173049.v1.5.B04.tif',\n 's3://lp-prod-protected/HLSL30.015/HLS.L30.T13TGF.2021229T172441.v1.5.B04.tif']\n\n\nCurrently, the utilities and packages used in Python to read in GeoTIFF/COG file do not recognize associated dates stored in the internal metadata. To account for the dates for each file we must create a time variable and add it as a dimension in our final time series xarray. We’ll create a function that extracts the date from the file link and create an xarray variable with a time array of datetime objects.\ndef time_index_from_filenames(file_links):\n    '''\n    Helper function to create a pandas DatetimeIndex\n    '''\n    return [datetime.strptime(f.split('.')[-5], '%Y%jT%H%M%S') for f in file_links]\ntime = xr.Variable('time', time_index_from_filenames(s3_links))\nWe’ll now specify a chunk size to use that matches the internal tiling of HLS files. This will help improve performance.\nchunks=dict(band=1, x=512, y=512)\nNow, we will create our time series.\n\nhls_ts_da = xr.concat([rioxarray.open_rasterio(f, chunks=chunks).squeeze('band', drop=True) for f in s3_links], dim=time)\nhls_ts_da\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray (time: 19, y: 3660, x: 3660)>\ndask.array<concatenate, shape=(19, 3660, 3660), dtype=int16, chunksize=(1, 512, 512), chunktype=numpy.ndarray>\nCoordinates:\n  * x            (x) float64 7e+05 7e+05 7e+05 ... 8.097e+05 8.097e+05 8.097e+05\n  * y            (y) float64 4.6e+06 4.6e+06 4.6e+06 ... 4.49e+06 4.49e+06\n    spatial_ref  int64 0\n  * time         (time) datetime64[ns] 2021-05-13T17:24:06 ... 2021-08-17T17:...\nAttributes:\n    _FillValue:    -9999.0\n    scale_factor:  0.0001\n    add_offset:    0.0\n    long_name:     Redxarray.DataArraytime: 19y: 3660x: 3660dask.array<chunksize=(1, 512, 512), meta=np.ndarray>\n    \n        \n            \n                \n                    \n                         \n                         Array \n                         Chunk \n                    \n                \n                \n                    \n                    \n                         Bytes \n                         485.45 MiB \n                         512.00 kiB \n                    \n                    \n                    \n                         Shape \n                         (19, 3660, 3660) \n                         (1, 512, 512) \n                    \n                    \n                         Count \n                         4883 Tasks \n                         1216 Chunks \n                    \n                    \n                     Type \n                     int16 \n                     numpy.ndarray \n                    \n                \n            \n        \n        \n        \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n\n  \n  3660\n  3660\n  19\n\n        \n    \nCoordinates: (4)x(x)float647e+05 7e+05 ... 8.097e+05 8.097e+05array([699975., 700005., 700035., ..., 809685., 809715., 809745.])y(y)float644.6e+06 4.6e+06 ... 4.49e+06array([4600005., 4599975., 4599945., ..., 4490295., 4490265., 4490235.])spatial_ref()int640crs_wkt :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :Unknown datum based upon the WGS 84 ellipsoidhorizontal_datum_name :Not_specified_based_on_WGS_84_spheroidprojected_crs_name :UTM Zone 13, Northern Hemispheregrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-105.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"UTM Zone 13, Northern Hemisphere\",GEOGCS[\"Unknown datum based upon the WGS 84 ellipsoid\",DATUM[\"Not_specified_based_on_WGS_84_spheroid\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-105],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :699960.0 30.0 0.0 4600020.0 0.0 -30.0array(0)time(time)datetime64[ns]2021-05-13T17:24:06 ... 2021-08-...array(['2021-05-13T17:24:06.000000000', '2021-05-13T17:38:59.000000000',\n       '2021-05-20T17:30:21.000000000', '2021-05-20T17:28:59.000000000',\n       '2021-05-25T17:29:01.000000000', '2021-06-05T17:30:29.000000000',\n       '2021-06-12T17:39:09.000000000', '2021-06-14T17:24:22.000000000',\n       '2021-06-14T17:29:01.000000000', '2021-07-04T17:29:01.000000000',\n       '2021-07-07T17:30:37.000000000', '2021-07-09T17:28:59.000000000',\n       '2021-07-17T17:39:11.000000000', '2021-07-19T17:28:59.000000000',\n       '2021-07-22T17:39:09.000000000', '2021-07-23T17:30:42.000000000',\n       '2021-08-03T17:29:01.000000000', '2021-08-08T17:30:49.000000000',\n       '2021-08-17T17:24:41.000000000'], dtype='datetime64[ns]')Attributes: (4)_FillValue :-9999.0scale_factor :0.0001add_offset :0.0long_name :Red\n\n\nSince we used the chunks parameter while reading the data, the hls_ts_da object is not read into memory yet. To do that we’ll use the load() function.\nNow, we’ll see what we have. Use hvplot to plot our time series\nhls_ts_da_data = hls_ts_da.load()\n\nhls_ts_da_data.hvplot.image(x='x', y='y', rasterize=True, width=800, height=600, colorbar=True, cmap='fire').opts(clim=(hls_ts_da_data.values.min(), hls_ts_da_data.values.max()))\n\nUnable to display output for mime type(s): \n\n\n\n\n\n\n\n\n  \n\n\n\n\n# Exit our context\nrio_env.__exit__()"
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#concluding-remarks",
    "href": "tutorials/05_Data_Access_Direct_S3.html#concluding-remarks",
    "title": "",
    "section": "Concluding Remarks",
    "text": "The above exercise demonstrated how to perform in-region direct S3 bucket access for HLS cloud data assets. HLS cloud data assets are stored as Cloud Optimized GeoTIFFs, a format that has been the benifactor of data discovery and access advancements within the Python ecosystem. Knowing what the data storage format is (e.g., COG, netcdf4, or zarr store) and/or what data access protocol you’re using is critical in determining what Python data access method you will use. For COG data, rioxarray package is often prefered due to is ability to bring the geospatial data format into an xarray object. For netcdf4 files, the standard xarray package incombination with s3fs allow users to perform in-region direct access reads into an xarray object. Finally, if you are using OPeNDAP to connect to data, specialized packages like pydap have been integrated into xarray for streamline access directly to an xarray object."
  },
  {
    "objectID": "tutorials/05_Data_Access_Direct_S3.html#resourses",
    "href": "tutorials/05_Data_Access_Direct_S3.html#resourses",
    "title": "",
    "section": "Resourses",
    "text": "Build time series from multiple GeoTIFF files\nHvplot/Holoview Colormap\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/lpdaac_cloud_data_access/browse\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/hls-tutorial/browse"
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "title": "",
    "section": "Using the Harmony-Py library to access customized data from NASA Earthdata",
    "text": ""
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#summary",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Harmony allows you to seamlessly analyze Earth observation data from different NASA data centers… https://harmony.earthdata.nasa.gov/\n\nBenefits\n\nConsistent access patterns to EOSDIS holdings make cross-data center data access easier\nData reduction services allow users to request only the data they want, in the format and projection they want\nAnalysis Ready Data and cloud access will help reduce time-to-science\nCommunity Development helps reduce the barriers for re-use of code and sharing of domain knowledge\n\nHarmony-Py is a Python library for integrating with NASA’s Harmony Services.\nHarmony-Py provides a Python alternative to directly using Harmony’s RESTful API. It handles NASA Earthdata Login (EDL) authentication and optionally integrates with the CMR Python Wrapper by accepting collection results as a request parameter. It’s convenient for scientists who wish to use Harmony from Jupyter notebooks as well as machine-to-machine communication with larger Python applications.\n\n\nObjectives\n\nPractice skills learned from intro to CMR tutorial to discover what access and service options exist for a given data set"
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#import-packages",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#import-packages",
    "title": "",
    "section": "Import Packages",
    "text": "from harmony import BBox, Client, Collection, Request, LinkType\nfrom harmony.config import Environment\nimport requests\nfrom pprint import pprint\nimport datetime as dt\nimport s3fs\nimport xarray as xr"
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "title": "",
    "section": "Discover service options for a given data set",
    "text": "First, what do we mean by a “service”? [TODO] Describe how we define services and their benefits, and how not all datasets have services on them due to level of support, etc….\nLet’s see what the collection metadata tells us\n\nBuilding off of CMR introduction tutorial:\ncmr_search_url = 'https://cmr.earthdata.nasa.gov/search'\nWe want to search by collection to inspect the access and service options that exist:\ncmr_collection_url = f'{cmr_search_url}/{\"collections\"}'\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given data set id (also referred to as a short_name).\nHere we are jumping ahead and already know the concept_id we are interested in, by browsing cloud-hosted datasets from PO.DAAC in Earthdata Search: https://search.earthdata.nasa.gov/portal/podaac-cloud/search.\nWe are going to focus on MODIS_A-JPL-L2P-v2019.0: GHRSST Level 2P Global Sea Surface Skin Temperature from the Moderate Resolution Imaging Spectroradiometer (MODIS) on the NASA Aqua satellite (GDS2). Let’s first save this as a variable that we can use later on once we request data from Harmony.\nshort_name= 'MODIS_A-JPL-L2P-v2019.0'\nconcept_id = 'C1940473819-POCLOUD'\nWe will view the top-level metadata for this collection to see what additional service and variable metadata exist.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'concept_id': concept_id,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\nPrint the response:\n\npprint(response)\n\n{'feed': {'entry': [{'archive_center': 'NASA/JPL/PODAAC',\n                     'associations': {'services': ['S1962070864-POCLOUD',\n                                                   'S2004184019-POCLOUD'],\n                                      'tools': ['TL2108419875-POCLOUD',\n                                                'TL2092786348-POCLOUD'],\n                                      'variables': ['V1997812737-POCLOUD',\n                                                    'V1997812697-POCLOUD',\n                                                    'V2112014688-POCLOUD',\n                                                    'V1997812756-POCLOUD',\n                                                    'V1997812688-POCLOUD',\n                                                    'V1997812670-POCLOUD',\n                                                    'V1997812724-POCLOUD',\n                                                    'V2112014684-POCLOUD',\n                                                    'V1997812701-POCLOUD',\n                                                    'V1997812681-POCLOUD',\n                                                    'V2112014686-POCLOUD',\n                                                    'V1997812663-POCLOUD',\n                                                    'V1997812676-POCLOUD',\n                                                    'V1997812744-POCLOUD',\n                                                    'V1997812714-POCLOUD']},\n                     'boxes': ['-90 -180 90 180'],\n                     'browse_flag': True,\n                     'collection_data_type': 'SCIENCE_QUALITY',\n                     'coordinate_system': 'CARTESIAN',\n                     'data_center': 'POCLOUD',\n                     'dataset_id': 'GHRSST Level 2P Global Sea Surface Skin '\n                                   'Temperature from the Moderate Resolution '\n                                   'Imaging Spectroradiometer (MODIS) on the '\n                                   'NASA Aqua satellite (GDS2)',\n                     'has_formats': True,\n                     'has_spatial_subsetting': True,\n                     'has_temporal_subsetting': True,\n                     'has_transforms': False,\n                     'has_variables': True,\n                     'id': 'C1940473819-POCLOUD',\n                     'links': [{'href': 'https://podaac.jpl.nasa.gov/Podaac/thumbnails/MODIS_A-JPL-L2P-v2019.0.jpg',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n                               {'href': 'https://github.com/podaac/data-readers',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac-tools.jpl.nasa.gov/drive/files/OceanTemperature/ghrsst/docs/GDS20r5.pdf',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://ghrsst.jpl.nasa.gov',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/flag/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/reprocessing/r2019/sst/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst4/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://modis.gsfc.nasa.gov/data/atbd/atbd_mod25.pdf',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'http://www.ghrsst.org',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac.jpl.nasa.gov/forum/viewforum.php?f=18&sid=e2d67e5a01815fc6e39fcd2087ed8bc8',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac.jpl.nasa.gov/CitingPODAAC',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://cmr.earthdata.nasa.gov/virtual-directory/collections/C1940473819-POCLOUD',\n                                'hreflang': 'en-US',\n                                'length': '75.0MB',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'},\n                               {'href': 'https://github.com/podaac/tutorials/blob/master/notebooks/MODIS_L2P_SST_DataCube.ipynb',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://search.earthdata.nasa.gov/search/granules?p=C1940473819-POCLOUD',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n                     'online_access_flag': True,\n                     'orbit_parameters': {'inclination_angle': '98.1',\n                                          'number_of_orbits': '1.0',\n                                          'period': '98.4',\n                                          'swath_width': '2330.0'},\n                     'organizations': ['NASA/JPL/PODAAC'],\n                     'original_format': 'UMM_JSON',\n                     'platforms': ['Aqua'],\n                     'processing_level_id': '2',\n                     'service_features': {'esi': {'has_formats': False,\n                                                  'has_spatial_subsetting': False,\n                                                  'has_temporal_subsetting': False,\n                                                  'has_transforms': False,\n                                                  'has_variables': False},\n                                          'harmony': {'has_formats': True,\n                                                      'has_spatial_subsetting': True,\n                                                      'has_temporal_subsetting': True,\n                                                      'has_transforms': False,\n                                                      'has_variables': True},\n                                          'opendap': {'has_formats': True,\n                                                      'has_spatial_subsetting': True,\n                                                      'has_temporal_subsetting': True,\n                                                      'has_transforms': False,\n                                                      'has_variables': True}},\n                     'short_name': 'MODIS_A-JPL-L2P-v2019.0',\n                     'summary': 'NASA produces skin sea surface temperature '\n                                '(SST) products from the Infrared (IR) '\n                                'channels of the Moderate-resolution Imaging '\n                                'Spectroradiometer (MODIS) onboard the Aqua '\n                                'satellite. Aqua was launched by NASA on May '\n                                '4, 2002, into a sun synchronous, polar orbit '\n                                'with a daylight ascending node at 1:30 pm, '\n                                'formation flying in the A-train with other '\n                                'Earth Observation Satellites (EOS), to study '\n                                'the global dynamics of the Earth atmosphere, '\n                                'land and oceans. MODIS captures data in 36 '\n                                'spectral bands at a variety of spatial '\n                                'resolutions.  Two SST products can be present '\n                                'in these files. The first is a skin SST '\n                                'produced for both day and night (NSST) '\n                                'observations, derived from the long wave IR '\n                                '11 and 12 micron wavelength channels, using a '\n                                'modified nonlinear SST algorithm intended to '\n                                'provide continuity of SST derived from '\n                                'heritage and current NASA sensors. At night, '\n                                'a second SST product is generated using the '\n                                'mid-infrared 3.95 and 4.05 micron  wavelength '\n                                'channels which are unique to MODIS; the SST '\n                                'derived from these measurements is identified '\n                                'as SST4. The SST4 product has lower '\n                                'uncertainty, but due to sun glint can only be '\n                                'used at night. MODIS L2P SST data have a 1 km '\n                                'spatial resolution at nadir and are stored in '\n                                '288 five minute granules per day. Full global '\n                                'coverage is obtained every two days, with '\n                                'coverage poleward of 32.3 degree being '\n                                'complete each day.  The production of MODIS '\n                                'L2P SST files is part of the Group for High '\n                                'Resolution Sea Surface Temperature (GHRSST) '\n                                'project and is a joint collaboration between '\n                                'the NASA Jet Propulsion Laboratory (JPL), the '\n                                'NASA Ocean Biology Processing Group (OBPG), '\n                                'and the Rosenstiel School of Marine and '\n                                'Atmospheric Science (RSMAS). Researchers at '\n                                'RSMAS are responsible for SST algorithm '\n                                'development, error statistics and quality '\n                                'flagging, while the OBPG, as the NASA ground '\n                                'data system, is responsible for the '\n                                'production of daily MODIS ocean products. JPL '\n                                'acquires MODIS ocean granules from the OBPG '\n                                'and reformats them to the GHRSST L2P netCDF '\n                                'specification with complete metadata and '\n                                'ancillary variables, and distributes the data '\n                                'as the official Physical Oceanography Data '\n                                'Archive (PO.DAAC) for SST.  The R2019.0 '\n                                'supersedes the previous R2014.0 datasets '\n                                'which can be found at '\n                                'https://doi.org/10.5067/GHMDA-2PJ02',\n                     'time_start': '2002-07-04T00:00:00.000Z',\n                     'title': 'GHRSST Level 2P Global Sea Surface Skin '\n                              'Temperature from the Moderate Resolution '\n                              'Imaging Spectroradiometer (MODIS) on the NASA '\n                              'Aqua satellite (GDS2)',\n                     'updated': '2019-12-02T22:59:24.849Z',\n                     'version_id': '2019.0'}],\n          'id': 'https://cmr.earthdata.nasa.gov:443/search/collections.json?concept_id=C1940473819-POCLOUD',\n          'title': 'ECHO dataset metadata',\n          'updated': '2021-11-04T00:50:26.948Z'}}\n\n\nLet’s walk through what each of these service values mean:\n\nAssociations\n\nCMR is a large web of interconnected metadata “schemas”, including Collections, Granules, Services, Tools, and Variables. In this case, this collection is associated with two unique services, two tools, and several unique variables.\n\nTags\n\nThere are also tags that describe what service options exist at a high-level. In this case, we see that this dataset supports the ability to reformat, subset by space and time, as well as by variable. This is used in web applications like Earthdata Search to surface those customization options more readily.\n\nService Features\n\nIn this case, we see three separate “features” listed here: esi, Harmony, and OPeNDAP.\n\n\nWe will dig into more details on what Harmony offers for this dataset.\nFirst, we need to isolate the services returned for this dataset:\n\nservices = response['feed']['entry'][0]['associations']['services']\nprint(services)\n\n['S1962070864-POCLOUD', 'S2004184019-POCLOUD']\n\n\ncmr_service_url = \"https://cmr.earthdata.nasa.gov/search/services\"\nInspect the first service returned. Now we’re going to search the services endpoint to view that individual service’s metadata, like we did with our dataset above.\nTODO: Explain why we need the output format in umm_json\noutput_format = \"umm_json\"\nservice_response = requests.get(f\"{cmr_service_url}.{output_format}?concept-id={services[0]}\")\n\npprint(service_response.json())\n\n{'hits': 1,\n 'items': [{'meta': {'concept-id': 'S1962070864-POCLOUD',\n                     'concept-type': 'service',\n                     'deleted': False,\n                     'format': 'application/vnd.nasa.cmr.umm+json',\n                     'native-id': 'POCLOUD_podaac_l2_cloud_subsetter',\n                     'provider-id': 'POCLOUD',\n                     'revision-date': '2021-11-02T22:57:03.597Z',\n                     'revision-id': 19,\n                     'user-id': 'podaaccloud'},\n            'umm': {'AccessConstraints': 'None',\n                    'Description': 'Endpoint for subsetting L2 Subsetter via '\n                                   'Harmony',\n                    'LongName': 'PODAAC Level 2 Cloud Subsetter',\n                    'MetadataSpecification': {'Name': 'UMM-S',\n                                              'URL': 'https://cdn.earthdata.nasa.gov/umm/service/v1.4',\n                                              'Version': '1.4'},\n                    'Name': 'PODAAC L2 Cloud Subsetter',\n                    'OperationMetadata': [{'OperationName': 'SPATIAL_SUBSETTING'},\n                                          {'OperationName': 'VARIABLE_SUBSETTING'},\n                                          {'OperationName': 'TEMPORAL_SUBSETTING'}],\n                    'ServiceKeywords': [{'ServiceCategory': 'EARTH SCIENCE '\n                                                            'SERVICES',\n                                         'ServiceTerm': 'SUBSETTING/SUPERSETTING',\n                                         'ServiceTopic': 'DATA MANAGEMENT/DATA '\n                                                         'HANDLING'}],\n                    'ServiceOptions': {'Subset': {'SpatialSubset': {'BoundingBox': {'AllowMultipleValues': False}},\n                                                  'TemporalSubset': {'AllowMultipleValues': False},\n                                                  'VariableSubset': {'AllowMultipleValues': True}},\n                                       'SupportedReformattings': [{'SupportedInputFormat': 'HDF5',\n                                                                   'SupportedOutputFormats': ['NETCDF-4']},\n                                                                  {'SupportedInputFormat': 'NETCDF-4',\n                                                                   'SupportedOutputFormats': ['NETCDF-4']}]},\n                    'ServiceOrganizations': [{'LongName': 'Physical '\n                                                          'Oceanography '\n                                                          'Distributed Active '\n                                                          'Archive Center, Jet '\n                                                          'Propulsion '\n                                                          'Laboratory, NASA',\n                                              'Roles': ['ORIGINATOR'],\n                                              'ShortName': 'NASA/JPL/PODAAC'}],\n                    'Type': 'Harmony',\n                    'URL': {'Description': 'PROJECT HOME PAGE',\n                            'URLValue': 'https://harmony.earthdata.nasa.gov'},\n                    'Version': '1.1.0'}}],\n 'took': 14}\n\n\nTODO: Describe these different service options and broader Harmony / backend subsetter context."
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#discover-variable-names",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#discover-variable-names",
    "title": "",
    "section": "Discover variable names",
    "text": "TODO: Could this be an “exercise” to gain more familiarity with CMR?\n\nvariables = response['feed']['entry'][0]['associations']['variables']\nprint(variables)\n\n['V1997812737-POCLOUD', 'V1997812697-POCLOUD', 'V2112014688-POCLOUD', 'V1997812756-POCLOUD', 'V1997812688-POCLOUD', 'V1997812670-POCLOUD', 'V1997812724-POCLOUD', 'V2112014684-POCLOUD', 'V1997812701-POCLOUD', 'V1997812681-POCLOUD', 'V2112014686-POCLOUD', 'V1997812663-POCLOUD', 'V1997812676-POCLOUD', 'V1997812744-POCLOUD', 'V1997812714-POCLOUD']\n\n\ncmr_var_url = \"https://cmr.earthdata.nasa.gov/search/variables\"\nvar_response = requests.get(f\"{cmr_var_url}.{output_format}?concept-id={variables[0]}\")\n\npprint(var_response.json())\n\n{'hits': 1,\n 'items': [{'associations': {'collections': [{'concept-id': 'C1940473819-POCLOUD'}]},\n            'meta': {'concept-id': 'V1997812737-POCLOUD',\n                     'concept-type': 'variable',\n                     'deleted': False,\n                     'format': 'application/vnd.nasa.cmr.umm+json',\n                     'native-id': 'MODIS_A-JPL-L2P-v2019.0-sses_standard_deviation_4um',\n                     'provider-id': 'POCLOUD',\n                     'revision-date': '2021-10-19T02:26:51.560Z',\n                     'revision-id': 6,\n                     'user-id': 'jmcnelis'},\n            'umm': {'DataType': 'byte',\n                    'Definition': 'mid-IR SST standard deviation error; non '\n                                  'L2P core field; signed byte array:  WARNING '\n                                  'Some applications are unable to properly '\n                                  'handle signed byte values. If values are '\n                                  'encountered > 127, please subtract 256 from '\n                                  'this reported value',\n                    'Dimensions': [{'Name': 'time',\n                                    'Size': 1,\n                                    'Type': 'TIME_DIMENSION'},\n                                   {'Name': 'nj',\n                                    'Size': 2030,\n                                    'Type': 'ALONG_TRACK_DIMENSION'},\n                                   {'Name': 'ni',\n                                    'Size': 1354,\n                                    'Type': 'CROSS_TRACK_DIMENSION'}],\n                    'FillValues': [{'Type': 'SCIENCE_FILLVALUE',\n                                    'Value': -128}],\n                    'LongName': 'SSES standard deviation error based on '\n                                'proximity confidence flags',\n                    'Name': 'sses_standard_deviation_4um',\n                    'Offset': 10.0,\n                    'Scale': 0.07874016,\n                    'Sets': [{'Index': 1,\n                              'Name': 'sses_standard_deviation_4um',\n                              'Size': 1,\n                              'Type': 'General'}],\n                    'Units': 'kelvin',\n                    'ValidRanges': [{'Max': 127, 'Min': -127}],\n                    'VariableType': 'ANCILLARY_VARIABLE'}}],\n 'took': 14}\n\n\nLet’s print out a simple list of all associated variable names.\nvar_list = []\nfor i in range(len(variables)):\n    response = requests.get(f\"{cmr_var_url}.{output_format}?concept-id={variables[i]}\")\n    response = response.json()\n    var_list.append(response['items'][0]['umm']['Name'])\n\npprint(var_list)\n\n['sses_standard_deviation_4um',\n 'l2p_flags',\n 'time',\n 'dt_analysis',\n 'sses_standard_deviation',\n 'sst_dtime',\n 'sses_bias_4um',\n 'lat',\n 'sea_surface_temperature_4um',\n 'sses_bias',\n 'lon',\n 'sea_surface_temperature',\n 'quality_level',\n 'wind_speed',\n 'quality_level_4um']"
  },
  {
    "objectID": "tutorials/07_Data_Access_Harmony_Subsetting.html#harmony-py-set-up",
    "href": "tutorials/07_Data_Access_Harmony_Subsetting.html#harmony-py-set-up",
    "title": "",
    "section": "Harmony-Py set up",
    "text": "[TODO] Describe Harmony-Py in more detail (connection between the library and the API).\nNext steps adopted from the intro tutorial notebook in the Harmony-Py library: https://github.com/nasa/harmony-py/blob/main/examples/intro_tutorial.ipynb\n\nCreate Harmony Client object\nFirst, we need to create a Harmony Client, which is what we will interact with to submit and inspect a data request to Harmony, as well as to retrieve results.\nWhen creating the Client, we need to provide Earthdata Login credentials, which are required to access data from NASA EOSDIS. This basic line below assumes that we have a .netrc available.\nharmony_client = Client()\n\n\nCreate Harmony Request\nThe following are common request parameters:\n\ncollection: Required parameter. This is the NASA EOSDIS collection, or data product. There are two options for inputting a collection of interest:\n\nProvide a concept ID, which is an ID provided in the Common Metadata Repository (CMR) metadata\nData product short name (e.g. SENTINEL-1_INTERFEROGRAMS).\n\nspatial: Bounding box spatial constraints on the data. The Harmony Bbox class accepts spatial coordinates as decimal degrees in w, s, e, n order, where longitude = -180, 180 and latitude = -90, 90.\ntemporal: Date/time constraints on the data. The example below demonstrates temporal start and end ranges using the python datetime library.\n\nOther advanced parameters that may be of interest. Note that many reformatting or advanced projection options may not be available for your requested dataset. See the documentation for details on how to construct these parameters.\n[TODO] Describe area/time use case with this dataset - maybe demonstrating Earthdata Search for browsing??\nrequest = Request(\n    collection=Collection(id=short_name),\n    spatial=BBox(60,-45.75,90,-45), # bounding box example that can be used as an alternative to shapefile input\n    temporal={\n        'start': dt.datetime(2021, 11, 1),\n        'stop': dt.datetime(2021, 11, 2),\n    },\n    # variables=variables,\n)\n\n\nCheck Request validity\nBefore submitting a Harmony Request, we can test your request to see if it’s valid and how to fix it if not. In particular, request.is_valid will check to ensure that the spatial BBox bounds and temporal ranges are entered correctly.\n\nrequest.is_valid()\n\nTrue\n\n\n\n\nSubmit request\nNow that the request is created, we can now submit it to Harmony using the Harmony Client object. A job id is returned, which is a unique identifier that represents the submitted request.\n\njob_id = harmony_client.submit(request)\njob_id\n\n'9e0cb72b-9662-4b2e-9828-bc85a024b93d'\n\n\n\n\nCheck request status\nWe can check on the progress of a processing job with status(). This method blocks while communicating with the server but returns quickly.\n\nharmony_client.status(job_id)\n\n{'status': 'running',\n 'message': 'There were 2 collections that matched the provided short name MODIS_A-JPL-L2P-v2019.0. See https://cmr.earthdata.nasa.gov/concepts/C1940473819-POCLOUD for details on the selected collection. The version ID for the selected collection is 2019.0. To use a different collection submit a new request specifying the desired CMR concept ID instead of the collection short name.',\n 'progress': 0,\n 'created_at': datetime.datetime(2021, 11, 4, 0, 50, 34, 333000, tzinfo=tzlocal()),\n 'updated_at': datetime.datetime(2021, 11, 4, 0, 50, 34, 333000, tzinfo=tzlocal()),\n 'request': 'https://harmony.earthdata.nasa.gov/MODIS_A-JPL-L2P-v2019.0/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?forceAsync=true&subset=lat(-45.75%3A-45)&subset=lon(60%3A90)&subset=time(%222021-11-01T00%3A00%3A00%22%3A%222021-11-02T00%3A00%3A00%22)',\n 'num_input_granules': 7}\n\n\nDepending on the size of the request, it may be helpful to wait until the request has completed processing before the remainder of the code is executed. The wait_for_processing() method will block subsequent lines of code while optionally showing a progress bar.\n\nharmony_client.wait_for_processing(job_id, show_progress=True)\n\n [ Processing: 100% ] |###################################################| [|]\n\n\n\n\nView Harmony job response and output URLs\nOnce the data request has finished processing, we can view details on the job that was submitted to Harmony, including the API call to Harmony, and informational messages on the request if available.\nresult_json() calls wait_for_processing() and returns the complete job in JSON format once processing is complete.\n\ndata = harmony_client.result_json(job_id)\npprint(data)\n\n{'createdAt': '2021-11-04T00:50:34.333Z',\n 'jobID': '9e0cb72b-9662-4b2e-9828-bc85a024b93d',\n 'links': [{'href': 'https://harmony.earthdata.nasa.gov/stac/9e0cb72b-9662-4b2e-9828-bc85a024b93d/',\n            'rel': 'stac-catalog-json',\n            'title': 'STAC catalog',\n            'type': 'application/json'},\n           {'bbox': [66.801, -66.443, 113.49, -44.231],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101083501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T08:39:58.000Z',\n                         'start': '2021-11-01T08:35:01.000Z'},\n            'title': '20211101083501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [66.7, -45.7, 90, -45],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101084001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T08:44:58.000Z',\n                         'start': '2021-11-01T08:40:01.000Z'},\n            'title': '20211101084001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [60, -45.7, 73.9, -45],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101101501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T10:19:58.000Z',\n                         'start': '2021-11-01T10:15:01.000Z'},\n            'title': '20211101101501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [88.05, -48.131, 120.198, -26.81],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101180501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T18:09:58.000Z',\n                         'start': '2021-11-01T18:05:01.000Z'},\n            'title': '20211101180501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [86.7, -45.7, 90, -45],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101181001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T18:14:58.000Z',\n                         'start': '2021-11-01T18:10:01.000Z'},\n            'title': '20211101181001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [61.9, -45.7, 90, -45],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101194501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T19:49:58.000Z',\n                         'start': '2021-11-01T19:45:01.000Z'},\n            'title': '20211101194501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [60, -45.7, 69.2, -45],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101212501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-11-01T21:29:58.000Z',\n                         'start': '2021-11-01T21:25:01.000Z'},\n            'title': '20211101212501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'href': 'https://harmony.earthdata.nasa.gov/jobs/9e0cb72b-9662-4b2e-9828-bc85a024b93d?linktype=https&page=1&limit=2000',\n            'rel': 'self',\n            'title': 'The current page',\n            'type': 'application/json'}],\n 'message': 'There were 2 collections that matched the provided short name '\n            'MODIS_A-JPL-L2P-v2019.0. See '\n            'https://cmr.earthdata.nasa.gov/concepts/C1940473819-POCLOUD for '\n            'details on the selected collection. The version ID for the '\n            'selected collection is 2019.0. To use a different collection '\n            'submit a new request specifying the desired CMR concept ID '\n            'instead of the collection short name.',\n 'numInputGranules': 7,\n 'progress': 100,\n 'request': 'https://harmony.earthdata.nasa.gov/MODIS_A-JPL-L2P-v2019.0/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?forceAsync=true&subset=lat(-45.75%3A-45)&subset=lon(60%3A90)&subset=time(%222021-11-01T00%3A00%3A00%22%3A%222021-11-02T00%3A00%3A00%22)',\n 'status': 'successful',\n 'updatedAt': '2021-11-04T00:51:11.841Z',\n 'username': 'amy.steiker'}\n\n\n\n\nDirect cloud access\nNote that the remainder of this tutorial will only succeed when running this notebook within the AWS us-west-2 region.\nHarmony data outputs can be accessed within the cloud using the s3 URLs and AWS credentials provided in the Harmony job response.\n\nRetrieve list of output URLs.\nThe result_urls() method calls wait_for_processing() and returns a list of the processed data URLs once processing is complete. You may optionally show the progress bar as shown below.\n\nresults = harmony_client.result_urls(job_id, link_type=LinkType.s3)\nurls = list(results)\npprint(urls)\n\n['s3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101083501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101084001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101101501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101180501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101181001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101194501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101212501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4']\n\n\nWe can see that the first file returned does not include the _subsetted suffix, which indicates that a blank file was returned, as no data values were located within our subsetted region. We’ll select the second URL in the list to bring into xarray below.\n\nurl = urls[1]\nurl\n\n's3://harmony-prod-staging/public/podaac/l2-subsetter/28b897a7-7349-4e1b-8141-2a06290c196f/20211101084001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4'\n\n\n\n\nAWS credential retrieval\nUsing aws_credentials you can retrieve the credentials needed to access the Harmony s3 staging bucket and its contents.\ncreds = harmony_client.aws_credentials()\n\n\n\nOpen staged files with s3fs and xarray\nWe use the AWS s3fs package to create a file system that can then be read by xarray:\nnetcdf_fs = s3fs.S3FileSystem(\n    key=creds['aws_access_key_id'],\n    secret=creds['aws_secret_access_key'],\n    token=creds['aws_session_token'],\n    client_kwargs={'region_name':'us-west-2'},\n)\n\n\n**Note, Ideally, we’d show how to bring in all files into a single xarray ds but I’m getting an error:\n# # Iterate through remote_files to create a fileset\n# fileset = [netcdf_fs.open(file) for file in urls]\n# fileset\n# ds = xr.open_mfdataset(fileset)\nNow that we have our s3 file system set, including our declared credentials, we’ll use that to open the url, and read in the file through xarray:\n\nwith netcdf_fs.open(url) as f:\n        ds= xr.open_dataset(f)\n        display(ds)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:                  (nj: 366, ni: 1154, time: 1)\nCoordinates:\n    lat                      (nj, ni, time) float32 ...\n    lon                      (nj, ni, time) float32 ...\n  * time                     (time) datetime64[ns] 2021-11-01T08:40:01\nDimensions without coordinates: nj, ni\nData variables:\n    sea_surface_temperature  (time, nj, ni) float32 ...\n    sst_dtime                (time, nj, ni) timedelta64[ns] ...\n    quality_level            (time, nj, ni) float32 ...\n    sses_bias                (time, nj, ni) float32 ...\n    sses_standard_deviation  (time, nj, ni) float32 ...\n    l2p_flags                (time, nj, ni) int16 ...\n    chlorophyll_a            (time, nj, ni) float32 ...\n    K_490                    (time, nj, ni) float32 ...\n    wind_speed               (time, nj, ni) float32 ...\n    dt_analysis              (time, nj, ni) float32 ...\nAttributes: (12/50)\n    Conventions:                CF-1.7, ACDD-1.3\n    title:                      MODIS Aqua L2P SST\n    summary:                    Sea surface temperature retrievals produced a...\n    references:                 GHRSST Data Processing Specification v2r5\n    institution:                NASA/JPL/OBPG/RSMAS\n    history:                    MODIS L2P created at JPL PO.DAAC\\n2021-11-04 ...\n    ...                         ...\n    processing_level:           L2P\n    cdm_data_type:              swath\n    startDirection:             Ascending\n    endDirection:               Ascending\n    day_night_flag:             Day\n    history_json:               [{\"date_time\": \"2021-11-04T00:50:49.990002+00...xarray.DatasetDimensions:nj: 366ni: 1154time: 1Coordinates: (3)lat(nj, ni, time)float32...long_name :latitudestandard_name :latitudeunits :degrees_northvalid_min :[-90.]valid_max :[90.]comment :geographical coordinates, WGS84 projectioncoverage_content_type :coordinate[422364 values with dtype=float32]lon(nj, ni, time)float32...long_name :longitudestandard_name :longitudeunits :degrees_eastvalid_min :[-180.]valid_max :[180.]comment :geographical coordinates, WGS84 projectioncoverage_content_type :coordinate[422364 values with dtype=float32]time(time)datetime64[ns]2021-11-01T08:40:01long_name :reference time of sst filestandard_name :timecomment :time of first sensor observationcoverage_content_type :coordinatearray(['2021-11-01T08:40:01.000000000'], dtype='datetime64[ns]')Data variables: (10)sea_surface_temperature(time, nj, ni)float32...long_name :sea surface temperaturestandard_name :sea_surface_skin_temperatureunits :kelvinvalid_min :[-1000]valid_max :[10000]comment :sea surface temperature from thermal IR (11 um) channelssource :NASA and University of Miamicoverage_content_type :physicalMeasurement[422364 values with dtype=float32]sst_dtime(time, nj, ni)timedelta64[ns]...long_name :time difference from reference timevalid_min :[-32767]valid_max :[32767]comment :time plus sst_dtime gives seconds after 00:00:00 UTC January 1, 1981coverage_content_type :referenceInformation[422364 values with dtype=timedelta64[ns]]quality_level(time, nj, ni)float32...long_name :quality level of SST pixelvalid_min :[0]valid_max :[5]comment :thermal IR SST proximity confidence value; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valueflag_values :[0 1 2 3 4 5]flag_meanings :no_data bad_data worst_quality low_quality acceptable_quality best_qualitycoverage_content_type :qualityInformation[422364 values with dtype=float32]sses_bias(time, nj, ni)float32...long_name :SSES bias error based on proximity confidence flagsunits :kelvinvalid_min :[-127]valid_max :[127]comment :thermal IR SST bias error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valuecoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]sses_standard_deviation(time, nj, ni)float32...long_name :SSES standard deviation error based on proximity confidence flagsunits :kelvinvalid_min :[-127]valid_max :[127]comment :thermal IR SST standard deviation error; signed byte array: WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported valuecoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]l2p_flags(time, nj, ni)int16...long_name :L2P flagsvalid_min :[0]valid_max :[16]comment :These flags can be used to further filter data variablesflag_meanings :microwave land ice lake riverflag_masks :[ 1  2  4  8 16]coverage_content_type :qualityInformation[422364 values with dtype=int16]chlorophyll_a(time, nj, ni)float32...long_name :Chlorophyll Concentration, OC3 Algorithmunits :mg m^-3valid_min :[0.001]valid_max :[100.]comment :non L2P core fieldcoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]K_490(time, nj, ni)float32...long_name :Diffuse attenuation coefficient at 490 nm (OBPG)units :m^-1valid_min :[50]valid_max :[30000]comment :non L2P core fieldcoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]wind_speed(time, nj, ni)float32...long_name :10m wind speedstandard_name :wind_speedunits :m s-1valid_min :[-127]valid_max :[127]comment :Wind at 10 meters above the sea surfacesource :TBD.  Placeholder.  Currently emptygrid_mapping :TBDtime_offset :[2.]height :10 mcoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]dt_analysis(time, nj, ni)float32...long_name :deviation from SST reference climatologyunits :kelvinvalid_min :[-127]valid_max :[127]comment :TBDsource :TBD. Placeholder.  Currently emptycoverage_content_type :auxiliaryInformation[422364 values with dtype=float32]Attributes: (50)Conventions :CF-1.7, ACDD-1.3title :MODIS Aqua L2P SSTsummary :Sea surface temperature retrievals produced at the NASA OBPG for the MODIS Aqua sensor.  These have been reformatted to GHRSST GDS specifications by the JPL PO.DAACreferences :GHRSST Data Processing Specification v2r5institution :NASA/JPL/OBPG/RSMAShistory :MODIS L2P created at JPL PO.DAAC\n2021-11-04 00:50:49.989964 l2ss-py v1.1.0 (bbox=[[60.0, 90.0], [-45.75, -45.0]] cut=True)comment :L2P Core without DT analysis or other ancillary fields; Day, Start Node:Ascending, End Node:Ascending; WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value; Quicklooklicense :GHRSST and PO.DAAC protocol allow data use as free and open.id :MODIS_A-JPL-L2P-v2019.0naming_authority :org.ghrsstproduct_version :2019.0uuid :f6e1f61d-c4a4-4c17-8354-0c15e12d688bgds_version_id :2.0netcdf_version_id :4.1date_created :20211101T110613Zfile_quality_level :[3]spatial_resolution :1kmstart_time :20211101T084001Ztime_coverage_start :20211101T084001Zstop_time :20211101T084458Ztime_coverage_end :20211101T084458Znorthernmost_latitude :[-27.3202]southernmost_latitude :[-48.6134]easternmost_longitude :[97.5941]westernmost_longitude :[65.1593]source :MODIS sea surface temperature observations for the OBPGplatform :Aquasensor :MODISmetadata_link :http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MODIS_A-JPL-L2P-v2019.0keywords :Oceans > Ocean Temperature > Sea Surface Temperaturekeywords_vocabulary :NASA Global Change Master Directory (GCMD) Science Keywordsstandard_name_vocabulary :NetCDF Climate and Forecast (CF) Metadata Conventiongeospatial_lat_units :degrees_northgeospatial_lat_resolution :[0.01]geospatial_lon_units :degrees_eastgeospatial_lon_resolution :[0.01]acknowledgment :The MODIS L2P sea surface temperature data are sponsored by NASAcreator_name :Ed Armstrong, JPL PO.DAACcreator_email :edward.m.armstrong@jpl.nasa.govcreator_url :http://podaac.jpl.nasa.govproject :Group for High Resolution Sea Surface Temperaturepublisher_name :The GHRSST Project Officepublisher_url :http://www.ghrsst.orgpublisher_email :ghrsst-po@nceo.ac.ukprocessing_level :L2Pcdm_data_type :swathstartDirection :AscendingendDirection :Ascendingday_night_flag :Dayhistory_json :[{\"date_time\": \"2021-11-04T00:50:49.990002+00:00\", \"derived_from\": \"https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MODIS_A-JPL-L2P-v2019.0/20211101084001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0.nc\", \"program\": \"l2ss-py\", \"version\": \"1.1.0\", \"parameters\": \"bbox=[[60.0, 90.0], [-45.75, -45.0]] cut=True\", \"program_ref\": \"https://cmr.earthdata.nasa.gov:443/search/concepts/S1962070864-POCLOUD\", \"$schema\": \"https://harmony.earthdata.nasa.gov/schemas/history/0.1.0/history-v0.1.0.json\"}]\n\n\n\n\nPlot the data\n# # Determine the lat/lon coordinate names\n# for coord_name, coord in ds.coords.items():\n#     if 'units' not in coord.attrs:\n#         continue\n#     if coord.attrs['units'] == 'degrees_north':\n#         lat_var = coord_name\n#     if coord.attrs['units'] == 'degrees_east':\n#         lon_var = coord_name\n\n# print(f'lat_var={lat_var}')\n# print(f'lon_var={lon_var}')\n\n# # if ds[variable].size == 0:\n# #     print(\"No data in subsetted region. Exiting\")\n# #     sys.exit(0)\n    \n# import matplotlib.pyplot as plt\n# import math\n\n# fig, axes = plt.subplots(ncols=3, nrows=math.ceil((len(ds.data_vars)/3)))\n# fig.set_size_inches((15,15))\n\n# for count, xvar in enumerate(ds.data_vars):\n#     if  ds[xvar].dtype == \"timedelta64[ns]\":\n#         continue\n#         #ds[xvar].astype('timedelta64[D]').plot(ax=axes[int(count/3)][count%3])\n#     ds[xvar].plot(ax=axes[int(count/3)][count%3])\n\n\nExtra code attempting to read in directly from s3 into xarray:\n# netcdf_stores = [netcdf_fs.get_mapper(root=u, check=False) for u in urls]\n# netcdf_stores\n\n# xr.open_mfdataset(netcdf_stores)"
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "title": "",
    "section": "Using the Harmony-Py library to access customized data from NASA Earthdata",
    "text": ""
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#summary",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Harmony allows you to seamlessly analyze Earth observation data from different NASA data centers… https://harmony.earthdata.nasa.gov/\n\nBenefits\n\nConsistent access patterns to EOSDIS holdings make cross-data center data access easier\nData reduction services allow users to request only the data they want, in the format and projection they want\nAnalysis Ready Data and cloud access will help reduce time-to-science\nCommunity Development helps reduce the barriers for re-use of code and sharing of domain knowledge\n\nHarmony-Py is a Python library for integrating with NASA’s Harmony Services.\nHarmony-Py provides a Python alternative to directly using Harmony’s RESTful API. It handles NASA Earthdata Login (EDL) authentication and optionally integrates with the CMR Python Wrapper by accepting collection results as a request parameter. It’s convenient for scientists who wish to use Harmony from Jupyter notebooks as well as machine-to-machine communication with larger Python applications.\n\n\nObjectives\n\nPractice skills learned from intro to CMR tutorial to discover what access and service options exist for a given data set"
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#import-packages",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#import-packages",
    "title": "",
    "section": "Import Packages",
    "text": "from harmony import BBox, Client, Collection, Request, LinkType\nfrom harmony.config import Environment\nimport requests\nfrom pprint import pprint\nimport datetime as dt\nimport s3fs\nimport xarray as xr"
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "title": "",
    "section": "Discover service options for a given data set",
    "text": "First, what do we mean by a “service”? [TODO] Describe how we define services and their benefits, and how not all datasets have services on them due to level of support, etc….\nLet’s see what the collection metadata tells us\n\nBuilding off of CMR introduction tutorial:\ncmr_search_url = 'https://cmr.earthdata.nasa.gov/search'\nWe want to search by collection to inspect the access and service options that exist:\ncmr_collection_url = f'{cmr_search_url}/{\"collections\"}'\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given data set id (also referred to as a short_name).\nHere we are jumping ahead and already know the concept_id we are interested in, by browsing cloud-hosted datasets from PO.DAAC in Earthdata Search: https://search.earthdata.nasa.gov/portal/podaac-cloud/search.\nWe are going to focus on MODIS_A-JPL-L2P-v2019.0: GHRSST Level 2P Global Sea Surface Skin Temperature from the Moderate Resolution Imaging Spectroradiometer (MODIS) on the NASA Aqua satellite (GDS2). Let’s first save this as a variable that we can use later on once we request data from Harmony.\nshort_name= 'MODIS_A-JPL-L2P-v2019.0'\nconcept_id = 'C1940473819-POCLOUD'\nWe will view the top-level metadata for this collection to see what additional service and variable metadata exist.\nresponse = requests.get(cmr_collection_url, \n                        params={\n                            'concept_id': concept_id,\n                            },\n                        headers={\n                            'Accept': 'application/json'\n                            }\n                       )\nresponse = response.json()\nPrint the response:\n\npprint(response)\n\n{'feed': {'entry': [{'archive_center': 'NASA/JPL/PODAAC',\n                     'associations': {'services': ['S1962070864-POCLOUD',\n                                                   'S2004184019-POCLOUD'],\n                                      'tools': ['TL2108419875-POCLOUD',\n                                                'TL2092786348-POCLOUD'],\n                                      'variables': ['V1997812737-POCLOUD',\n                                                    'V1997812697-POCLOUD',\n                                                    'V2112014688-POCLOUD',\n                                                    'V1997812756-POCLOUD',\n                                                    'V1997812688-POCLOUD',\n                                                    'V1997812670-POCLOUD',\n                                                    'V1997812724-POCLOUD',\n                                                    'V2112014684-POCLOUD',\n                                                    'V1997812701-POCLOUD',\n                                                    'V1997812681-POCLOUD',\n                                                    'V2112014686-POCLOUD',\n                                                    'V1997812663-POCLOUD',\n                                                    'V1997812676-POCLOUD',\n                                                    'V1997812744-POCLOUD',\n                                                    'V1997812714-POCLOUD']},\n                     'boxes': ['-90 -180 90 180'],\n                     'browse_flag': True,\n                     'collection_data_type': 'SCIENCE_QUALITY',\n                     'coordinate_system': 'CARTESIAN',\n                     'data_center': 'POCLOUD',\n                     'dataset_id': 'GHRSST Level 2P Global Sea Surface Skin '\n                                   'Temperature from the Moderate Resolution '\n                                   'Imaging Spectroradiometer (MODIS) on the '\n                                   'NASA Aqua satellite (GDS2)',\n                     'has_formats': True,\n                     'has_spatial_subsetting': True,\n                     'has_temporal_subsetting': True,\n                     'has_transforms': False,\n                     'has_variables': True,\n                     'id': 'C1940473819-POCLOUD',\n                     'links': [{'href': 'https://podaac.jpl.nasa.gov/Podaac/thumbnails/MODIS_A-JPL-L2P-v2019.0.jpg',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/browse#'},\n                               {'href': 'https://github.com/podaac/data-readers',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac-tools.jpl.nasa.gov/drive/files/OceanTemperature/ghrsst/docs/GDS20r5.pdf',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://ghrsst.jpl.nasa.gov',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/flag/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/reprocessing/r2019/sst/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst4/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://modis.gsfc.nasa.gov/data/atbd/atbd_mod25.pdf',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://oceancolor.gsfc.nasa.gov/atbd/sst/',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'http://www.ghrsst.org',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac.jpl.nasa.gov/forum/viewforum.php?f=18&sid=e2d67e5a01815fc6e39fcd2087ed8bc8',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://podaac.jpl.nasa.gov/CitingPODAAC',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://cmr.earthdata.nasa.gov/virtual-directory/collections/C1940473819-POCLOUD',\n                                'hreflang': 'en-US',\n                                'length': '75.0MB',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'},\n                               {'href': 'https://github.com/podaac/tutorials/blob/master/notebooks/MODIS_L2P_SST_DataCube.ipynb',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/documentation#'},\n                               {'href': 'https://search.earthdata.nasa.gov/search/granules?p=C1940473819-POCLOUD',\n                                'hreflang': 'en-US',\n                                'rel': 'http://esipfed.org/ns/fedsearch/1.1/data#'}],\n                     'online_access_flag': True,\n                     'orbit_parameters': {'inclination_angle': '98.1',\n                                          'number_of_orbits': '1.0',\n                                          'period': '98.4',\n                                          'swath_width': '2330.0'},\n                     'organizations': ['NASA/JPL/PODAAC'],\n                     'original_format': 'UMM_JSON',\n                     'platforms': ['Aqua'],\n                     'processing_level_id': '2',\n                     'service_features': {'esi': {'has_formats': False,\n                                                  'has_spatial_subsetting': False,\n                                                  'has_temporal_subsetting': False,\n                                                  'has_transforms': False,\n                                                  'has_variables': False},\n                                          'harmony': {'has_formats': True,\n                                                      'has_spatial_subsetting': True,\n                                                      'has_temporal_subsetting': True,\n                                                      'has_transforms': False,\n                                                      'has_variables': True},\n                                          'opendap': {'has_formats': True,\n                                                      'has_spatial_subsetting': True,\n                                                      'has_temporal_subsetting': True,\n                                                      'has_transforms': False,\n                                                      'has_variables': True}},\n                     'short_name': 'MODIS_A-JPL-L2P-v2019.0',\n                     'summary': 'NASA produces skin sea surface temperature '\n                                '(SST) products from the Infrared (IR) '\n                                'channels of the Moderate-resolution Imaging '\n                                'Spectroradiometer (MODIS) onboard the Aqua '\n                                'satellite. Aqua was launched by NASA on May '\n                                '4, 2002, into a sun synchronous, polar orbit '\n                                'with a daylight ascending node at 1:30 pm, '\n                                'formation flying in the A-train with other '\n                                'Earth Observation Satellites (EOS), to study '\n                                'the global dynamics of the Earth atmosphere, '\n                                'land and oceans. MODIS captures data in 36 '\n                                'spectral bands at a variety of spatial '\n                                'resolutions.  Two SST products can be present '\n                                'in these files. The first is a skin SST '\n                                'produced for both day and night (NSST) '\n                                'observations, derived from the long wave IR '\n                                '11 and 12 micron wavelength channels, using a '\n                                'modified nonlinear SST algorithm intended to '\n                                'provide continuity of SST derived from '\n                                'heritage and current NASA sensors. At night, '\n                                'a second SST product is generated using the '\n                                'mid-infrared 3.95 and 4.05 micron  wavelength '\n                                'channels which are unique to MODIS; the SST '\n                                'derived from these measurements is identified '\n                                'as SST4. The SST4 product has lower '\n                                'uncertainty, but due to sun glint can only be '\n                                'used at night. MODIS L2P SST data have a 1 km '\n                                'spatial resolution at nadir and are stored in '\n                                '288 five minute granules per day. Full global '\n                                'coverage is obtained every two days, with '\n                                'coverage poleward of 32.3 degree being '\n                                'complete each day.  The production of MODIS '\n                                'L2P SST files is part of the Group for High '\n                                'Resolution Sea Surface Temperature (GHRSST) '\n                                'project and is a joint collaboration between '\n                                'the NASA Jet Propulsion Laboratory (JPL), the '\n                                'NASA Ocean Biology Processing Group (OBPG), '\n                                'and the Rosenstiel School of Marine and '\n                                'Atmospheric Science (RSMAS). Researchers at '\n                                'RSMAS are responsible for SST algorithm '\n                                'development, error statistics and quality '\n                                'flagging, while the OBPG, as the NASA ground '\n                                'data system, is responsible for the '\n                                'production of daily MODIS ocean products. JPL '\n                                'acquires MODIS ocean granules from the OBPG '\n                                'and reformats them to the GHRSST L2P netCDF '\n                                'specification with complete metadata and '\n                                'ancillary variables, and distributes the data '\n                                'as the official Physical Oceanography Data '\n                                'Archive (PO.DAAC) for SST.  The R2019.0 '\n                                'supersedes the previous R2014.0 datasets '\n                                'which can be found at '\n                                'https://doi.org/10.5067/GHMDA-2PJ02',\n                     'time_start': '2002-07-04T00:00:00.000Z',\n                     'title': 'GHRSST Level 2P Global Sea Surface Skin '\n                              'Temperature from the Moderate Resolution '\n                              'Imaging Spectroradiometer (MODIS) on the NASA '\n                              'Aqua satellite (GDS2)',\n                     'updated': '2019-12-02T22:59:24.849Z',\n                     'version_id': '2019.0'}],\n          'id': 'https://cmr.earthdata.nasa.gov:443/search/collections.json?concept_id=C1940473819-POCLOUD',\n          'title': 'ECHO dataset metadata',\n          'updated': '2021-11-11T04:20:20.527Z'}}\n\n\nLet’s walk through what each of these service values mean:\n\nAssociations\n\nCMR is a large web of interconnected metadata “schemas”, including Collections, Granules, Services, Tools, and Variables. In this case, this collection is associated with two unique services, two tools, and several unique variables.\n\nTags\n\nThere are also tags that describe what service options exist at a high-level. In this case, we see that this dataset supports the ability to reformat, subset by space and time, as well as by variable. This is used in web applications like Earthdata Search to surface those customization options more readily.\n\nService Features\n\nIn this case, we see three separate “features” listed here: esi, Harmony, and OPeNDAP.\n\n\nWe will dig into more details on what Harmony offers for this dataset.\nFirst, we need to isolate the services returned for this dataset:\n\nservices = response['feed']['entry'][0]['associations']['services']\nprint(services)\n\n['S1962070864-POCLOUD', 'S2004184019-POCLOUD']\n\n\ncmr_service_url = \"https://cmr.earthdata.nasa.gov/search/services\"\nInspect the first service returned. Now we’re going to search the services endpoint to view that individual service’s metadata, like we did with our dataset above.\nTODO: Explain why we need the output format in umm_json\noutput_format = \"umm_json\"\nservice_response = requests.get(f\"{cmr_service_url}.{output_format}?concept-id={services[0]}\")\n\npprint(service_response.json())\n\n{'hits': 1,\n 'items': [{'meta': {'concept-id': 'S1962070864-POCLOUD',\n                     'concept-type': 'service',\n                     'deleted': False,\n                     'format': 'application/vnd.nasa.cmr.umm+json',\n                     'native-id': 'POCLOUD_podaac_l2_cloud_subsetter',\n                     'provider-id': 'POCLOUD',\n                     'revision-date': '2021-11-02T22:57:03.597Z',\n                     'revision-id': 19,\n                     'user-id': 'podaaccloud'},\n            'umm': {'AccessConstraints': 'None',\n                    'Description': 'Endpoint for subsetting L2 Subsetter via '\n                                   'Harmony',\n                    'LongName': 'PODAAC Level 2 Cloud Subsetter',\n                    'MetadataSpecification': {'Name': 'UMM-S',\n                                              'URL': 'https://cdn.earthdata.nasa.gov/umm/service/v1.4',\n                                              'Version': '1.4'},\n                    'Name': 'PODAAC L2 Cloud Subsetter',\n                    'OperationMetadata': [{'OperationName': 'SPATIAL_SUBSETTING'},\n                                          {'OperationName': 'VARIABLE_SUBSETTING'},\n                                          {'OperationName': 'TEMPORAL_SUBSETTING'}],\n                    'ServiceKeywords': [{'ServiceCategory': 'EARTH SCIENCE '\n                                                            'SERVICES',\n                                         'ServiceTerm': 'SUBSETTING/SUPERSETTING',\n                                         'ServiceTopic': 'DATA MANAGEMENT/DATA '\n                                                         'HANDLING'}],\n                    'ServiceOptions': {'Subset': {'SpatialSubset': {'BoundingBox': {'AllowMultipleValues': False}},\n                                                  'TemporalSubset': {'AllowMultipleValues': False},\n                                                  'VariableSubset': {'AllowMultipleValues': True}},\n                                       'SupportedReformattings': [{'SupportedInputFormat': 'HDF5',\n                                                                   'SupportedOutputFormats': ['NETCDF-4']},\n                                                                  {'SupportedInputFormat': 'NETCDF-4',\n                                                                   'SupportedOutputFormats': ['NETCDF-4']}]},\n                    'ServiceOrganizations': [{'LongName': 'Physical '\n                                                          'Oceanography '\n                                                          'Distributed Active '\n                                                          'Archive Center, Jet '\n                                                          'Propulsion '\n                                                          'Laboratory, NASA',\n                                              'Roles': ['ORIGINATOR'],\n                                              'ShortName': 'NASA/JPL/PODAAC'}],\n                    'Type': 'Harmony',\n                    'URL': {'Description': 'PROJECT HOME PAGE',\n                            'URLValue': 'https://harmony.earthdata.nasa.gov'},\n                    'Version': '1.1.0'}}],\n 'took': 21}\n\n\nTODO: Describe these different service options and broader Harmony / backend subsetter context."
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#discover-variable-names",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#discover-variable-names",
    "title": "",
    "section": "Discover variable names",
    "text": "TODO: Could this be an “exercise” to gain more familiarity with CMR?\n\nvariables = response['feed']['entry'][0]['associations']['variables']\nprint(variables)\n\n['V1997812737-POCLOUD', 'V1997812697-POCLOUD', 'V2112014688-POCLOUD', 'V1997812756-POCLOUD', 'V1997812688-POCLOUD', 'V1997812670-POCLOUD', 'V1997812724-POCLOUD', 'V2112014684-POCLOUD', 'V1997812701-POCLOUD', 'V1997812681-POCLOUD', 'V2112014686-POCLOUD', 'V1997812663-POCLOUD', 'V1997812676-POCLOUD', 'V1997812744-POCLOUD', 'V1997812714-POCLOUD']\n\n\ncmr_var_url = \"https://cmr.earthdata.nasa.gov/search/variables\"\nvar_response = requests.get(f\"{cmr_var_url}.{output_format}?concept-id={variables[0]}\")\n\npprint(var_response.json())\n\n{'hits': 1,\n 'items': [{'associations': {'collections': [{'concept-id': 'C1940473819-POCLOUD'}]},\n            'meta': {'concept-id': 'V1997812737-POCLOUD',\n                     'concept-type': 'variable',\n                     'deleted': False,\n                     'format': 'application/vnd.nasa.cmr.umm+json',\n                     'native-id': 'MODIS_A-JPL-L2P-v2019.0-sses_standard_deviation_4um',\n                     'provider-id': 'POCLOUD',\n                     'revision-date': '2021-10-19T02:26:51.560Z',\n                     'revision-id': 6,\n                     'user-id': 'jmcnelis'},\n            'umm': {'DataType': 'byte',\n                    'Definition': 'mid-IR SST standard deviation error; non '\n                                  'L2P core field; signed byte array:  WARNING '\n                                  'Some applications are unable to properly '\n                                  'handle signed byte values. If values are '\n                                  'encountered > 127, please subtract 256 from '\n                                  'this reported value',\n                    'Dimensions': [{'Name': 'time',\n                                    'Size': 1,\n                                    'Type': 'TIME_DIMENSION'},\n                                   {'Name': 'nj',\n                                    'Size': 2030,\n                                    'Type': 'ALONG_TRACK_DIMENSION'},\n                                   {'Name': 'ni',\n                                    'Size': 1354,\n                                    'Type': 'CROSS_TRACK_DIMENSION'}],\n                    'FillValues': [{'Type': 'SCIENCE_FILLVALUE',\n                                    'Value': -128}],\n                    'LongName': 'SSES standard deviation error based on '\n                                'proximity confidence flags',\n                    'Name': 'sses_standard_deviation_4um',\n                    'Offset': 10.0,\n                    'Scale': 0.07874016,\n                    'Sets': [{'Index': 1,\n                              'Name': 'sses_standard_deviation_4um',\n                              'Size': 1,\n                              'Type': 'General'}],\n                    'Units': 'kelvin',\n                    'ValidRanges': [{'Max': 127, 'Min': -127}],\n                    'VariableType': 'ANCILLARY_VARIABLE'}}],\n 'took': 109}\n\n\nLet’s print out a simple list of all associated variable names.\nvar_list = []\nfor i in range(len(variables)):\n    response = requests.get(f\"{cmr_var_url}.{output_format}?concept-id={variables[i]}\")\n    response = response.json()\n    var_list.append(response['items'][0]['umm']['Name'])\n\npprint(var_list)\n\n['sses_standard_deviation_4um',\n 'l2p_flags',\n 'time',\n 'dt_analysis',\n 'sses_standard_deviation',\n 'sst_dtime',\n 'sses_bias_4um',\n 'lat',\n 'sea_surface_temperature_4um',\n 'sses_bias',\n 'lon',\n 'sea_surface_temperature',\n 'quality_level',\n 'wind_speed',\n 'quality_level_4um']"
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#harmony-py-set-up",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#harmony-py-set-up",
    "title": "",
    "section": "Harmony-Py set up",
    "text": "[TODO] Describe Harmony-Py in more detail (connection between the library and the API).\nNext steps adopted from the intro tutorial notebook in the Harmony-Py library: https://github.com/nasa/harmony-py/blob/main/examples/intro_tutorial.ipynb\n\nCreate Harmony Client object\nFirst, we need to create a Harmony Client, which is what we will interact with to submit and inspect a data request to Harmony, as well as to retrieve results.\nWhen creating the Client, we need to provide Earthdata Login credentials, which are required to access data from NASA EOSDIS. This basic line below assumes that we have a .netrc available.\nharmony_client = Client()\n\n\nCreate Harmony Request\nThe following are common request parameters:\n\ncollection: Required parameter. This is the NASA EOSDIS collection, or data product. There are two options for inputting a collection of interest:\n\nProvide a concept ID, which is an ID provided in the Common Metadata Repository (CMR) metadata\nData product short name (e.g. SENTINEL-1_INTERFEROGRAMS).\n\nspatial: Bounding box spatial constraints on the data. The Harmony Bbox class accepts spatial coordinates as decimal degrees in w, s, e, n order, where longitude = -180, 180 and latitude = -90, 90.\ntemporal: Date/time constraints on the data. The example below demonstrates temporal start and end ranges using the python datetime library.\n\nOther advanced parameters that may be of interest. Note that many reformatting or advanced projection options may not be available for your requested dataset. See the documentation for details on how to construct these parameters.\n[TODO] Describe area/time use case with this dataset - maybe demonstrating Earthdata Search for browsing??\nWe will search over the Gulf of Mexico during the period 1 Aug 2020 to 1 Nov 2020, since we are interested in exploring how SST responds during the latest Atlantic hurricane season.\nrequest = Request(\n    collection=Collection(id=short_name),\n#    spatial=BBox(60,-45.75,90,-45), # bounding box example that can be used as an alternative to shapefile input\n    spatial=BBox(-97.77667,21.20806,-83.05197,30.16605), # bounding box example that can be used as an alternative to shapefile input\n    temporal={\n        # 'start': dt.datetime(2021, 11, 1),\n        # 'stop': dt.datetime(2021, 11, 2),\n        'start': dt.datetime(2021, 8, 1),\n        'stop': dt.datetime(2021, 8, 2),\n    },\n    # variables=variables,\n)\n\n\nCheck Request validity\nBefore submitting a Harmony Request, we can test your request to see if it’s valid and how to fix it if not. In particular, request.is_valid will check to ensure that the spatial BBox bounds and temporal ranges are entered correctly.\n\nrequest.is_valid()\n\nTrue\n\n\n\n\nSubmit request\nNow that the request is created, we can now submit it to Harmony using the Harmony Client object. A job id is returned, which is a unique identifier that represents the submitted request.\n\njob_id = harmony_client.submit(request)\njob_id\n\n'9979fa59-f3e9-4ac9-b8c1-2888bc736258'\n\n\n\n\nCheck request status\nWe can check on the progress of a processing job with status(). This method blocks while communicating with the server but returns quickly.\n\nharmony_client.status(job_id)\n\n{'status': 'running',\n 'message': 'There were 2 collections that matched the provided short name MODIS_A-JPL-L2P-v2019.0. See https://cmr.earthdata.nasa.gov/concepts/C1940473819-POCLOUD for details on the selected collection. The version ID for the selected collection is 2019.0. To use a different collection submit a new request specifying the desired CMR concept ID instead of the collection short name.',\n 'progress': 0,\n 'created_at': datetime.datetime(2021, 11, 11, 4, 23, 47, 746000, tzinfo=tzlocal()),\n 'updated_at': datetime.datetime(2021, 11, 11, 4, 23, 47, 746000, tzinfo=tzlocal()),\n 'request': 'https://harmony.earthdata.nasa.gov/MODIS_A-JPL-L2P-v2019.0/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?forceAsync=true&subset=lat(21.20806%3A30.16605)&subset=lon(-97.77667%3A-83.05197)&subset=time(%222021-08-01T00%3A00%3A00%22%3A%222021-08-02T00%3A00%3A00%22)',\n 'num_input_granules': 6}\n\n\nDepending on the size of the request, it may be helpful to wait until the request has completed processing before the remainder of the code is executed. The wait_for_processing() method will block subsequent lines of code while optionally showing a progress bar.\n\nharmony_client.wait_for_processing(job_id, show_progress=True)\n\n [ Processing: 100% ] |###################################################| [|]\n\n\n\n\nView Harmony job response and output URLs\nOnce the data request has finished processing, we can view details on the job that was submitted to Harmony, including the API call to Harmony, and informational messages on the request if available.\nresult_json() calls wait_for_processing() and returns the complete job in JSON format once processing is complete.\n\ndata = harmony_client.result_json(job_id)\npprint(data)\n\n{'createdAt': '2021-11-11T04:23:47.746Z',\n 'jobID': '9979fa59-f3e9-4ac9-b8c1-2888bc736258',\n 'links': [{'href': 'https://harmony.earthdata.nasa.gov/stac/9979fa59-f3e9-4ac9-b8c1-2888bc736258/',\n            'rel': 'stac-catalog-json',\n            'title': 'STAC catalog',\n            'type': 'application/json'},\n           {'bbox': [-95.851, 29.339, -62.863, 50.743],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801072501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T07:29:58.000Z',\n                         'start': '2021-08-01T07:25:01.000Z'},\n            'title': '20210801072501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [-97.5, 21.2, -83.1, 30.2],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801073001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T07:34:58.000Z',\n                         'start': '2021-08-01T07:30:01.000Z'},\n            'title': '20210801073001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [-97.8, 25.9, -96.2, 30.2],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801090501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T09:09:58.000Z',\n                         'start': '2021-08-01T09:05:01.000Z'},\n            'title': '20210801090501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [-90.2, 21.2, -83.1, 29.8],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801182501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T18:29:58.000Z',\n                         'start': '2021-08-01T18:25:01.000Z'},\n            'title': '20210801182501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [-90.9, 28.3, -83.1, 30.2],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801183001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T18:34:58.000Z',\n                         'start': '2021-08-01T18:30:01.000Z'},\n            'title': '20210801183001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'bbox': [-97.8, 21.2, -89.5, 30.2],\n            'href': 'https://harmony.earthdata.nasa.gov/service-results/harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801200501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'rel': 'data',\n            'temporal': {'end': '2021-08-01T20:09:58.000Z',\n                         'start': '2021-08-01T20:05:01.000Z'},\n            'title': '20210801200501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n            'type': 'application/x-netcdf4'},\n           {'href': 'https://harmony.earthdata.nasa.gov/jobs/9979fa59-f3e9-4ac9-b8c1-2888bc736258?linktype=https&page=1&limit=2000',\n            'rel': 'self',\n            'title': 'The current page',\n            'type': 'application/json'}],\n 'message': 'There were 2 collections that matched the provided short name '\n            'MODIS_A-JPL-L2P-v2019.0. See '\n            'https://cmr.earthdata.nasa.gov/concepts/C1940473819-POCLOUD for '\n            'details on the selected collection. The version ID for the '\n            'selected collection is 2019.0. To use a different collection '\n            'submit a new request specifying the desired CMR concept ID '\n            'instead of the collection short name.',\n 'numInputGranules': 6,\n 'progress': 100,\n 'request': 'https://harmony.earthdata.nasa.gov/MODIS_A-JPL-L2P-v2019.0/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?forceAsync=true&subset=lat(21.20806%3A30.16605)&subset=lon(-97.77667%3A-83.05197)&subset=time(%222021-08-01T00%3A00%3A00%22%3A%222021-08-02T00%3A00%3A00%22)',\n 'status': 'successful',\n 'updatedAt': '2021-11-11T04:24:25.421Z',\n 'username': 'amy.steiker'}\n\n\n\n\nDirect cloud access\nNote that the remainder of this tutorial will only succeed when running this notebook within the AWS us-west-2 region.\nHarmony data outputs can be accessed within the cloud using the s3 URLs and AWS credentials provided in the Harmony job response.\n\nRetrieve list of output URLs.\nThe result_urls() method calls wait_for_processing() and returns a list of the processed data URLs once processing is complete. You may optionally show the progress bar as shown below.\n\nresults = harmony_client.result_urls(job_id, link_type=LinkType.s3)\nurls = list(results)\npprint(urls)\n\n['s3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801072501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801073001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801090501-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801182501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801183001-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4',\n 's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801200501-JPL-L2P_GHRSST-SSTskin-MODIS_A-D-v02.0-fv01.0_subsetted.nc4']\n\n\nWe can see that the first file returned does not include the _subsetted suffix, which indicates that a blank file was returned, as no data values were located within our subsetted region. We’ll select the second URL in the list to bring into xarray below.\n\nurl = urls[1]\nurl\n\n's3://harmony-prod-staging/public/podaac/l2-subsetter/b081caea-4c8c-4118-b613-e8688b16140c/20210801073001-JPL-L2P_GHRSST-SSTskin-MODIS_A-N-v02.0-fv01.0_subsetted.nc4'\n\n\n\n\nAWS credential retrieval\nUsing aws_credentials you can retrieve the credentials needed to access the Harmony s3 staging bucket and its contents.\ncreds = harmony_client.aws_credentials()\n\n\n\nOpen staged files with s3fs and xarray\nWe use the AWS s3fs package to create a file system that can then be read by xarray:\ns3_fs = s3fs.S3FileSystem(\n    key=creds['aws_access_key_id'],\n    secret=creds['aws_secret_access_key'],\n    token=creds['aws_session_token'],\n    client_kwargs={'region_name':'us-west-2'},\n)\n\n\n**Note, Ideally, we’d show how to bring in all files into a single xarray ds but I’m getting an error:\n# # Iterate through remote_files to create a fileset\n# fileset = [s3_fs.open(file) for file in urls]\n# fileset\n# ds = xr.open_mfdataset(fileset)\nNow that we have our s3 file system set, including our declared credentials, we’ll use that to open the url, and read in the file through xarray:\n\nf = s3_fs.open(url, mode='rb')\n# ds = xr.open_dataset(f, decode_cf=False)\nds = xr.open_dataset(f)\nds.sea_surface_temperature.plot()\nf.close()\n\n\n\n\n\n\nPlot the data\n# # Determine the lat/lon coordinate names\n# for coord_name, coord in ds.coords.items():\n#     if 'units' not in coord.attrs:\n#         continue\n#     if coord.attrs['units'] == 'degrees_north':\n#         lat_var = coord_name\n#     if coord.attrs['units'] == 'degrees_east':\n#         lon_var = coord_name\n\n# print(f'lat_var={lat_var}')\n# print(f'lon_var={lon_var}')\n\n# # if ds[variable].size == 0:\n# #     print(\"No data in subsetted region. Exiting\")\n# #     sys.exit(0)\n    \n# import matplotlib.pyplot as plt\n# import math\n\n# fig, axes = plt.subplots(ncols=3, nrows=math.ceil((len(ds.data_vars)/3)))\n# fig.set_size_inches((15,15))\n\n# for count, xvar in enumerate(ds.data_vars):\n#     if  ds[xvar].dtype == \"timedelta64[ns]\":\n#         continue\n#         #ds[xvar].astype('timedelta64[D]').plot(ax=axes[int(count/3)][count%3])\n#     ds[xvar].plot(ax=axes[int(count/3)][count%3])\n\n\nExtra code attempting to read in directly from s3 into xarray:\n# netcdf_stores = [netcdf_fs.get_mapper(root=u, check=False) for u in urls]\n# netcdf_stores\n\n# xr.open_mfdataset(netcdf_stores)"
  },
  {
    "objectID": "tutorials/Data_Access__Harmony_Subsetting.html#resources",
    "href": "tutorials/Data_Access__Harmony_Subsetting.html#resources",
    "title": "",
    "section": "Resources",
    "text": "https://github.com/podaac/tutorials/blob/master/notebooks/SWOT-EA-2021/Colocate_satellite_insitu_ocean.ipynb"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#summary",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Hello World"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#exercise",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#exercise",
    "title": "",
    "section": "Exercise",
    "text": "Import Required Packages\n#\n\n\nGet Temporary Credentials and Configure Local Environment\nTo perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME.\n#\n#\n\nInsert the credentials into our boto3 session and configure out rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session can then be used to pass those credentials and get S3 objects from applicable buckets.\n#\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n#\n\n\n\nRead In and Process STAC Asset Links\nIn the previous section, we used the NASA CMR-STAC API to discover HLS assets the intersect with our search criteria, i.e., ROI, Date range, and collections. The search results were filtered and saved as text files by individual bands for each tile. We will read in the text files for tile T13TGF for the RED (L30: B04 & S30: B04), NIR (L30: B05 & S30: B8A), and Fmask bands.\n\nList text files with HLS links\n#\n\n\nRead in our asset links for BO4 (RED)\n#\n\n\nRead in and combine our asset links for BO5 (Landsat NIR) and B8A (Sentinel-2 NIR)\nThe near-infrared (NIR) band for Landsat is B05 while the NIR band for Sentinel-2 is B8A. In the next step we will read in and combine the lists into a single NIR list.\n#\n\n\nRead in our asset links for Fmask\n#\nIn this example we will use the gdalbuildvrt.exe utility to create a time series virtual raster format (VRT) file. The utility, however, expects the links to be formated with the GDAL virtual file system (VSI) path, rather than the actual asset links. We will therefore use the VSI path to access our assets. The examples below show the VSI path substitution for S3 (vsis3) links.\n/vsis3/lp-prod-protected/HLSS30.015/HLS.S30.T13TGF.2020191T172901.v1.5.B04.tif\nSee the GDAL Virtual File Systems for more information regarding GDAL VSI.\n\n\nWrite out a new text file containing the vsis3 path\n#\n#\n#\n\n\n\nRead in geoJSON for subsetting\nWe will use the input geoJSON file to clip the source data to our desired region of interest.\n#\nTo clip the source data to our input feature boundary, we need to transform the feature boundary from its original WGS84 coordinate reference system to the projected reference system of the source HLS file (i.e., UTM Zone 13).\n#\n\nTransform geoJSON feature from WGS84 to UTM\n#\n\n\n\nDirect S3 Data Access\n\nStart up a dask client\n#\n#\nThere are multiple way to read COG data in as a time series. The subprocess package is used in this example to run GDAL’s build virtual raster file (gdalbuildvrt) executable outside our python session. First we’ll need to construct a string object with the command and it’s parameter parameters (including our temporary credentials). Then, we run the command using the subprocess.call() function.\n\n\nBuild GDAL VRT Files\n\nConstruct the GDAL VRT call\n#\nWe now have a fully configured gdalbuildvrt string that we can pass to Python’s subprocess module to run the gdalbuildvrt executable outside our Python environment.\n\n\n\nExecute gdalbuildvrt to construct a VRT on disk from the S3 links\n#\n0 means success! We’ll have some troubleshooting to do you get any other value. In this tutorial, the path for the output VRT file or the input file list are the first things to check.\nWhile we’re here, we’ll build the VRT files for the NIR layers and the Fmask layers.\n#\n#\n\n\n\nReading in an HLS time series\nWe can now read the VRT files into our Python session. A drawback of reading VRTs into Python is that the time coordinate variable needs to be contructed. Below we not only read in the VRT file using rioxarray, but we also repurpose the band variable, which is generated automatically, to hold out time information.\n\nRead the RED VRT in as xarray with Dask backing\n#\nAbove we use the parameter chunk in the rioxarray.open_rasterio() function to enable the Dask backing. What this allows is lazy reading of the data, which means the data is not actually read in into memory at this point. What we have is an object with some metadata and pointer to the source data. The data will be streamed to us when we call for it, but not stored in memory until with call the Dask compute() or persist() methods.\n\n\nPrint out the time coordinate\n#\n\n\nClip out the ROI and persist the result in memory\nUp until now, we haven’t read any of the HLS data into memory. Now we will use the persist() method to load the data into memory.\n#\nAbove, we persisted the clipped results to memory using the persist() method. This doesn’t necessarily need to be done, but it will substantially improve the performance of the visualization of the time series below.\n\n\nPlot red_clip with hvplot\n#\n\n\n\nRead in the NIR and Fmask VRT files\n#\n#\n\n\nCreate an xarray dataset\nWe will now combine the RED, NIR, and Fmask arrays into a dataset and create/add a new NDVI variable.\n#\nAbove, we created a new NDVI variable. Now, we will clip and plot our results.\n#\n\nPlot NDVI\n#\nYou may have notices that some images for some of the time step are ‘blurrier’ than other. This is because they are contaminated in some way, be it clouds, cloud shadows, snow, ice.\n\n\n\nApply quality filter\nWe want to keep NDVI data values where Fmask equals 0 (no clouds, no cloud shadow, no snow/ice, no water.\n#\n#\n\nAggregate by month\nFinally, we will use xarray’s groupby operation to aggregate by month.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#references",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__gdalvrt.html#references",
    "title": "",
    "section": "References",
    "text": "https://rasterio.readthedocs.io/en/latest/\nhttps://corteva.github.io/rioxarray/stable/index.html\nhttps://tutorial.dask.org/index.html\nhttps://examples.dask.org/applications/satellite-imagery-geotiff.html"
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#why-do-we-need-xarray",
    "href": "tutorials-templates/03_Xarray.html#why-do-we-need-xarray",
    "title": "",
    "section": "Why do we need xarray?",
    "text": "As Geoscientists, we often work with time series of data with two or more dimensions: a time series of calibrated, orthorectified satellite images; two-dimensional grids of surface air temperature from an atmospheric reanalysis; or three-dimensional (level, x, y) cubes of ocean salinity from an ocean model. These data are often provided in GeoTIFF, NetCDF or HDF format with rich and useful metadata that we want to retain, or even use in our analysis. Common analyses include calculating means, standard deviations and anomalies over time or one or more spatial dimensions (e.g. zonal means). Model output often includes multiple variables that you want to apply similar analyses to.\n\n\n\nA schematic of multi-dimensional data\n\n\nThe schematic above shows a typical data structure for multi-dimensional data. There are two data cubes, one for temperature and one for precipitation. Common coordinate variables, in this case latitude, longitude and time are associated with each variable. Each variable, including coordinate variables, will have a set of attributes: name, units, missing value, etc. The file containing the data may also have attributes: source of the data, model name coordinate reference system if the data are projected. Writing code using low-level packages such as netcdf4 and numpy to read the data, then perform analysis, and write the results to file is time consuming and prone to errors."
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#what-is-xarray",
    "href": "tutorials-templates/03_Xarray.html#what-is-xarray",
    "title": "",
    "section": "What is xarray",
    "text": "xarray is an open-source project and python package to work with labelled multi-dimensional arrays. It is leverages numpy, pandas, matplotlib and dask to build Dataset and DataArray objects with built-in methods to subset, analyze, interpolate, and plot multi-dimensional data. It makes working with multi-dimensional data cubes efficient and fun. It will change your life for the better. You’ll be more attractive, more interesting, and better equiped to take on lifes challenges."
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials-templates/03_Xarray.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "In this tutorial you will learn how to:\n\nload a netcdf file into xarray\ninterrogate the Dataset and understand the difference between DataArray and Dataset\nsubset a Dataset\ncalculate annual and monthly mean fields\ncalculate a time series of zonal means\nplot these results\n\nAs always, we’ll start by importing xarray. We’ll follow convention by giving the module the shortname xr\n#\nI’m going to use one of xarray’s tutorial datasets. In this case, air temperature from the NCEP reanalysis. I’ll assign the result of the open_dataset to ds. I may change this to access a dataset directly\n#\nAs we are in an interactive environment, we can just type ds to see what we have.\n#\nFirst thing to notice is that ds is an xarray.Dataset object. It has dimensions, lat, lon, and time. It also has coordinate variables with the same names as these dimensions. These coordinate variables are 1-dimensional. This is a NetCDF convention. The Dataset contains one data variable, air. This has dimensions (time, lat, lon).\nClicking on the document icon reveals attributes for each variable. Clicking on the disk icon reveals a representation of the data.\nEach of the data and coordinate variables can be accessed and examined using the variable name as a key.\n#\n#\nThese are xarray.DataArray objects. This is the basic building block for xarray.\nVariables can also be accessed as attributes of ds.\n#\nA major difference between accessing a variable as an attribute versus using a key is that the attribute is read-only but the key method can be used to update the variable. For example, if I want to convert the units of air from Kelvin to degrees Celsius.\n#\nThis approach can also be used to add new variables\n#\nIt is helpful to update attributes such as units, this saves time, confusion and mistakes, especially when you save the dataset.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#subsetting-and-indexing",
    "href": "tutorials-templates/03_Xarray.html#subsetting-and-indexing",
    "title": "",
    "section": "Subsetting and Indexing",
    "text": "Subsetting and indexing methods depend on whether you are working with a Dataset or DataArray. A DataArray can be accessed using positional indexing just like a numpy array. To access the temperature field for the first time step, you do the following.\n#\nNote this returns a DataArray with coordinates but not attributes.\nHowever, the real power is being able to access variables using coordinate variables. I can get the same subset using the following. (It’s also more explicit about what is being selected and robust in case I modify the DataArray and expect the same output.)\n#\n#\nI can also do slices. I’ll extract temperatures for the state of Colorado. The bounding box for the state is [-109 E, -102 E, 37 N, 41 N].\nIn the code below, pay attention to both the order of the coordinates and the range of values. The first value of the lat coordinate variable is 41 N, the second value is 37 N. Unfortunately, xarray expects slices of coordinates to be in the same order as the coordinates. Note lon is 0 to 360 not -180 to 180, and I let python calculate it for me within the slice.\n#\nWhat if we want temperature for a point, for example Denver, CO (39.72510678889283 N, -104.98785545855408 E). xarray can handle this! If we just want data from the nearest grid point, we can use sel and specify the method as “nearest”.\n#\n#\nIf we want to interpolate, we can use interp(). In this case I use linear or bilinear interpolation.\ninterp() can also be used to resample data to a new grid and even reproject data\n#\nsel() and interp() can also be used on Dataset objects.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#analysis",
    "href": "tutorials-templates/03_Xarray.html#analysis",
    "title": "",
    "section": "Analysis",
    "text": "As a simple example, let’s try to calculate a mean field for the whole time range.\n#\nWe can also calculate a zonal mean (averaging over longitude)\n#\nOther aggregation methods include min(), max(), std(), along with others.\n#\nThe data we have are in 6h timesteps. This can be resampled to daily or monthly. If you are familiar with pandas, xarray uses the same methods.\n#\n#\nThis is a really short time series but as an example, let’s calculate a monthly climatology (at least for 2 months). For this we can use groupby()\n#"
  },
  {
    "objectID": "tutorials-templates/03_Xarray.html#plot-results",
    "href": "tutorials-templates/03_Xarray.html#plot-results",
    "title": "",
    "section": "Plot results",
    "text": "Finally, let’s plot the results! This will plot the lat/lon axes of the original ds DataArray.\n#"
  },
  {
    "objectID": "tutorials-templates/01_Data_Discovery_CMR.html#what-is-cmr",
    "href": "tutorials-templates/01_Data_Discovery_CMR.html#what-is-cmr",
    "title": "",
    "section": "What is CMR",
    "text": "CMR is the Common Metadata Repository. It catalogs all data for NASA’s Earth Observing System Data and Information System (EOSDIS). It is the backend of Earthdata Search, the GUI search interface you are probably familiar with. More information about CMR can be found here.\nUnfortunately, the GUI for Earthdata Search is not accessible from a cloud instance - at least not without some work. Earthdata Search is also not immediately reproducible. What I mean by that is if you create a search using the GUI you would have to note the search criteria (date range, search area, collection name, etc), take a screenshot, copy the search url, or save the list of data granules returned by the search, in order to recreate the search. This information would have to be re-entered each time you or someone else wanted to do the search. You could make typos or other mistakes. A cleaner, reproducible solution is to search CMR programmatically using the CMR API."
  },
  {
    "objectID": "tutorials-templates/01_Data_Discovery_CMR.html#what-is-the-cmr-api",
    "href": "tutorials-templates/01_Data_Discovery_CMR.html#what-is-the-cmr-api",
    "title": "",
    "section": "What is the CMR API",
    "text": "API stands for Application Programming Interface. It allows applications (software, services, etc) to send information to each other. A helpful analogy is a waiter in a restaurant. The waiter takes your drink or food order that you select from the menu, often translated into short-hand, to the bar or kitchen, and then returns (hopefully) with what you ordered when it is ready.\nThe CMR API accepts search terms such as collection name, keywords, datetime range, and location, queries the CMR database and returns the results."
  },
  {
    "objectID": "tutorials-templates/01_Data_Discovery_CMR.html#how-to-search-cmr-from-python",
    "href": "tutorials-templates/01_Data_Discovery_CMR.html#how-to-search-cmr-from-python",
    "title": "",
    "section": "How to search CMR from Python",
    "text": "The first step is to import python packages. We will use:\n- requests This package does most of the work for us accessing the CMR API using HTTP methods. - pprint to pretty print the results of the search.\nA more in depth tutorial on requests is here\n#\nThen we need to authenticate with EarthData Login. Since we’ve already set this up in the previous lesson, here you need to enter your username before executing the cell.\nTo conduct a search using the CMR API, requests needs the url for the root CMR search endpoint. We’ll build this url as a python variable.\n#\nCMR allows search by collections, which are datasets, and granules, which are files that contain data. Many of the same search parameters can be used for colections and granules but the type of results returned differ. Search parameters can be found in the API Documentation.\nWhether we search collections or granules is distinguished by adding \"collections\" or \"granules\" to the url for the root CMR endpoint.\nWe are going to search collections first, so we add collections to the url. I’m using a python format string here.\n#\nIn this first example, I want to retrieve a list of collections that are hosted in the cloud. Each collection has a cloud_hosted parameter that is either True if that collection is in the cloud and False if it is not. The migration of NASA data to the cloud is a work in progress. Not all collections tagged as cloud_hosted have granules. To search for only cloud_hosted datasets with granules, I also set has_granules to True.\nI also want to get the content in json (pronounced “jason”) format, so I pass a dictionary to the header keyword argument to say that I want results returned as json.\nThe .get() method is used to send this information to the CMR API. get() calls the HTTP method GET.\n#\nrequests returns a Response object.\nOften, we want to check that our request was successful. In a notebook or someother interactive environment, we can just type the name of the variable we have saved our requests Response to, in this case the response variable.\n#\nA cleaner and more understandable method is to check the status_code attribute. Both methods return a HTTP status code. You’ve probably seen a 404 error when you have tried to access a website that doesn’t exist.\n#\nTry changing CMR_OPS to https://cmr.earthdata.nasa.gov/searches and run requests.get again. Don’t forget to rerun the cell that assigns the url variable\nThe response from requests.get returns the results of the search and metadata about those results in the headers.\nMore information about the response object can be found by typing help(response).\nheaders contains useful information in a case-insensitive dictionary. This information is printed below. TODO: maybe some context for where the 2 elements k, v, come from?\n#\nWe can see that the content returned is in json format in the UTF-8 character set. We can also see from CMR-Hits that 919 collections were found.\nEach item in the dictionary can be accessed in the normal way you access a python dictionary but because it is case-insensitive, both\n#\nand\n#\nwork.\nThis is a large number of data sets. I’m going to restrict the search to cloud-hosted datasets from ASF (Alaska SAR Facility) because I’m interested in SAR images of sea ice. To do this, I set the provider parameter to ASF.\nYou can modify the code below to explore all of the cloud-hosted datasets or cloud-hosted datasets from other providers. A partial list of providers is given below.\n\n\n\n\n\n\n\n\n\nDAAC\nShort Name\nCloud Provider\nOn-Premises Provider\n\n\n\n\nNSIDC\nNational Snow and Ice Data Center\nNSIDC_CPRD\nNSIDC_ECS\n\n\nGHRC DAAC\nGlobal Hydrometeorology Resource Center\nGHRC_DAAC\nGHRC_DAAC\n\n\nPO DAAC\nPhysical Oceanography Distributed Active Archive Center\nPOCLOUD\nPODAAC\n\n\nASF\nAlaska Satellite Facility\nASF\nASF\n\n\nORNL DAAC\nOak Ridge National Laboratory\nORNL_CLOUD\nORNL_DAAC\n\n\nLP DAAC\nLand Processes Distributed Active Archive Center\nLPCLOUD\nLPDAAC_ECS\n\n\nGES DISC\nNASA Goddard Earth Sciences (GES) Data and Information Services Center (DISC)\nGES_DISC\nGES_DISC\n\n\nOB DAAC\nNASA’s Ocean Biology Distributed Active Archive Center\n\nOB_DAAC\n\n\nSEDAC\nNASA’s Socioeconomic Data and Applications Center\n\nSEDAC\n\n\n\nWhen search by provider, use Cloud Provider to search for cloud-hosted datasets and On-Premises Provider to search for datasets archived at the DAACs.\n#\n#\nSearch results are contained in the content part of the Response object. However, response.content returns information in bytes.\n#\nIt is more convenient to work with json formatted data. I’m using pretty print pprint to print the data in an easy to read way.\nStep through response.json(), then to response.json()['feed']['entry'][0]. A reminder that python starts indexing at 0, not 1!\n#\nThe first response is not the result I am looking for TODO: because xyz…but it does show a few variables that we can use to further refine the search. So I want to print the name of the dataset (dataset_id) and the concept id (id). We can build this variable and print statement like we did above with the url variable. TODO: is it worth saying something about what “feed” and “entry” are?\n#\n#\nBut there is a problem. We know from CMR-Hits that there are 49 datasets but only 10 are printed. This is because CMR restricts the number of results returned by a query. The default is 10 but it can be set to a maximum of 2000. Knowing that there were 49 ‘hits’, I’ll set page_size to 49. Then, we can re-run our for loop for the collections.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/01_Data_Discovery_CMR.html#granule-search",
    "href": "tutorials-templates/01_Data_Discovery_CMR.html#granule-search",
    "title": "",
    "section": "Granule Search",
    "text": "In NASA speak, Granules are files. In this example, we will search for recent Sentinel-1 Ground Range Detected (GRD) Medium Resolution Synthetic Aperture Radar images over the east coast of Greenland. The data in these files are most useful for sea ice mapping.\nI’ll use the data range 2021-10-17 00:00 to 2021-10-18 23:59:59.\nI’ll use a simple bounding box to search. - SW: 76.08166,-67.1746 - NW: 88.19689,21.04862\nFrom the collections search, I know the concept ids for Sentinel-1A and Sentinel-1B GRD medium resolution are - C1214472336-ASF - C1327985578-ASF\nWe need to change the resource url to look for granules instead of collections\n#\nWe will search by concept_id, temporal, and bounding_box. Details about these search parameters can be found in the CMR API Documentation.\nThe formatting of the values for each parameter is quite specific.\nTemporal parameters are in ISO 8061 format yyyy-MM-ddTHH:mm:ssZ.\nBounding box coordinates are lower left longitude, lower left latitude, upper right longitude, upper right latitude.\n#\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#summary",
    "href": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This tutorial will combine several workflow steps and components from the previous days, demonstrating the process of using the geolocation of data available outside of the Earthdata Cloud to then access coincident variables of cloud-accessible data. This may be a common use case as NASA Earthdata continues to migrate to the cloud, producing a “hybrid” data archive across Amazon Web Services (AWS) and original on-premise data storage systems. Additionally, you may also want to combine field measurements with remote sensing data available on the Earthdata Cloud.\nThis specific example explores the harmonization of the ICESat-2 ATL03 data product, currently (as of November 2021) available publicly via direct download at the NSIDC DAAC, with Sea Surface Temperature variables available from PO.DAAC on the Earthdata Cloud.\n\nObjectives\n[TODO]\n\n\n\nImport packages\n#\n\n\nDetermine storage location of datasets of interest\nFirst, let’s see whether our datasets of interest reside in the Earthdata Cloud or whether they reside on premise, or “on prem” at a local data center.\nBackground from CMR API [TODO: consider removing]: The cloud_hosted parameter can be set to “true” or “false”. When true, the results will be restricted to collections that have a DirectDistributionInformation element or have been tagged with gov.nasa.earthdatacloud.s3.\nWe are building off of the CMR introductory tutorial, beginning with a collection search.\n#\nWe want to search by collection to inspect the access and service options that exist:\n#\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given dataset id (also referred to as a short_name). Here we’ll start with two datasets that we want to explore over a coincident area and time:\n#\nLike in the intro tutorial, we’re going to first determine what concept-ids are returned for the MODIS dataset. First, retrieve collection results based on the MODIS short_name:\n#\nFor each collection result, print out the CMR concept-id and version:\n#\nTwo collections are returned, both at version 2019.0. We can see from the suffix of the id that one is associated with “POCLOUD” versus “PODAAC”. That gives us a clue in terms of where the data are hosted, but we can also use the cloud_hosted parameter set to True to confirm.\n#\n#\nWe will save this concept-id to use later on when we access the data granules.\n#\nNow we will try our ICESat-2 dataset to see what id’s are returned for a given dataset name.\n#\n#\nTwo separate datasets exist in the CMR, one at version 3 and one at version 4. Let’s see if these are cloud_hosted:\n#\n#\nWhen set to False, we get our collections back. We have now determined that we have a copy of the MODIS dataset in the cloud, whereas the ICESat-2 dataset (both versions) remains “on premise”, residing in a local data center.\nSave the ATL03 concept ID and the MODIS GHRSST concept ID to variables:\n#\n\nSpecify time range and area of interest\nWe are going to focus on getting data for an area north of Greenland for a single day in June.\nThese bounding_box and temporal variables will be used for data search, subset, and access below\n#\nPerform a granule search over our time and area of interest. How many granules are returned?\n#\n#\nPrint the file names, size, and links:\n#\n\n\n\nDownload ICESat-2 ATL03 granule\n[TODO] Describe what services are available, including icepyx (provide references), but just direct download for simplicity. Describe that this is being “downloaded” to our cloud environment - what does that mean in terms of cost, etc.\nWe’ve found 2 granules. We’ll download the first one and write it to a file with the same name as the producer_granule_id.\nWe need the url for the granule as well. This is href links we printed out above.\n#\nYou need Earthdata login credentials to download data from NASA DAACs. These are the credentials you stored in the .netrc file you setup in previous tutorials.\nWe’ll use the netrc package to retrieve your login and password without exposing them.\n#\nTo retrieve the granule data, we use the requests.get() method, passing Earthdata login credentials as a tuple using the auth keyword.\n#\nThe response returned by requests has the same structure as all the other responses: a header and contents. The header information has information about the response, including the size of the data we downloaded in bytes.\n#\nThe contents needs to be saved to a file. To keep the directory clean, we will create a downloads directory to store the file. We can use a shell command to do this or use the mkdir method from the os package.\n#\nYou should see a downloads directory in the file browser.\nTo write the data to a file, we use open to open a file. We need to specify that the file is open for writing by using the write-mode w. We also need to specify that we want to write bytes by setting the binary-mode b. This is important because the response contents are bytes. The default mode for open is text-mode. So make sure you use b.\nWe’ll use the with statement context-manager to open the file, write the contents of the response, and then close the file. Once the data in r.content is written sucessfully to the file, or if there is an error, the file is closed by the context-manager.\nWe also need to prepend the downloads path to the filename. We do this using Path from the pathlib package in the standard library.\n#\nCheck to make sure it is downloaded.\n#\nATL03_20190622061415_12980304_004_01.h5 is an HDF5 file. xarray can open this but you need to tell it which group to read the data from. In this case we read the height data for ground-track 1 left-beam.\n#\n\n\nDetermine variables of interest: SST, ocean color, chemistry…\n#\n\n\nPull those variables into xarray “in place”\n\nFirst, we need to determine the granules returned from our time and area of interest\n#\n#\n#\n\n\n\nGet S3 credentials\n#\n#\n\n\nOpen a s3 file\n#\n\n\nUse geolocation of ICESat-2 to define the single transect used to pull coincident ocean data out from array\n\n\nCreate a plot of the single transect of gridded data\n(bonus: time series) - describe what this means to egress out of the cloud versus pulling the original data down (benefit to processing in the cloud)"
  },
  {
    "objectID": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "href": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "title": "",
    "section": "Download MODIS GHRSST data from Cloud",
    "text": "#\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#resources-optional",
    "href": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#resources-optional",
    "title": "",
    "section": "Resources (optional)",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#conclusion",
    "href": "tutorials-templates/08_Data_Access_Harmonize-cloud-non-cloud.html#conclusion",
    "title": "",
    "section": "Conclusion",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/04_NASA_Earthdata_Authentication.html#summary",
    "href": "tutorials-templates/04_NASA_Earthdata_Authentication.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This notebook creates a hidden .netrc file (_netrc for Window OS) with Earthdata login credentials in your home directory. This file is need to access NASA Earthdata assets from a scripting environment like Python.\n\nEarthdata Login\nAn Earthdata Login account is required to access data, as well as discover restricted data, from the NASA Earthdata system. Thus, to access NASA data, you need Earthdata Login. Please visit https://urs.earthdata.nasa.gov to register and manage your Earthdata Login account. This account is free to create and only takes a moment to set up.\n\n\nAuthentication via netrc File\nYou will need a netrc file containing your NASA Earthdata Login credentials in order to execute the notebooks. A netrc file can be created manually within text editor and saved to your home directory. An example of the required content is below.\nmachine urs.earthdata.nasa.gov\nlogin <USERNAME>\npassword <PASSWORD>\n<USERNAME> and <PASSWORD> would be replaced by your actual Earthdata Login username and password respectively."
  },
  {
    "objectID": "tutorials-templates/04_NASA_Earthdata_Authentication.html#import-required-packages",
    "href": "tutorials-templates/04_NASA_Earthdata_Authentication.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "#\nThe code below will:\n\ncheck what operating system (OS) is being used to determine which netrc file to check for/create (.netrc or _netrc)\ncheck if you have an netrc file, and if so, varify if those credentials are for the Earthdata endpoint\ncreate a netrc file if a netrc file is not present.\n\n#\n\nSee if the file was created\nIf the file was created, we’ll see a .netrc file (_netrc for Window OS) in the list printed below. To view the contents from a Jupyter environment, click File on the top toolbar, select Open from Path…, type .netrc, and click Open. The .netrc file will open within the text editor.\n\n!!! Beware, your password will be visible if the .netrc file is opened in the text editor.\n\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Data_Access__Direct_S3_Access__PODAAC_ECCO_SSH.html",
    "href": "tutorials-templates/Additional_Resources__Data_Access__Direct_S3_Access__PODAAC_ECCO_SSH.html",
    "title": "",
    "section": "",
    "text": "Direct S3 Data Access - Rough PODAAC ECCO SSH Example"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#timing",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#timing",
    "title": "",
    "section": "Timing",
    "text": "Exercise: 30 min"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#summary",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In this example we will access the NASA’s Harmonized Landsat Sentinel-2 (HLS) version 2 assets, which are archived in cloud optimized geoTIFF (COG) format in the LP DAAC Cumulus cloud space. The COGs can be used like any other geoTIFF file, but have some added features that make them more efficient within the cloud data access paradigm. These features include: overviews and internal tiling. Below we will demonstrate how to leverage these features.\n\nBut first, what is STAC?\nSpatioTemporal Asset Catalog (STAC) is a specification that provides a common language for interpreting geospatial information in order to standardize indexing and discovering data.\nThe STAC specification is made up of a collection of related, yet independent specifications that when used together provide search and discovery capabilities for remove assets.\n\nFour STAC Specifications\nSTAC Item (aka Granule)\nSTAC Catalog (aka DAAC Archive)\nSTAC Collection (aka Data Product)\nSTAC API\nIn the following sections, we will explore each of STAC element using NASA’s Common Metadata Repository (CMR) STAC application programming interface (API), or CMR-STAC API for short.\n\n\n\nCMR-STAC API\nThe CMR-STAC API is NASA’s implementation of the STAC API specification for all NASA data holdings within EOSDIS. The current implementation does not allow for querries accross the entire NASA catalog. Users must execute searches within provider catalogs (e.g., LPCLOUD) to find the STAC Items they are searching for. All the providers can be found at the CMR-STAC endpoint here: https://cmr.earthdata.nasa.gov/stac/.\nIn this exercise, we will query the LPCLOUD provider to identify STAC Items from the Harmonized Landsat Sentinel-2 (HLS) collection that fall within our region of interest (ROI) and within our specified time range."
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "how to connect to NASA CMR-STAC API using Python’s pystac-client\n\nhow to navigate CMR-STAC records\n\nhow to read in a geojson file using geopandas to specify your region of interest\nhow to use the CMR-STAC API to search for data\nhow to perform post-search filtering of CMR-STAC API search result in Python\n\nhow to extract and save data access URLs for geospatial assets\n\nThis exercise can be found in the 2021 Cloud Hackathon Book"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#import-required-packages",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#explored-available-nasa-providers",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#explored-available-nasa-providers",
    "title": "",
    "section": "Explored available NASA Providers",
    "text": "#\n\nConnect to the CMR-STAC API\n#\nWe’ll create a providers variable so we can take a deeper look into available data providers - subcategories are referred to as “children”. We can then print them as a for loop.\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#connect-to-the-lpcloud-providerstac-catalog",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#connect-to-the-lpcloud-providerstac-catalog",
    "title": "",
    "section": "Connect to the LPCLOUD Provider/STAC Catalog",
    "text": "For this next step we need the provider title (e.g., LPCLOUD) from above. We will add the provider to the end of the CMR-STAC API URL (i.e., https://cmr.earthdata.nasa.gov/stac/) to connect to the LPCLOUD STAC Catalog.\n#\nSince we are using a dedicated client (i.e., pystac-client.Client) to connect to our STAC Provider Catalog, we will have access to some useful internal methods and functions we can use to get information from these objects."
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#list-stac-collections",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#list-stac-collections",
    "title": "",
    "section": "List STAC Collections",
    "text": "We’ll create a products variable to view deeper in the STAC Catalog.\n#\n\nPrint one of the STAC Collection records\nTo view the products variable we just created, let’s look at one entry as a dictionary.\n#\n\n\nPrint the STAC Collection ids with their title\nIn the above output, id and title are two elements of interest that we can print for all products using a for loop.\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#search-for-granulesstac-items---set-up-query-parameters-to-submit-to-the-cmr-stac-api",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#search-for-granulesstac-items---set-up-query-parameters-to-submit-to-the-cmr-stac-api",
    "title": "",
    "section": "Search for Granules/STAC Items - Set up query parameters to submit to the CMR-STAC API",
    "text": "We will define our ROI using the geojson file from the previous exercise, while also specifying the data collections and time range of needed for our example.\n\nRead in a geojson file\nReading in a geojson file with geopandas will return the geometry of our polygon (our ROI).\n#\n\n\nVisualize contents of geojson file\nWe can use that geometry to visualize the polygon: here, a square. But wait for it –\n#\nWe can plot the polygon using the geoviews package that we imported as gv with ‘bokeh’ and ‘matplotlib’ extensions. The following has reasonable width, height, color, and line widths to view our polygon when it is overlayed on a base tile map.\n#\nWe will now start to specify the search criteria we are interested in, i.e, the date range, the ROI, and the data collections, that we will pass to the STAC API.\n\n\nExtract the coordinates for the ROI\n#\nSo, what just happen there? Let’s take a quick detour to break it down.\n\n\n\nSpecify date range\nNext up is to specify our date range using ISO_8601 date formatting.\n#\n\n\nSpecify the STAC Collections\nSTAC Collection is synonomous with what we usually consider a NASA data product. Desired STAC Collections are submitted to the search API as a list containing the collection id. We can use the ids that we printed from our products for loop above. Let’s focus on S30 and L30 collections.\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#search-the-cmr-stac-api-with-our-search-criteria",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#search-the-cmr-stac-api-with-our-search-criteria",
    "title": "",
    "section": "Search the CMR-STAC API with our search criteria",
    "text": "Now we can put all our search criteria together using catalog.search from the pystac_client package.\n#\n\nPrint out how many STAC Items match our search query\n#\nWe now have a search object containing the STAC Items that matched our query. Now, let’s pull out all of the STAC Items (as a PySTAC ItemCollection object) and explore the contents (i.e., the STAC Items)\n#\nLet’s list some of the Items from our pystac item_collection:\n#\nWe can view a single Item as a dictionary, as we did above with STAC Collections/products.\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#filtering-stac-items",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#filtering-stac-items",
    "title": "",
    "section": "Filtering STAC Items",
    "text": "While the CMR-STAC API is a powerful search and discovery utility, it is still maturing and currently does not have the full gamut of filtering capabilities that the STAC API specification allows for. Hence, additional filtering is required if we want to filter by a property, for example cloud cover. Below we will loop through and filter the item_collection by a specified cloud cover as well as extract the band we’d need to do an Enhanced Vegetation Index (EVI) calculation for a future analysis.\nWe’ll make a cloudcover variable where we will set the maximum allowable cloud cover and extract the band links for those Items that match or are less than the max cloud cover.\n#\nWe will also specify the STAC Assets (i.e., bands/layers) of interest for both the S30 and L30 collections (also in our collections variable above).\nIn this hypothetical workflow, we’ll extract the bands needed to calculate an enhanced vegetation index (EVI). Thus, the band needed include red, near infrared (NIR), and blue. We’ll also extract a quality band (i.e., Fmask) that we’d eventually use to perform per-pixel quality filtering.\nNotice that the band ids are in some case not one-to-one between the S30 and the L30 product. This is evident in the NIR band for each product where S30’s NIR band id is B8A and L30’s is B05. Note, the S30 product has an additional NIR band with a band id of B08, but the spectral ranges between B8A and B05 are more closely aligned. Visit the HLS Overview page to learn more about HLS spectral bands.\n#\nAnd now to loop through and filter the item_collection by cloud cover and bands:\n#\nThe filtering done in the previous steps produces a list of links to STAC Assets. Let’s print out the first ten links.\n#\nNOTE that HLS data is mapped to the Universal Transverse Mercator (UTM) projection and is tiled using the Sentinel-2 Military Grid Reference System (MGRS) UTM grid. Notice that in the list of links we have multiple tiles, i.e. T14TKL & T13TGF, that intersect with our region of interest. In this case, these two tiles represent neighboring UTM zones. The tiles can be discern from the file name, which is the last element in a link (far right) following the last forward slash (/) - e.g., HLS.L30.T14TKL.2021133T172406.v1.5.B04.tif. The figure below explains where to find the tile/UTM zone from the file name.\n\nWe will now split the list of links into separate logical sub-lists."
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#split-data-links-list-into-logical-groupings",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#split-data-links-list-into-logical-groupings",
    "title": "",
    "section": "Split Data Links List into Logical Groupings",
    "text": "We have a list of links to data assets that meet our search and filtering criteria. Below we’ll split our list from above into lists first by tile/UTM zone and then further by individual bands bands. The commands that follow will do the splitting with python routines.\n\nSplit by UTM tile specified in the file name (e.g., T14TKL & T13TGF)\n#\n#\n\nPrint dictionary keys and values, i.e. the data links\n#\n#\nNow we will create a separate list of data links for each tile\n#\n\n\nPrint band/layer links for HLS tile T13TGF\n#\n\n\n\nSplit the links by band\n#\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#save-links-to-a-text-file",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#save-links-to-a-text-file",
    "title": "",
    "section": "Save links to a text file",
    "text": "To complete this exercise, we will save the individual link lists as separate text files with descriptive names.\n\nWrite links from CMR-STAC API to a file\n#\n\n\nWrite links to file for S3 access\n#"
  },
  {
    "objectID": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#resources",
    "href": "tutorials-templates/02_Data_Discovery_CMR-STAC_API.html#resources",
    "title": "",
    "section": "Resources",
    "text": "STAC Specification Webpage\nSTAC API Documentation\nCMR-STAC API Github\nhttps://stackoverflow.com/questions/26367812/appending-to-list-in-python-dictionary\nGeopandas\nHLS Overview"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#summary",
    "href": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#summary",
    "title": "",
    "section": "Summary",
    "text": "This tutorial will combine several workflow steps and components from the previous days, demonstrating the process of using the geolocation of data available outside of the Earthdata Cloud to then access coincident variables of cloud-accessible data. This may be a common use case as NASA Earthdata continues to migrate to the cloud, producing a “hybrid” data archive across Amazon Web Services (AWS) and original on-premise data storage systems. Additionally, you may also want to combine field measurements with remote sensing data available on the Earthdata Cloud.\nThis specific example explores the harmonization of the ICESat-2 ATL03 data product, currently (as of November 2021) available publicly via direct download at the NSIDC DAAC, with Sea Surface Temperature variables available from PO.DAAC on the Earthdata Cloud.\n\nObjectives\n[TODO]\n\n\n\nImport packages\n#\n\n\nDetermine storage location of datasets of interest\nFirst, let’s see whether our datasets of interest reside in the Earthdata Cloud or whether they reside on premise, or “on prem” at a local data center.\nBackground from CMR API [TODO: consider removing]: The cloud_hosted parameter can be set to “true” or “false”. When true, the results will be restricted to collections that have a DirectDistributionInformation element or have been tagged with gov.nasa.earthdatacloud.s3.\nWe are building off of the CMR introductory tutorial, beginning with a collection search.\n#\nWe want to search by collection to inspect the access and service options that exist:\n#\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given dataset id (also referred to as a short_name). Here we’ll start with two datasets that we want to explore over a coincident area and time:\n#\nLike in the intro tutorial, we’re going to first determine what concept-ids are returned for the MODIS dataset. First, retrieve collection results based on the MODIS short_name:\n#\nFor each collection result, print out the CMR concept-id and version:\n#\nTwo collections are returned, both at version 2019.0. We can see from the suffix of the id that one is associated with “POCLOUD” versus “PODAAC”. That gives us a clue in terms of where the data are hosted, but we can also use the cloud_hosted parameter set to True to confirm.\n#\n#\nWe will save this concept-id to use later on when we access the data granules.\n#\nNow we will try our ICESat-2 dataset to see what id’s are returned for a given dataset name.\n#\n#\nTwo separate datasets exist in the CMR, one at version 3 and one at version 4. Let’s see if these are cloud_hosted:\n#\n#\nWhen set to False, we get our collections back. We have now determined that we have a copy of the MODIS dataset in the cloud, whereas the ICESat-2 dataset (both versions) remains “on premise”, residing in a local data center.\nSave the ATL03 concept ID and the MODIS GHRSST concept ID to variables:\n#\n\nSpecify time range and area of interest\nWe are going to focus on getting data for an area north of Greenland for a single day in June.\nThese bounding_box and temporal variables will be used for data search, subset, and access below\n#\nPerform a granule search over our time and area of interest. How many granules are returned?\n#\n#\nPrint the file names, size, and links:\n#\n\n\n\nDownload ICESat-2 ATL03 granule\n[TODO] Describe what services are available, including icepyx (provide references), but just direct download for simplicity. Describe that this is being “downloaded” to our cloud environment - what does that mean in terms of cost, etc.\nWe’ve found 2 granules. We’ll download the first one and write it to a file with the same name as the producer_granule_id.\nWe need the url for the granule as well. This is href links we printed out above.\n#\nYou need Earthdata login credentials to download data from NASA DAACs. These are the credentials you stored in the .netrc file you setup in previous tutorials.\nWe’ll use the netrc package to retrieve your login and password without exposing them.\n#\nTo retrieve the granule data, we use the requests.get() method, passing Earthdata login credentials as a tuple using the auth keyword.\n#\nThe response returned by requests has the same structure as all the other responses: a header and contents. The header information has information about the response, including the size of the data we downloaded in bytes.\n#\nThe contents needs to be saved to a file. To keep the directory clean, we will create a downloads directory to store the file. We can use a shell command to do this or use the mkdir method from the os package.\n#\nYou should see a downloads directory in the file browser.\nTo write the data to a file, we use open to open a file. We need to specify that the file is open for writing by using the write-mode w. We also need to specify that we want to write bytes by setting the binary-mode b. This is important because the response contents are bytes. The default mode for open is text-mode. So make sure you use b.\nWe’ll use the with statement context-manager to open the file, write the contents of the response, and then close the file. Once the data in r.content is written sucessfully to the file, or if there is an error, the file is closed by the context-manager.\nWe also need to prepend the downloads path to the filename. We do this using Path from the pathlib package in the standard library.\n#\nCheck to make sure it is downloaded.\n#\nATL03_20190622061415_12980304_004_01.h5 is an HDF5 file. xarray can open this but you need to tell it which group to read the data from. In this case we read the height data for ground-track 1 left-beam.\n#\n\n\nDetermine variables of interest: SST, ocean color, chemistry…\n#\n\n\nPull those variables into xarray “in place”\n\nFirst, we need to determine the granules returned from our time and area of interest\n#\n#\n#\n\n\n\nGet S3 credentials\n#\n#\n\n\nOpen a s3 file\n#\n\n\nUse geolocation of ICESat-2 to define the single transect used to pull coincident ocean data out from array\n\n\nCreate a plot of the single transect of gridded data\n(bonus: time series) - describe what this means to egress out of the cloud versus pulling the original data down (benefit to processing in the cloud)"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "href": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#download-modis-ghrsst-data-from-cloud",
    "title": "",
    "section": "Download MODIS GHRSST data from Cloud",
    "text": "#\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#resources-optional",
    "href": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#resources-optional",
    "title": "",
    "section": "Resources (optional)",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#conclusion",
    "href": "tutorials-templates/Data_Access__Harmonize-cloud-non-cloud.html#conclusion",
    "title": "",
    "section": "Conclusion",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/index.html",
    "href": "tutorials-templates/index.html",
    "title": "Notebooks for live-coding",
    "section": "",
    "text": "Templates of all tutorials — .ipynb notebooks with code removed — are available at:\nhttps://github.com/NASA-Openscapes/2021-Cloud-Hackathon/tree/main/tutorials-templates.\nPlease open these tutorial templates in our JupyterHub to follow along and live-code with the tutorial lead."
  },
  {
    "objectID": "tutorials-templates/09_Zarr_Access.html#summary",
    "href": "tutorials-templates/09_Zarr_Access.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Zarr is an open source library for storing N-dimensional array data. It supports multidimensional arrays with attributes and dimensions similar to NetCDF4, and it can be read by XArray. Zarr is often used for data held in cloud object storage (like Amazon S3), because it is better optimized for these situations than NetCDF4.\nThe zarr-eosdis-store library allows NASA EOSDIS NetCDF4 files to be read more efficiently by transferring only file metadata and data needed for computation in a small number of requests, rather than moving the whole file or making many small requests. It works by making the files directly readable by the Zarr Python library and XArray across a network. To use it, files must have a corresponding metadata file ending in .dmrpp, which increasingly true for cloud-accessible EOSDIS data. https://github.com/nasa/zarr-eosdis-store\nThe zarr-eosdis-store library provides several benefits over downloading EOSDIS data files and accessing them using XArray, NetCDF4, or HDF5 Python libraries:\n\nIt only downloads the chunks of data you actually read, so if you don’t read all variables or the full spatiotemporal extent of a file, you usually won’t spend time downloading those portions of the file\nIt parallelizes and optimizes downloads for the portions of files you do read, so download speeds can be faster in general\nIt automatically interoperates with Earthdata Login if you have a .netrc file set up\nIt is aware of some EOSDIS cloud implementation quirks and provides caching that can save time for repeated requests to individual files\n\nIt can also be faster than using XArray pointing NetCDF4 files with s3:// URLs, depending on the file’s internal structure, and is often more convenient.\nConsider using this library when: 1. The portion of the data file you need to use is much smaller than the full file, e.g. in cases of spatial subsets or reading a single variable from a file containing several 1. s3:// URLs are not readily available 1. Code need to run outside of the AWS cloud or us-west-2 region or in a hybrid cloud / non-cloud manner 1. s3:// access using XArray seems slower than you would expect (possibly due to unoptimized internal file structure) 1. No readily-available, public, cloud-optimized version of the data exists already. The example we show is also available as an AWS Public Dataset: https://registry.opendata.aws/mur/ 1. Adding “.dmrpp” to the end of a data URL returns a file\n\nObjectives\n\nBuild on prior knowledge from CMR and Earthdata Login tutorials\nWork through an example of using the EOSDIS Zarr Store to access data using XArray\nLearn about the Zarr format and library for accessing data in the cloud ___"
  },
  {
    "objectID": "tutorials-templates/09_Zarr_Access.html#exercise",
    "href": "tutorials-templates/09_Zarr_Access.html#exercise",
    "title": "",
    "section": "Exercise",
    "text": "In this exercise, we will be using the eosdis-zarr-store library to aggregate and analyze a month of sea surface temperature for the Great Lakes region\n\nSet up\n\nImport Required Packages\n#\nAlso set the width / height for plots we show\n#\n\n\nSet Dataset, Time, and Region of Interest\nLook in PO.DAAC’s cloud archive for Group for High Resolution Sea Surface Temperature (GHRSST) Level 4 Multiscale Ultrahigh Resolution (MUR) data\n#\nLooking for data from the month of September over the Great Lakes\n#\n\n\n\nFind URLs for the dataset and AOI\nSet up a CMR granules search for our area of interest, as we saw in prior tutorials\n#\nSearch for granules in our area of interest, expecting one granule per day of September\n#\n#\n#\n#\n\n\nOpen and view our AOI without downloading a whole file\n\nCheck to see if we can use an efficient partial-access technique\n#\nOpen our first URL using the Zarr library\n#\nThat’s it! No downloads, temporary credentials, or S3 filesystems. Hereafter, we interact with the ds variable as with any XArray dataset. We need not worry about the EosdisStore anymore.\nView the file’s variable structure\n#\n#\n#\n#\n\n\n\nAggregate and analyze 30 files\nSet up a function to open all of our URLs as XArrays in parallel\n#\nCombine the individual file-based datasets into a single xarray dataset with a time axis\n#\nLook at the Analysed SST variable metadata\n#\nCreate a dataset / variable that is only our area of interest and view its metadata\n#\nXArray reads data lazily, i.e. only when our code actually needs it. Up to this point, we haven’t read any data values, only metadata. The next line will force XArray to read the portions of the source files containing our area of interest. Behind the scenes, the eosdis-zarr-store library is ensuring data is fetched as efficiently as possible.\nNote: This line isn’t strictly necessary, since XArray will automatically read the data we need the first time our code tries to use it, but calling this will make sure that we can read the data multiple times later on without re-fetching anything from the source files.\nThis line will take several seconds to complete, but since it is retrieving only about 50 MB of data from 22 GB of source files, several seconds constitutes a significant time, bandwidth, and disk space savings.\n#\nNow we can start looking at aggregations across the time dimension. In this case, plot the standard deviation of the temperature at each point to get a visual sense of how much temperatures fluctuate over the course of the month.\n#\n\nInteractive animation of a month of data\nThis section isn’t as important to fully understand. It shows us a way to get an interactive animation to see what we have retrieved so far\nDefine an animation function to plot the ith time step. We need to make sure each plot is using the same color scale, set by vmin and vmax so the animation is consistent\n#\nRender each time slice once and show it as an HTML animation with interactive controls\n#\n\n\n\nSupplemental: What’s happening here?\nFor EOSDIS data in the cloud, we have begun producing a metadata sidecar file in a format called DMR++ that extracts all of the information about arrays, variables, and dimensions from data files, as well as the byte offsets in the NetCDF4 file where data can be found. This information is sufficient to let the Zarr library read data from our NetCDF4 files, but it’s in the wrong format. zarr-eosdis-store knows how to fetch the sidecar file and transform it into something the Zarr library understands. Passing it when reading Zarr using XArray or the Zarr library lets these libraries interact with EOSDIS data exactly as if they were Zarr stores in a way that’s more optimal for reading data in the cloud. Beyond this, the zarr-eosdis-store library makes some optimizations in the way it reads data to help make up for situations where the NetCDF4 file is not internally arranged well for cloud-based access patterns."
  },
  {
    "objectID": "tutorials-templates/S6_OPeNDAP_Access_Gridding.html#getting-started",
    "href": "tutorials-templates/S6_OPeNDAP_Access_Gridding.html#getting-started",
    "title": "",
    "section": "Getting Started",
    "text": "Summary\nDescription goes here…\n\n\nObjectives\nIn this tutorial you will learn…\n\nabout level 2 radar altimetry data from the Sentinel-6 Michael Freilich mission;\nhow to efficiently download variable subsets using OPeNDAP;\nhow to grid the along-track altimetry observations produced by S6 at level 2.;\n\n\n\nRequirements\nThis workflow was developed using Python 3.9 (and tested against versions 3.7, 3.8).\nimport os\nimport os.path\nimport json\nimport warnings\nimport requests\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nfrom tqdm import tqdm\nfrom io import StringIO\nfrom concurrent.futures import ThreadPoolExecutor\nwarnings.filterwarnings(\"ignore\")\nimport pyresample as pr\nfrom pyresample.kd_tree import resample_gauss\n\n\nWorkspace\nCreate some directories inside a temporary user workspace. They will be used to write outputs.\n\nhttps://docs.python.org/3/library/os.html#os.makedirs"
  },
  {
    "objectID": "tutorials-templates/S6_OPeNDAP_Access_Gridding.html#datasets",
    "href": "tutorials-templates/S6_OPeNDAP_Access_Gridding.html#datasets",
    "title": "",
    "section": "Dataset(s)",
    "text": "This example operates on Level 2 Low Resolution Altimetry from Sentinel-6 Michael Freilich (the Near Real Time Reduced distribution). It is most easily identified by its collection ShortName, given below:\nShortName = 'JASON_CS_S6A_L2_ALT_LR_RED_OST_NRT_F'\n\ncollection\nGet metadata about the collection from the CMR.\nGet the collection’s concept-id from the record’s meta object. It uniquely identifies the collection in the CMR and is a component of the OPeNDAP endpoints for its granules.\n\nhttps://docs.python-requests.org/en/latest/api/#requests.get\n\n\n\ngranules\nGet metadata about the granules in the collection from the CMR.\n\nhttps://docs.python.org/3/library/io.html#io.StringIO\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html\nhttps://docs.python-requests.org/en/latest/api/#requests.get\n\nLoad the results to a data frame.\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html\n\nDisplay the list of items created by splitting the a value in the Granule UR field.\nReferences:\nhttps://docs.python.org/3/library/stdtypes.html#str.split\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html\nNote that cycle and pass are items 8 and 9, respectively, after splitting the Granule UR field by _. Add two columns containing the cycle/pass numbers for granules in the table.\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.copy.html\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.apply.html\nhttps://docs.python.org/3/reference/expressions.html#lambda\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html\n\nNow create a table with one row per cycle and with these columns:\n\nstart time\nend time\ngranule names (list)\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.to_frame.html\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html\n\n\n\nPick a cycle of interest\nPick one cycle that is nearly complete, >= 120 orbits/files. Limit options to cycles with at least 120 granules/files available (i.e. orbits in S6 context).\nChoose from the nearly-complete cycles that remain in the table, which start with cycle number 023 for S6 data in the public domain (and start on June 22). Slice the table of granules to exclude all rows that are not from the cycle of interest.\nmy_cycle = int\n\n\nOPeNDAP Access Endpoints\nAll endpoints for granules/files in OPeNDAP/Hyrax start with the server hostname and path to the parent collection, followed by granules. The collection is specified by the concept-id given right after collections in a valid url. The next cell formats a string giving the base url to which we will append granule filenames (stored in the Granule UR column of the granules table) to get the full url/endpoint for each granule.\nFyi, the url printed by this cell will not be accessible from your web browser.\n\nhttps://docs.python.org/3/library/string.html#format-string-syntax\n\nAppending the granule name (taken from the Granule UR column) to the end of the url above results in a valid endpoint. You can click the one printed by this cell to confirm. A new browser tab should open to the HTML access form served by Hyrax/OPeNDAP.\nMake a new column with the nc4 download url for all granules.\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html\n\n\nPick target data/coordinate variables\nDisplay the url to access the DDS file for the first granule:\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.iloc.html\n\nAssemble the list of target variables that you will subset from each granule/file using OPeNDAP.\n\nhttps://docs.python.org/3/library/stdtypes.html#list\n\nJoin the list of variables with commas and append the resulting string to the end of each opendap nc4 endpoint created during the steps above. The variables given after the ? will be subset from the source file on the server-side into a new netCDF4 file that OPeNDAP returns in response content which is downloaded over https.\nHere’s an example for the first granule in the selected cycle. Clicking this link should download a netCDF4 containing the target variables (4 of them, in my case). *You may be prompted to authenticate with your Earthdata Login account info.\n\nhttps://opendap.github.io/documentation/UserGuideComprehensive.html#Constraint_Expressions (Hyrax/OPeNDAP docs)\n\n\n\n\nDownload subsets\nThis function downloads one granule from the remote url to a local target path, and will reliably manage simultaneous streaming downloads divided between multiple threads.\ndef download(url: str, target: str, force: bool=False):\n    if not os.path.isfile(target) or force is True:\n        with requests.get(url) as response, open(target, 'wb') as file:\n            if not response.status_code // 100 == 2: \n                raise Exception(response.text)\n            for chunk in response.iter_content(chunk_size=1024):\n                if chunk:\n                    file.write(chunk)\n    return target\n\nhttps://docs.python.org/3/library/os.path.html#os.path.isfile\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.text\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.status_code\nhttps://docs.python-requests.org/en/latest/api/#requests.Response.iter_content\n\n#!ls data/subsets/*NR_025*.nc4 | wc -l\n#!rm data/subsets/*NR_025*.nc4\nThis next cell assembles a list of local paths for the subset downloads.\nCalling tolist on the resulting Series will convert it to a Python list (by way of the numpy method, tolist). Use zip merge the lists of subset urls and local paths, itemwise. The result will be a list of lists, each length two and containing a remote url and local path (corresponding to two positional arguments in the download function that will be defined in a subsequent cell).\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.tolist.html\n\nThis next cell creates a pool of workers to divide the list of downloads between multiple threads.\nUse the ThreadPoolExecutor from concurrent.futures module (in the Python 3 standard library) to divide the 120+ download jobs between multiple threads and run them concurrently. This should take no more than a minute or two to process all subsets on the server side and download to the local host.\nwith ThreadPoolExecutor(max_workers=12) as pool:\n    \n    workers = pool.map(lambda x: download(*x), download_arguments)\n    \n    granules['local'] = list(tqdm(workers, total=len(download_arguments)))\n\nhttps://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor\n\nThe source files range from 2.5MB to 3.0MB. These OPeNDAP subsets are ~100KB apiece. (anecdote: it took less than 10 minutes to download subsets for >1700 granules/files when I ran this routine for all cycles going back to 2021-06-22.) Here we call the shell du and ls utilities to get the size of the directory:\n%%bash\n#ls\n#du\n\nhttps://www.gnu.org/software/coreutils/manual/html_node/du-invocation.html\n\nConfirm that a netcdf file exists on disk for all the file paths in the local column.\n\nhttps://docs.python.org/3/library/functions.html#sorted\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.all.html\n\n\n\nAggregate to cycle\nMake a dictionary to rename variables so that the data_01_ prefix is removed from each one.\nReferences:\nhttps://docs.python.org/3/library/functions.html#map\nhttps://docs.python.org/3/library/functions.html#zip\nSort the list of local paths to the downloaded subsets to ensure they concatenate in proper order. Call open_mfdataset on the list to open all the subsets in memory as one dataset in xarray.\n\nhttps://tqdm.github.io/docs/tqdm/#pandas\nhttps://xarray.pydata.org/en/stable/generated/xarray.open_mfdataset.html\nhttps://xarray.pydata.org/en/stable/generated/xarray.Dataset.rename.html\n\n\n\nRender along-track altimetry data to the ECCO grid\n\nAcknowledgement This approach using pyresample was shared to me by Ian Fenty, ECCO Lead.\n\nECCO V4r4 products are distributed in two spatial formats. One set of collections provides the ocean state estimates on the native model grid (LLC0090) and the other provides them after interpolating to a regular grid defined in geographic coordinates with horizontal cell size of 0.5-degrees.\n\nDownload the ECCO V4r4 0.5-Deg Grid Geometry and Mask\nIt’s distributed as its own dataset/collection containing just one file. We can access it over OPeNDAP like demonstrated above or simply download it from the HTTPS download endpoint – the file size is inconsequential. The next cell downloads the file into the data folder from the granule’s https endpoint.\n\nhttps://docs.python.org/3/library/os.path.html#os.path.basename\nhttps://xarray.pydata.org/en/stable/generated/xarray.open_dataset.html\n\nThe maskC variable contains a boolean mask representing the wet/dry state of the area contained in each cell of the 3d grid defined by Z and latitude and longitude.\nHere are the variable’s attributes:\nSo, the mask derives from another variable hFacC that essentially describes 3d space/volume contained within each model grid cell by the fractional area representing the horizontal coverage (in the longitude,latitude dimensions) within each vertical/depth layer.\nSelect the 2d array from maskC that corresponds to the depth layer at ocean surface (i.e. at index 0 on the Z axis/dimension) and then produce a boolean array where True represents cells with a value greater than 0. The resulting array/grid is our land/water mask for the 2d grids generated during the next few steps.\nPlot the land/water mask:\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.isel.html\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.html\n\n\n\n\nGrid ssha or a similar variable\nJinbo’s recommendation: wrap this logic for parameterization by workshop attendees.\nGet a single timestamp to represent the midpoint of the cycle.\nAccess the target variable, ssha in this case, and make a nan mask.\nDefine a simple function get_grid_defn to validate input arrays of longitudes/latitudes and return a pyresample.geometry.SwathDefinition object. (We use it twice to define source/target grids in the next steps.)\nDefine source grid/geometry for the input along-track data. (They are stored as 1-dimensional arrays.)\nDefine target grid based on the longitudes and latitudes from the ECCO grid geometry dataset. This time define the grid using two 2-dimensional arrays that give positions of all SSHA values in geographic/longitude-latitude coordinates.\nMake the pyresample object for the target grid and proceed.\nShow the help for pyresample.kdtree.resample_gauss to aid during the hackathon.\n#help(resample_gauss)\nGet the target grid definition defined by the 2d arrays of lons and lats created in the cell above. Apply gaussian resampling with some optional arguments (borrowed from Ian’s implementation).\nApply the land/water mask in the numpy array created from the ECCO layer in the steps above. Then, convert the masked numpy array to an xarray data array object named gridded. Print its header.\n#ssha, stddev, counts\nPlot the resulting arrays with xarray.\n#ssha\n#stddev\n#counts\nAdditional References:\n\nnumpy (https://numpy.org/doc/stable/reference)\n\nnumpy.ndarray.data\n\nnumpy.ravel\n\nnumpy.where\n\nnumpy.isnan\n\ndatetimes\n\n\nxarray (https://xarray.pydata.org/en/stable)\n\nxarray.DataArray\n\nxarray.DataArray.values\n\nxarray.DataArray.mean\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.pcolormesh.html (matplotlib)\n\n\npyresample (https://pyresample.readthedocs.io/en/latest/api/pyresample)\n\npyresample.utils.check_and_wrap\n\npyresample.kd_tree.resample_gauss\n\npyresample.geometry.SwathDefinition\n\n\nBonus: generate a grid for every cycle and get mean/std over all the cycles\nstack = xr.concat(data['grid'].tolist(), dim=\"time\")\n\nmidlat = stack.sel(latitude=slice(-66.,66.0))\n\nstats = xr.concat(objs=[midlat.mean(\"time\"),\n                        midlat.std(\"time\") ], \n                  dim=pd.Index(['mean','std'], name=\"stat\"))\n\nhttps://xarray.pydata.org/en/stable/generated/xarray.concat.html\n\nBonus: calculate area-weighted mean\ndef to_area_weighted_mean(x):\n    nonzero_mask = np.where(~np.isnan(x), 1, np.nan)            # mask where nans=0 & ~nans=1\n    nonzero_area = np.sum(nonzero_mask * ecco_grid.area)        # total area where data is nonzero\n    return float(np.nansum(x * ecco_grid.area) / nonzero_area)  # area-weighted global mean\n\nhttps://numpy.org/doc/stable/reference/generated/numpy.sum.html\nhttps://numpy.org/doc/stable/reference/generated/numpy.nansum.html"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#summary",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In the previous exercises we searched for and discovered cloud data assets that met certain search criteria (i.e., intersects with our region of interest and for a specified date range). The end goal was to find and save web links to the data assets we want to use in our workflow. The links we found allow us to download data via HTTPS (Hypertext Transfer Protocol Secure). However, NASA allows for direct in-region S3 bucket access for the same assets. In addition to saving the HTTPS links, we also created and saved the S3 links for those same cloud assets and we will use them here. In this exercise we will demonstrate how to perform direction in-region S3 bucket access for Harmonized Landsat Sentinel-2 (HLS) cloud data assets.\n\nDirect S3 Access\nNASA Eartdata Cloud provides two pathways for accessing data from the cloud. The first is via HTTPS. The other is through direct S3 bucket access. Below are some benefits and considerations when choosing to use direct S3 bucket access for NASA cloud assets.\n\nBenefits\n\nRetrieve data is very quickly\nNo need to download data! Work with data in a more efficient manner\nIncreased capacity to do parallel processing\nYou are working completely with the AWS cloud ecosystem and thus have access to the might of all AWS offerings (e.g., infrastructure, S3 API, services, etc.)\n\n\n\nConsiderations\n\nAccess only works within AWS us-west-2 region\nNeed an AWS S3 “token” to access S3 Bucket\nToken expires after 1 hour\nToken only works at the DAAC that generates it, e.g.,\n\nPO.DAAC token generator: https://archive.podaac.earthdata.nasa.gov/s3credentials\nLP DAAC token generator: https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials\n\nS3 on its own does not solve ‘cloud’ problems, but it is one key technology in solving big data problems\nStill have to load things in to memory, parallelize the computation, if working with really large data volumes. There are a lot of tool that allow you to do that, not discussed in this tutorial\n\n\n\n\nObjective\n\nConfigure our notebook environment and retrieve temporary S3 credentials for in-region direct S3 bucket access\nAccess a single HLS file\nAccess and clip an HLS file to a region of interest\nCreate an HLS time series data array\n\nLet’s get started!\n\n\n\nImport Required Packages\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#configure-local-environment-and-get-temporary-credentials",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#configure-local-environment-and-get-temporary-credentials",
    "title": "",
    "section": "Configure Local Environment and Get Temporary Credentials",
    "text": "To perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME. A netrc file is required to aquire these credentials. Use the NASA Earthdata Authentication to create a netrc file in your home directory.\n#\n#\n#\n\nInsert the credentials into our boto3 session and configure our rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session is used to pass credentials and configuration to AWS so we can interact wit S3 objects from applicable buckets.\n#\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-s3-links",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-s3-links",
    "title": "",
    "section": "Read in S3 Links",
    "text": "In the CMR-STAC API tutorial we saved off multiple text file containing links, both HTTPS and S3 links, to Harmonized Landsat Sentinel-2 (HLS) cloud data assets. We will now read in one of those file and show how to access those data assets.\n\nList the available files in the data directory\n#\nWe will safe our list of links and a single link as Python objects for use later.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-a-single-hls-file",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-a-single-hls-file",
    "title": "",
    "section": "Read in a single HLS file",
    "text": "We’ll access the HLS S3 object using the rioxarray Python package. The package is an extension of xarray and rasterio, allowing users to read in and interact with geospatial data using xarray data structures. We will also be leveraging the tight integration between xarray and dask to lazily read in data via the chunks parameter. This allows us to connect to the HLS S3 object, reading only metadata, an not load the data into memory until we request it via the loads() function.\n#\nWhen GeoTIFFS/Cloud Optimized GeoTIFFS are read in, a band coordinate variable is automatically created (see the print out above). In this exercise we will not use that coordinate variable, so we will remove it using the squeeze() function to avoid confusion.\n#\n\nPlot the HLS S3 object\n#\nWe can print out the data value as a numpy array by typing .values\n#\nUp to this point, we have not saved anything but metadata into memory. To save or load the data into memory we can call the .load() function.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-a-single-hls-file",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-a-single-hls-file",
    "title": "",
    "section": "Read in and clip a single HLS file",
    "text": "To clip the HLS file, our feature representing our region of interest must be in the same coordinate reference system (CRS) or projection coordinate system as the HLS file. The map projection for our HLS file is Universal Transverse Mercator (UTM) zone 13N. Our feature is mapped to WGS84 geographic coordinate system grid space. We need to transform the geographic coordinate reference system (CRS) of our feature to the UTM projected coordinate system (i.e., UTM Zone 13N)\n\nRead in our geojson file and transform its CRS\n#\nLet’s take a look at the bounding coordinate values.\n#\nNote, the values above are in decimal degrees and represent the longitude and latitude for the lower left corner (-101.67271614074707, 41.04754380304359) and upper right corner (-101.65344715118408, 41.06213891056728) respectively.\n\n\nGet the projection information from the HLS file\n#\n\n\nTransform coordinates from lat lon (units = dd) to UTM (units = m)\n#\n#\n#\nThe coordinates for our feature have now been converted to UTM Zone 13N whether meters is the designated unit. Note the difference in the values between field_shape.bounds (in geographic) and fsUTM.bounds (in UTM projection).\nNow we can clip our HLS file to our region of insterest!\n\n\nAccess and clip the HLS file\nWe can now use our transformed ROI bounding box to clip the HLS S3 object we accessed before. We’ll use the `rio.clip\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-an-hls-time-series",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#read-in-and-clip-an-hls-time-series",
    "title": "",
    "section": "Read in and clip an HLS time series",
    "text": "Now we’ll read in multiple HLS S3 objects as a time series xarray. Let’s print the links list again to see what we’re working with.\n#\nCurrently, the utilities and packages used in Python to read in GeoTIFF/COG file do not recognize associated dates stored in the internal metadata. To account for the dates for each file we must create a time variable and add it as a dimension in our final time series xarray. We’ll create a function that extracts the date from the file link and create an xarray variable with a time array of datetime objects.\n#\n#\nWe’ll now specify a chunk size to use that matches the internal tiling of HLS files. This will help improve performance.\n#\nNow, we will create our time series.\n#\nSince we used the chunks parameter while reading the data, the hls_ts_da object is read into memory. To do that we’ll use the load() function. But, before that, we’ll clip the hls_ts_da object to our roi using our transformed roi coordinates.\n#\nNow, we’ll see what we have. Use hvplot to plot the clipped time series\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#resourses",
    "href": "tutorials-templates/Additional_Resources__Direct_S3_Access__rioxarray_clipping.html#resourses",
    "title": "",
    "section": "Resourses",
    "text": "Build time series from multiple GeoTIFF files\nHvplot/Holoview Colormap\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/lpdaac_cloud_data_access/browse\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/hls-tutorial/browse"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#timing",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#timing",
    "title": "",
    "section": "Timing",
    "text": "Exercise: 20 minutes"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#summary",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#summary",
    "title": "",
    "section": "Summary",
    "text": "In the previous exercises we searched for and discovered cloud data assets that met certain search criteria (i.e., intersects with our region of interest and for a specified date range). The end goal was to find and save web links to the data assets we want to use in our workflow. The links we found allow us to download data via HTTPS (Hypertext Transfer Protocol Secure). However, NASA allows for direct in-region S3 bucket access for the same assets. In addition to saving the HTTPS links, we also created and saved the S3 links for those same cloud assets and we will use them here. In this exercise we will demonstrate how to perform direction in-region S3 bucket access for Harmonized Landsat Sentinel-2 (HLS) cloud data assets.\n\nDirect S3 Access\nNASA Eartdata Cloud provides two pathways for accessing data from the cloud. The first is via HTTPS. The other is through direct S3 bucket access. Below are some benefits and considerations when choosing to use direct S3 bucket access for NASA cloud assets.\n\nBenefits\n\nRetrieve data is very quickly\n\nNo need to download data! Work with data in a more efficient manner\n\nIncreased capacity to do parallel processing\n\nYou are working completely with the AWS cloud ecosystem and thus have access to the might of all AWS offerings (e.g., infrastructure, S3 API, services, etc.)\n\n\n\nConsiderations\n\nIf you’re workflow is in the cloud, choose S3 over HTTPS\n\nAccess only works within AWS us-west-2 region\n\nNeed an AWS S3 “token” to access S3 Bucket\n\nToken expires after 1 hour\n\nToken only works at the DAAC that generates it, e.g.,\n\nPO.DAAC token generator: https://archive.podaac.earthdata.nasa.gov/s3credentials\n\nLP DAAC token generator: https://data.lpdaac.earthdatacloud.nasa.gov/s3credentials\n\n\nS3 on its own does not solve ‘cloud’ problems, but it is one key technology in solving big data problems\n\nStill have to load things in to memory, parallelize the computation, if working with really large data volumes. There are a lot of tool that allow you to do that, not discussed in this tutorial"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#what-you-will-learn-from-this-tutorial",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#what-you-will-learn-from-this-tutorial",
    "title": "",
    "section": "What you will learn from this tutorial",
    "text": "how to retrieve temporary S3 credentials for in-region direct S3 bucket access\n\nhow to configure our notebook environment for in-region direct S3 bucket access\n\nhow to access a single HLS file via in-region direct S3 bucket access\n\nhow to create an HLS time series data array from cloud assets via in-region direct S3 bucket access\n\nhow to plot results\n\nThis exercise can be found in the 2021 Cloud Hackathon Book"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#import-required-packages",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#import-required-packages",
    "title": "",
    "section": "Import Required Packages",
    "text": "#"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#configure-local-environment-and-get-temporary-credentials",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#configure-local-environment-and-get-temporary-credentials",
    "title": "",
    "section": "Configure Local Environment and Get Temporary Credentials",
    "text": "To perform direct S3 data access one needs to acquire temporary S3 credentials. The credentials give users direct access to S3 buckets in NASA Earthdata Cloud. AWS credentials should not be shared, so take precautions when using them in notebooks our scripts. Note, these temporary credentials are valid for only 1 hour. For more information regarding the temporary credentials visit https://data.lpdaac.earthdatacloud.nasa.gov/s3credentialsREADME. A netrc file is required to aquire these credentials. Use the NASA Earthdata Authentication to create a netrc file in your home directory.\n#\n#\n#\n\nInsert the credentials into our boto3 session and configure our rasterio environment for data access\nCreate a boto3 Session object using your temporary credentials. This Session is used to pass credentials and configuration to AWS so we can interact wit S3 objects from applicable buckets.\n#\nFor this exercise, we are going to open up a context manager for the notebook using the rasterio.env module to store the required GDAL and AWS configurations we need to access the data in Earthdata Cloud. While the context manager is open (rio_env.__enter__()) we will be able to run the open or get data commands that would typically be executed within a with statement, thus allowing us to more freely interact with the data. We’ll close the context (rio_env.__exit__()) at the end of the notebook.\nGDAL environment variables must be configured to access Earthdata Cloud data assets. Geospatial data access Python packages like rasterio and rioxarray depend on GDAL, leveraging GDAL’s “Virtual File Systems” to read remote files. GDAL has a lot of environment variables that control it’s behavior. Changing these settings can mean the difference being able to access a file or not. They can also have an impact on the performance.\n#"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-s3-links",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-s3-links",
    "title": "",
    "section": "Read in S3 Links",
    "text": "In the CMR-STAC API tutorial we saved off multiple text file containing links, both HTTPS and S3 links, to Harmonized Landsat Sentinel-2 (HLS) cloud data assets. We will now read in one of those file and show how to access those data assets.\n\nList the available files in the data directory\n#\nWe will safe our list of links and a single link as Python objects for use later.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-a-single-hls-file",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-a-single-hls-file",
    "title": "",
    "section": "Read in a single HLS file",
    "text": "We’ll access the HLS S3 object using the rioxarray Python package. The package is an extension of xarray and rasterio, allowing users to read in and interact with geospatial data using xarray data structures. We will also be leveraging the tight integration between xarray and dask to lazily read in data via the chunks parameter. This allows us to connect to the HLS S3 object, reading only metadata, an not load the data into memory until we request it via the loads() function.\n#\nWhen GeoTIFFS/Cloud Optimized GeoTIFFS are read in, a band coordinate variable is automatically created (see the print out above). In this exercise we will not use that coordinate variable, so we will remove it using the squeeze() function to avoid confusion.\n#\n\nPlot the HLS S3 object\n#\nWe can print out the data value as a numpy array by typing .values\n#\nUp to this point, we have not saved anything but metadata into memory. To save or load the data into memory we can call the .load() function.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-hls-as-a-time-series",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#read-in-hls-as-a-time-series",
    "title": "",
    "section": "Read in HLS as a time series",
    "text": "Now we’ll read in multiple HLS S3 objects as a time series xarray. Let’s print the links list again to see what we’re working with.\n#\nCurrently, the utilities and packages used in Python to read in GeoTIFF/COG file do not recognize associated dates stored in the internal metadata. To account for the dates for each file we must create a time variable and add it as a dimension in our final time series xarray. We’ll create a function that extracts the date from the file link and create an xarray variable with a time array of datetime objects.\n#\n#\nWe’ll now specify a chunk size to use that matches the internal tiling of HLS files. This will help improve performance.\n#\nNow, we will create our time series.\n#\nSince we used the chunks parameter while reading the data, the hls_ts_da object is not read into memory yet. To do that we’ll use the load() function.\nNow, we’ll see what we have. Use hvplot to plot our time series\n#\n#\n#"
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#concluding-remarks",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#concluding-remarks",
    "title": "",
    "section": "Concluding Remarks",
    "text": "The above exercise demonstrated how to perform in-region direct S3 bucket access for HLS cloud data assets. HLS cloud data assets are stored as Cloud Optimized GeoTIFFs, a format that has been the benifactor of data discovery and access advancements within the Python ecosystem. Knowing what the data storage format is (e.g., COG, netcdf4, or zarr store) and/or what data access protocol you’re using is critical in determining what Python data access method you will use. For COG data, rioxarray package is often prefered due to is ability to bring the geospatial data format into an xarray object. For netcdf4 files, the standard xarray package incombination with s3fs allow users to perform in-region direct access reads into an xarray object. Finally, if you are using OPeNDAP to connect to data, specialized packages like pydap have been integrated into xarray for streamline access directly to an xarray object."
  },
  {
    "objectID": "tutorials-templates/05_Data_Access_Direct_S3.html#resourses",
    "href": "tutorials-templates/05_Data_Access_Direct_S3.html#resourses",
    "title": "",
    "section": "Resourses",
    "text": "Build time series from multiple GeoTIFF files\nHvplot/Holoview Colormap\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/lpdaac_cloud_data_access/browse\nhttps://git.earthdata.nasa.gov/projects/LPDUR/repos/hls-tutorial/browse"
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "title": "",
    "section": "Using the Harmony-Py library to access customized data from NASA Earthdata",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#summary",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Harmony allows you to seamlessly analyze Earth observation data from different NASA data centers… https://harmony.earthdata.nasa.gov/\n\nBenefits\n\nConsistent access patterns to EOSDIS holdings make cross-data center data access easier\nData reduction services allow users to request only the data they want, in the format and projection they want\nAnalysis Ready Data and cloud access will help reduce time-to-science\nCommunity Development helps reduce the barriers for re-use of code and sharing of domain knowledge\n\nHarmony-Py is a Python library for integrating with NASA’s Harmony Services.\nHarmony-Py provides a Python alternative to directly using Harmony’s RESTful API. It handles NASA Earthdata Login (EDL) authentication and optionally integrates with the CMR Python Wrapper by accepting collection results as a request parameter. It’s convenient for scientists who wish to use Harmony from Jupyter notebooks as well as machine-to-machine communication with larger Python applications.\n\n\nObjectives\n\nPractice skills learned from intro to CMR tutorial to discover what access and service options exist for a given data set"
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#import-packages",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#import-packages",
    "title": "",
    "section": "Import Packages",
    "text": "#"
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "title": "",
    "section": "Discover service options for a given data set",
    "text": "First, what do we mean by a “service”? [TODO] Describe how we define services and their benefits, and how not all datasets have services on them due to level of support, etc….\nLet’s see what the collection metadata tells us\n\nBuilding off of CMR introduction tutorial:\n#\nWe want to search by collection to inspect the access and service options that exist:\n#\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given data set id (also referred to as a short_name).\nHere we are jumping ahead and already know the concept_id we are interested in, by browsing cloud-hosted datasets from PO.DAAC in Earthdata Search: https://search.earthdata.nasa.gov/portal/podaac-cloud/search.\nWe are going to focus on MODIS_A-JPL-L2P-v2019.0: GHRSST Level 2P Global Sea Surface Skin Temperature from the Moderate Resolution Imaging Spectroradiometer (MODIS) on the NASA Aqua satellite (GDS2). Let’s first save this as a variable that we can use later on once we request data from Harmony.\n#\nWe will view the top-level metadata for this collection to see what additional service and variable metadata exist.\n#\nPrint the response:\n#\nLet’s walk through what each of these service values mean:\n\nAssociations\n\nCMR is a large web of interconnected metadata “schemas”, including Collections, Granules, Services, Tools, and Variables. In this case, this collection is associated with two unique services, two tools, and several unique variables.\n\nTags\n\nThere are also tags that describe what service options exist at a high-level. In this case, we see that this dataset supports the ability to reformat, subset by space and time, as well as by variable. This is used in web applications like Earthdata Search to surface those customization options more readily.\n\nService Features\n\nIn this case, we see three separate “features” listed here: esi, Harmony, and OPeNDAP.\n\n\nWe will dig into more details on what Harmony offers for this dataset.\nFirst, we need to isolate the services returned for this dataset:\n#\n#\nInspect the first service returned. Now we’re going to search the services endpoint to view that individual service’s metadata, like we did with our dataset above.\nTODO: Explain why we need the output format in umm_json\n#\n#\n#\nTODO: Describe these different service options and broader Harmony / backend subsetter context."
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#discover-variable-names",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#discover-variable-names",
    "title": "",
    "section": "Discover variable names",
    "text": "TODO: Could this be an “exercise” to gain more familiarity with CMR?\n#\n#\n#\n#\nLet’s print out a simple list of all associated variable names.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#harmony-py-set-up",
    "href": "tutorials-templates/07_Data_Access_Harmony_Subsetting.html#harmony-py-set-up",
    "title": "",
    "section": "Harmony-Py set up",
    "text": "[TODO] Describe Harmony-Py in more detail (connection between the library and the API).\nNext steps adopted from the intro tutorial notebook in the Harmony-Py library: https://github.com/nasa/harmony-py/blob/main/examples/intro_tutorial.ipynb\n\nCreate Harmony Client object\nFirst, we need to create a Harmony Client, which is what we will interact with to submit and inspect a data request to Harmony, as well as to retrieve results.\nWhen creating the Client, we need to provide Earthdata Login credentials, which are required to access data from NASA EOSDIS. This basic line below assumes that we have a .netrc available.\n#\n\n\nCreate Harmony Request\nThe following are common request parameters:\n\ncollection: Required parameter. This is the NASA EOSDIS collection, or data product. There are two options for inputting a collection of interest:\n\nProvide a concept ID, which is an ID provided in the Common Metadata Repository (CMR) metadata\nData product short name (e.g. SENTINEL-1_INTERFEROGRAMS).\n\nspatial: Bounding box spatial constraints on the data. The Harmony Bbox class accepts spatial coordinates as decimal degrees in w, s, e, n order, where longitude = -180, 180 and latitude = -90, 90.\ntemporal: Date/time constraints on the data. The example below demonstrates temporal start and end ranges using the python datetime library.\n\nOther advanced parameters that may be of interest. Note that many reformatting or advanced projection options may not be available for your requested dataset. See the documentation for details on how to construct these parameters.\n[TODO] Describe area/time use case with this dataset - maybe demonstrating Earthdata Search for browsing??\n#\n\n\nCheck Request validity\nBefore submitting a Harmony Request, we can test your request to see if it’s valid and how to fix it if not. In particular, request.is_valid will check to ensure that the spatial BBox bounds and temporal ranges are entered correctly.\n#\n\n\nSubmit request\nNow that the request is created, we can now submit it to Harmony using the Harmony Client object. A job id is returned, which is a unique identifier that represents the submitted request.\n#\n\n\nCheck request status\nWe can check on the progress of a processing job with status(). This method blocks while communicating with the server but returns quickly.\n#\nDepending on the size of the request, it may be helpful to wait until the request has completed processing before the remainder of the code is executed. The wait_for_processing() method will block subsequent lines of code while optionally showing a progress bar.\n#\n\n\nView Harmony job response and output URLs\nOnce the data request has finished processing, we can view details on the job that was submitted to Harmony, including the API call to Harmony, and informational messages on the request if available.\nresult_json() calls wait_for_processing() and returns the complete job in JSON format once processing is complete.\n#\n\n\nDirect cloud access\nNote that the remainder of this tutorial will only succeed when running this notebook within the AWS us-west-2 region.\nHarmony data outputs can be accessed within the cloud using the s3 URLs and AWS credentials provided in the Harmony job response.\n\nRetrieve list of output URLs.\nThe result_urls() method calls wait_for_processing() and returns a list of the processed data URLs once processing is complete. You may optionally show the progress bar as shown below.\n#\nWe can see that the first file returned does not include the _subsetted suffix, which indicates that a blank file was returned, as no data values were located within our subsetted region. We’ll select the second URL in the list to bring into xarray below.\n#\n\n\nAWS credential retrieval\nUsing aws_credentials you can retrieve the credentials needed to access the Harmony s3 staging bucket and its contents.\n#\n\n\n\nOpen staged files with s3fs and xarray\nWe use the AWS s3fs package to create a file system that can then be read by xarray:\n#\n\n\n**Note, Ideally, we’d show how to bring in all files into a single xarray ds but I’m getting an error:\n#\nNow that we have our s3 file system set, including our declared credentials, we’ll use that to open the url, and read in the file through xarray:\n#\n\n\nPlot the data\n#\n\n\nExtra code attempting to read in directly from s3 into xarray:\n#"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#using-the-harmony-py-library-to-access-customized-data-from-nasa-earthdata",
    "title": "",
    "section": "Using the Harmony-Py library to access customized data from NASA Earthdata",
    "text": ""
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#summary",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Harmony allows you to seamlessly analyze Earth observation data from different NASA data centers… https://harmony.earthdata.nasa.gov/\n\nBenefits\n\nConsistent access patterns to EOSDIS holdings make cross-data center data access easier\nData reduction services allow users to request only the data they want, in the format and projection they want\nAnalysis Ready Data and cloud access will help reduce time-to-science\nCommunity Development helps reduce the barriers for re-use of code and sharing of domain knowledge\n\nHarmony-Py is a Python library for integrating with NASA’s Harmony Services.\nHarmony-Py provides a Python alternative to directly using Harmony’s RESTful API. It handles NASA Earthdata Login (EDL) authentication and optionally integrates with the CMR Python Wrapper by accepting collection results as a request parameter. It’s convenient for scientists who wish to use Harmony from Jupyter notebooks as well as machine-to-machine communication with larger Python applications.\n\n\nObjectives\n\nPractice skills learned from intro to CMR tutorial to discover what access and service options exist for a given data set"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#import-packages",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#import-packages",
    "title": "",
    "section": "Import Packages",
    "text": "#"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#discover-service-options-for-a-given-data-set",
    "title": "",
    "section": "Discover service options for a given data set",
    "text": "First, what do we mean by a “service”? [TODO] Describe how we define services and their benefits, and how not all datasets have services on them due to level of support, etc….\nLet’s see what the collection metadata tells us\n\nBuilding off of CMR introduction tutorial:\n#\nWe want to search by collection to inspect the access and service options that exist:\n#\nIn the CMR introduction tutorial, we explored cloud-hosted collections from different DAAC providers, and identified the CMR concept-id for a given data set id (also referred to as a short_name).\nHere we are jumping ahead and already know the concept_id we are interested in, by browsing cloud-hosted datasets from PO.DAAC in Earthdata Search: https://search.earthdata.nasa.gov/portal/podaac-cloud/search.\nWe are going to focus on MODIS_A-JPL-L2P-v2019.0: GHRSST Level 2P Global Sea Surface Skin Temperature from the Moderate Resolution Imaging Spectroradiometer (MODIS) on the NASA Aqua satellite (GDS2). Let’s first save this as a variable that we can use later on once we request data from Harmony.\n#\nWe will view the top-level metadata for this collection to see what additional service and variable metadata exist.\n#\nPrint the response:\n#\nLet’s walk through what each of these service values mean:\n\nAssociations\n\nCMR is a large web of interconnected metadata “schemas”, including Collections, Granules, Services, Tools, and Variables. In this case, this collection is associated with two unique services, two tools, and several unique variables.\n\nTags\n\nThere are also tags that describe what service options exist at a high-level. In this case, we see that this dataset supports the ability to reformat, subset by space and time, as well as by variable. This is used in web applications like Earthdata Search to surface those customization options more readily.\n\nService Features\n\nIn this case, we see three separate “features” listed here: esi, Harmony, and OPeNDAP.\n\n\nWe will dig into more details on what Harmony offers for this dataset.\nFirst, we need to isolate the services returned for this dataset:\n#\n#\nInspect the first service returned. Now we’re going to search the services endpoint to view that individual service’s metadata, like we did with our dataset above.\nTODO: Explain why we need the output format in umm_json\n#\n#\n#\nTODO: Describe these different service options and broader Harmony / backend subsetter context."
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#discover-variable-names",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#discover-variable-names",
    "title": "",
    "section": "Discover variable names",
    "text": "TODO: Could this be an “exercise” to gain more familiarity with CMR?\n#\n#\n#\n#\nLet’s print out a simple list of all associated variable names.\n#\n#"
  },
  {
    "objectID": "tutorials-templates/Data_Access__Harmony_Subsetting.html#harmony-py-set-up",
    "href": "tutorials-templates/Data_Access__Harmony_Subsetting.html#harmony-py-set-up",
    "title": "",
    "section": "Harmony-Py set up",
    "text": "[TODO] Describe Harmony-Py in more detail (connection between the library and the API).\nNext steps adopted from the intro tutorial notebook in the Harmony-Py library: https://github.com/nasa/harmony-py/blob/main/examples/intro_tutorial.ipynb\n\nCreate Harmony Client object\nFirst, we need to create a Harmony Client, which is what we will interact with to submit and inspect a data request to Harmony, as well as to retrieve results.\nWhen creating the Client, we need to provide Earthdata Login credentials, which are required to access data from NASA EOSDIS. This basic line below assumes that we have a .netrc available.\n#\n\n\nCreate Harmony Request\nThe following are common request parameters:\n\ncollection: Required parameter. This is the NASA EOSDIS collection, or data product. There are two options for inputting a collection of interest:\n\nProvide a concept ID, which is an ID provided in the Common Metadata Repository (CMR) metadata\nData product short name (e.g. SENTINEL-1_INTERFEROGRAMS).\n\nspatial: Bounding box spatial constraints on the data. The Harmony Bbox class accepts spatial coordinates as decimal degrees in w, s, e, n order, where longitude = -180, 180 and latitude = -90, 90.\ntemporal: Date/time constraints on the data. The example below demonstrates temporal start and end ranges using the python datetime library.\n\nOther advanced parameters that may be of interest. Note that many reformatting or advanced projection options may not be available for your requested dataset. See the documentation for details on how to construct these parameters.\n[TODO] Describe area/time use case with this dataset - maybe demonstrating Earthdata Search for browsing??\n#\n\n\nCheck Request validity\nBefore submitting a Harmony Request, we can test your request to see if it’s valid and how to fix it if not. In particular, request.is_valid will check to ensure that the spatial BBox bounds and temporal ranges are entered correctly.\n#\n\n\nSubmit request\nNow that the request is created, we can now submit it to Harmony using the Harmony Client object. A job id is returned, which is a unique identifier that represents the submitted request.\n#\n\n\nCheck request status\nWe can check on the progress of a processing job with status(). This method blocks while communicating with the server but returns quickly.\n#\nDepending on the size of the request, it may be helpful to wait until the request has completed processing before the remainder of the code is executed. The wait_for_processing() method will block subsequent lines of code while optionally showing a progress bar.\n#\n\n\nView Harmony job response and output URLs\nOnce the data request has finished processing, we can view details on the job that was submitted to Harmony, including the API call to Harmony, and informational messages on the request if available.\nresult_json() calls wait_for_processing() and returns the complete job in JSON format once processing is complete.\n#\n\n\nDirect cloud access\nNote that the remainder of this tutorial will only succeed when running this notebook within the AWS us-west-2 region.\nHarmony data outputs can be accessed within the cloud using the s3 URLs and AWS credentials provided in the Harmony job response.\n\nRetrieve list of output URLs.\nThe result_urls() method calls wait_for_processing() and returns a list of the processed data URLs once processing is complete. You may optionally show the progress bar as shown below.\n#\nWe can see that the first file returned does not include the _subsetted suffix, which indicates that a blank file was returned, as no data values were located within our subsetted region. We’ll select the second URL in the list to bring into xarray below.\n#\n\n\nAWS credential retrieval\nUsing aws_credentials you can retrieve the credentials needed to access the Harmony s3 staging bucket and its contents.\n#\n\n\n\nOpen staged files with s3fs and xarray\nWe use the AWS s3fs package to create a file system that can then be read by xarray:\n#\n\n\n**Note, Ideally, we’d show how to bring in all files into a single xarray ds but I’m getting an error:\n#\nNow that we have our s3 file system set, including our declared credentials, we’ll use that to open the url, and read in the file through xarray:\n#\n\n\nPlot the data\n#\n\n\nExtra code attempting to read in directly from s3 into xarray:\n#"
  },
  {
    "objectID": "cloud-paradigm.html",
    "href": "cloud-paradigm.html",
    "title": "Cloud Paradigm",
    "section": "",
    "text": "Slides that introduce NASA Earthdata Cloud & the Cloud Paradigm."
  },
  {
    "objectID": "projects/hackathon-projects.html",
    "href": "projects/hackathon-projects.html",
    "title": "Hackathon Projects",
    "section": "",
    "text": "We’ll add information about hackathon projects as they develop!"
  },
  {
    "objectID": "projects/projects-overview.html#purpose-of-the-projects",
    "href": "projects/projects-overview.html#purpose-of-the-projects",
    "title": "Projects Overview",
    "section": "Purpose of the projects:",
    "text": "During the Cloud Hackathon we will be facilitating team hacking sessions in the second half of each day. The purpose of these sessions is for you to gain hands-on experience in working together on a well-defined problem, in a collaborative space where you can talk things through and get help."
  },
  {
    "objectID": "projects/projects-overview.html#what-is-hacking",
    "href": "projects/projects-overview.html#what-is-hacking",
    "title": "Projects Overview",
    "section": "What is hacking?",
    "text": "Hacking is a session of focused, highly collaborative work time – often involving coding – in which the group creates conditions for rapid absorption of new ideas and methods. The word “hack” or “hackathon” has many different interpretations, both positive and negative. Here our intention is to foster the idea of hacking as a fun, interactive and welcoming environment to explore and experiment with computer code."
  },
  {
    "objectID": "projects/projects-overview.html#how-will-the-projects-be-conducted",
    "href": "projects/projects-overview.html#how-will-the-projects-be-conducted",
    "title": "Projects Overview",
    "section": "How will the projects be conducted?",
    "text": "Participants are invited to start conversations about projects in the Slack channel 2021-nasacloudhack-projects one week before the Cloud Hackathon begins.\n\nIf you have a project idea brewing, please pitch it in this channel (even if you have signed up for the cloud hackathon as a team; tag your proposed teammates if you already have that worked out).\nStart a thread with “Project idea:” and then provide a few sentences. Include whether you are looking for teammates to join this project. Others who are interested can respond in a thread.\nWe welcome a broad range of project topics. People often use project time to dig deeper into concepts introduced in tutorials, to explore problems within their own research, or to advance community data sharing and software building efforts.\nThe Cloud Hackathon team is here to help you get clear on project ideas and decide on what is possible within 5 days. Feel free to reach out to any of us between now and the Cloud Hackathon in the 2021-nasacloudhack-help channel, or @ us – we all have “helper” appended to the front of our names. !\n\nAt the end of Day 1 of the Cloud Hackathon we will have a Pitchfest where proposer(s) can pitch their idea, and mention whether they are still looking for teammates or if they have already formed a team using the Slack _#2021-nasacloudhack-projects _channel. At this time we will finalize the project teams for the week.\nTeam hacktime will begin on Day 2.\nEach team is encouraged to identify a project lead, likely the person who pitched the idea, who has knowledge of the datasets and the specific problem to be explored. But roles can be assigned as the group decides to best fit skills and needs.\nThroughout the hackathon we will have optional morning office hours 8-9am PT for additional support or team check-in time.\nOn the final day of the Cloud Hackathon, each team will present their work in a series of lightning talks."
  },
  {
    "objectID": "projects/projects-overview.html#what-can-i-do-to-prepare-in-advance",
    "href": "projects/projects-overview.html#what-can-i-do-to-prepare-in-advance",
    "title": "Projects Overview",
    "section": "What can I do to prepare in advance?",
    "text": "If you have a project idea already brewing, we encourage you to share that with participants on our Slack channel 2021-nasacloudhack-projects.\nFeel free to explore various projects and initiate conversations. The goal is to gather as much information as you can to inform your decision about which team to join during the Cloud Hackathon"
  },
  {
    "objectID": "projects/projects-overview.html#how-to-start-hacking",
    "href": "projects/projects-overview.html#how-to-start-hacking",
    "title": "Projects Overview",
    "section": "How to start hacking",
    "text": "Suggestions for how to set up your GitHub workflow is in the GitHub Workflows section.\nThis is a great slide deck for collaborating on project teamwork collaborating from SnowEx Hackweek."
  },
  {
    "objectID": "external/zarr-eosdis-store.html",
    "href": "external/zarr-eosdis-store.html",
    "title": "",
    "section": "",
    "text": "Zarr Example\nimported on: 2021-11-14\n\nThis notebook is from NASA’s Zarr EOSDIS store notebook\n\n\nThe original source for this document is https://github.com/nasa/zarr-eosdis-store\n\n\n\nzarr-eosdis-store example\nInstall dependencies\nimport sys\n\n# zarr and zarr-eosdis-store, the main libraries being demoed\n!{sys.executable} -m pip install zarr zarr-eosdis-store\n\n# Notebook-specific libraries\n!{sys.executable} -m pip install matplotlib\nImportant: To run this, you must first create an Earthdata Login account (https://urs.earthdata.nasa.gov) and place your credentials in ~/.netrc e.g.:\n   machine urs.earthdata.nasa.gov login YOUR_USER password YOUR_PASSWORD\nNever share or commit your password / .netrc file!\nBasic usage. After these lines, we work with ds as though it were a normal Zarr dataset\nimport zarr\nfrom eosdis_store import EosdisStore\n\nurl = 'https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20210715090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc'\n\nds = zarr.open(EosdisStore(url))\nView the file’s variable structure\n\nprint(ds.tree())\n\n/\n ├── analysed_sst (1, 17999, 36000) int16\n ├── analysis_error (1, 17999, 36000) int16\n ├── dt_1km_data (1, 17999, 36000) int16\n ├── lat (17999,) float32\n ├── lon (36000,) float32\n ├── mask (1, 17999, 36000) int16\n ├── sea_ice_fraction (1, 17999, 36000) int16\n ├── sst_anomaly (1, 17999, 36000) int16\n └── time (1,) int32\n\n\nFetch the latitude and longitude arrays and determine start and end indices for our area of interest. In this case, we’re looking at the Great Lakes, which have a nice, recognizeable shape. Latitudes 41 to 49, longitudes -93 to 76.\nlats = ds['lat'][:]\nlons = ds['lon'][:]\nlat_range = slice(lats.searchsorted(41), lats.searchsorted(49))\nlon_range = slice(lons.searchsorted(-93), lons.searchsorted(-76))\nGet the analysed sea surface temperature variable over our area of interest and apply scale factor and offset from the file metadata. In a future release, scale factor and add offset will be automatically applied.\nvar = ds['analysed_sst']\nanalysed_sst = var[0, lat_range, lon_range] * var.attrs['scale_factor'] + var.attrs['add_offset']\nDraw a pretty picture\n\nfrom matplotlib import pyplot as plt\n\nplt.rcParams[\"figure.figsize\"] = [16, 8]\nplt.imshow(analysed_sst[::-1, :])\nNone\n\n\n\n\nIn a dozen lines of code and a few seconds, we have managed to fetch and visualize the 3.2 megabyte we needed from a 732 megabyte file using the original archive URL and no processing services"
  },
  {
    "objectID": "external/cof-zarr-reformat.html#getting-started",
    "href": "external/cof-zarr-reformat.html#getting-started",
    "title": "",
    "section": "Getting Started",
    "text": "We will access monthly ocean bottom pressure (OBP) data from ECCO V4r4 (10.5067/ECG5M-OBP44), which are provided as a monthly time series on a 0.5-degree latitude/longitude grid.\nThe data are archived in netCDF format. However, this notebook demonstration will request conversion to Zarr format for files covering the period between 2010 and 2018. Upon receiving our request, Harmony’s backend will convert the files and stage them in S3 for native access in AWS (us-west-2 region, specifically). We will access the new Zarr datasets as an aggregated dataset using xarray, and leverage the S3 native protocols for direct access to the data in an efficient manner.\n\n\nRequirements\n\nAWS\nThis notebook should be running in an EC2 instance in AWS region us-west-2, as previously mentioned. We recommend using an EC2 with at least 8GB of memory available.\nThe notebook was developed and tested using a t2.large instance (2 cpus; 8GB memory).\n\n\nPython 3\nMost of these imports are from the Python standard library. However, you will need to install these packages into your Python 3 environment if you have not already done so:\n\ns3fs\nrequests\npandas\nxarray\nmatplotlib\n\n\n\n\nRequirements\nimport matplotlib.pyplot as plt\nimport xarray as xr\nimport pandas as pd\nimport numpy as np\nimport requests\nimport json\nimport time\nimport s3fs\n\nShortName = \"ECCO_L4_OBP_05DEG_MONTHLY_V4R4\"\n\n\nStudy period\nSet some “master” inputs to define the time and place contexts for our case studies in the ipynb. This example will be requesting time subsets and receiving global data back from the Harmony API.\nstart_date = \"2010-01-01\"\nend_date   = \"2018-12-31\"\n\n\nData Access\nSome features in the Harmony API require us to identify the target dataset/collection by its concept-id (which uniquely idenfifies it among the other datasets in the Common Metadata Repository). Support for selection by the dataset ShortName will be added in a future release.\n\nCommon Metadata Repository (CMR)\nFor now, we will need to get the concept-id that corresponds to our dataset by accessing its metadata from the CMR. Read more about the CMR at: https://cmr.earthdata.nasa.gov/\nRequest the UMM Collection metadata (i.e. metadata about the dataset) from the CMR and select the concept-id as a new variable ccid.\n\nresponse = requests.get(\n    url='https://cmr.earthdata.nasa.gov/search/collections.umm_json', \n    params={'provider': \"POCLOUD\",\n            'ShortName': ShortName,\n            'page_size': 1}\n)\n\nummc = response.json()['items'][0]\n\nccid = ummc['meta']['concept-id']\n\nccid\n\n'C1990404791-POCLOUD'\n\n\n\n\nHarmony API\nAnd get the Harmony API endpoint and zarr parameter like we did for SMAP before:\n\nbase = f\"https://harmony.earthdata.nasa.gov/{ccid}\"\nhreq = f\"{base}/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset\"\nrurl = f\"{hreq}?format=application/x-zarr\"\n\nprint(rurl)\n\nhttps://harmony.earthdata.nasa.gov/C1990404791-POCLOUD/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?format=application/x-zarr\n\n\nECCO monthly collections have 312 granules in V4r4 (you can confirm with the granule listing from CMR Search API) so we can get the entire time series for 2010 to 2018 with one request to the Harmony API.\nFormat a string of query parameters to limit the processing to the desired time period. Then, append the string of time subset parameters to the variable rurl.\n\nsubs = '&'.join([f'subset=time(\"{start_date}T00:00:00.000Z\":\"{end_date}T23:59:59.999Z\")'])\n\nrurl = f\"{rurl}&{subs}\"\n\nprint(rurl)\n\nhttps://harmony.earthdata.nasa.gov/C1990404791-POCLOUD/ogc-api-coverages/1.0.0/collections/all/coverage/rangeset?format=application/x-zarr&subset=time(\"2010-01-01T00:00:00.000Z\":\"2018-12-31T23:59:59.999Z\")\n\n\nSubmit the request and monitor the processing status in a while loop, breaking it on completion of the request job:\n\nresponse = requests.get(url=rurl).json()\n\n# Monitor status in a while loop. Wait 10 seconds for each check.\nwait = 10\nwhile True:\n    response = requests.get(url=response['links'][0]['href']).json()\n    if response['status']!='running':\n        break\n    print(f\"Job in progress ({response['progress']}%)\")\n    time.sleep(wait)\n\nprint(\"DONE!\")\n\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nJob in progress (0%)\nDONE!\n\n\nAccess the staged cloud datasets over native AWS interfaces\nCheck the message field in the response for clues about how to proceed:\n\nprint(response['message'])\n\nThe job has completed successfully. Contains results in AWS S3. Access from AWS us-west-2 with keys from https://harmony.earthdata.nasa.gov/cloud-access.sh\n\n\nThe third item in the list of links contains the shell script from the job status message printed above. Let’s download the same information in JSON format. It should be the fourth item; check to be sure:\n\nlen(response['links'])\n\n102\n\n\nSelect the url and download the json, then load to Python dictionary and print the keys:\n\nwith requests.get(response['links'][3]['href']) as r:\n    creds = r.json()\n\nprint(creds.keys())\n\ndict_keys(['AccessKeyId', 'SecretAccessKey', 'SessionToken', 'Expiration'])\n\n\nCheck the expiration timestamp for the temporary credentials:\n\ncreds['Expiration']\n\n'2021-06-11T02:36:29.000Z'\n\n\nOpen zarr datasets with s3fs and xarray\nGet the s3 output directory and list of zarr datasets from the list of links. The s3 directory should be the fifth item; the urls are from item six onward:\n\ns3_dir = response['links'][4]['href']\n\nprint(s3_dir)\n\ns3://harmony-prod-staging/public/harmony/netcdf-to-zarr/2295236b-8086-4543-9482-f524a9f2d0c3/\n\n\nNow select the URLs for the staged files and print the first one:\n\ns3_urls = [u['href'] for u in response['links'][5:]]\n\nprint(s3_urls[0])\n\ns3://harmony-prod-staging/public/harmony/netcdf-to-zarr/2295236b-8086-4543-9482-f524a9f2d0c3/OCEAN_BOTTOM_PRESSURE_mon_mean_2009-12_ECCO_V4r4_latlon_0p50deg.zarr\n\n\nUse the AWS s3fs package and your temporary aws_creds to open the zarr directory storage:\n\ns3 = s3fs.S3FileSystem(\n    key=creds['AccessKeyId'],\n    secret=creds['SecretAccessKey'],\n    token=creds['SessionToken'],\n    client_kwargs={'region_name':'us-west-2'},\n)\n\nlen(s3.ls(s3_dir))\n\n97\n\n\nPlot the first Ocean Bottom Pressure dataset\nCheck out the documentation for xarray’s open_zarr method at this link. Open the first dataset and plot the OBP variable:\n\nds0 = xr.open_zarr(s3.get_mapper(s3_urls[0]), decode_cf=True, mask_and_scale=True)\n\n# Mask the dataset where OBP is not within the bounds of the variable's valid min/max:\nds0_masked = ds0.where((ds0.OBP>=ds0.OBP.valid_min) & (ds0.OBP<=ds0.OBP.valid_max))\n\n# Plot the masked dataset\nds0_masked.OBP.isel(time=0).plot.imshow(size=10)\n\n<matplotlib.image.AxesImage at 0x7f28ed2ba4c0>\n\n\n\n\n\nLoad the zarr datasets into one large xarray dataset\nLoad all the datasets in a loop and concatenate them:\n\nzds = xr.concat([xr.open_zarr(s3.get_mapper(u)) for u in s3_urls], dim=\"time\")\n\nprint(zds)\n\n<xarray.Dataset>\nDimensions:         (latitude: 360, longitude: 720, nv: 2, time: 97)\nCoordinates:\n  * latitude        (latitude) float64 -89.75 -89.25 -88.75 ... 89.25 89.75\n    latitude_bnds   (latitude, nv) float64 -90.0 -89.5 -89.5 ... 89.5 89.5 90.0\n  * longitude       (longitude) float64 -179.8 -179.2 -178.8 ... 179.2 179.8\n    longitude_bnds  (longitude, nv) float64 -180.0 -179.5 -179.5 ... 179.5 180.0\n  * time            (time) datetime64[ns] 2009-12-16T12:00:00 ... 2017-12-16T...\n    time_bnds       (time, nv) datetime64[ns] dask.array<chunksize=(1, 2), meta=np.ndarray>\nDimensions without coordinates: nv\nData variables:\n    OBP             (time, latitude, longitude) float64 dask.array<chunksize=(1, 360, 720), meta=np.ndarray>\n    OBPGMAP         (time, latitude, longitude) float64 dask.array<chunksize=(1, 360, 720), meta=np.ndarray>\nAttributes: (12/57)\n    Conventions:                  CF-1.8, ACDD-1.3\n    acknowledgement:              This research was carried out by the Jet Pr...\n    author:                       Ian Fenty and Ou Wang\n    cdm_data_type:                Grid\n    comment:                      Fields provided on a regular lat-lon grid. ...\n    coordinates_comment:          Note: the global 'coordinates' attribute de...\n    ...                           ...\n    time_coverage_duration:       P1M\n    time_coverage_end:            2010-01-01T00:00:00\n    time_coverage_resolution:     P1M\n    time_coverage_start:          2009-12-01T00:00:00\n    title:                        ECCO Ocean Bottom Pressure - Monthly Mean 0...\n    uuid:                         297c8df0-4158-11eb-b208-0cc47a3f687b\n\n\nReference OBP and mask the dataset according to the valid minimum and maximum:\n\nobp = zds.OBP\n\nprint(obp)\n\n<xarray.DataArray 'OBP' (time: 97, latitude: 360, longitude: 720)>\ndask.array<concatenate, shape=(97, 360, 720), dtype=float64, chunksize=(1, 360, 720), chunktype=numpy.ndarray>\nCoordinates:\n  * latitude   (latitude) float64 -89.75 -89.25 -88.75 ... 88.75 89.25 89.75\n  * longitude  (longitude) float64 -179.8 -179.2 -178.8 ... 178.8 179.2 179.8\n  * time       (time) datetime64[ns] 2009-12-16T12:00:00 ... 2017-12-16T06:00:00\nAttributes:\n    comment:                OBP excludes the contribution from global mean at...\n    coverage_content_type:  modelResult\n    long_name:              Ocean bottom pressure given as equivalent water t...\n    units:                  m\n    valid_max:              72.07011413574219\n    valid_min:              -1.7899188995361328\n\n\nGet the valid min and max from the corresponding CF attributes:\n\nobp_vmin, obp_vmax = obp.valid_min, obp.valid_max\n\nobp_vmin, obp_vmax\n\n(-1.7899188995361328, 72.07011413574219)\n\n\nMask the dataset according to the OBP min and max and plot a series:\n\n# Mask dataset where not inside OBP variable valid min/max:\nzds_masked = zds.where((obp>=obp_vmin)&(obp<=obp_vmax))\n\n# Plot SSH again for the first 12 time slices:\nobpp = zds_masked.OBP.isel(time=slice(0, 6)).plot(\n    x=\"longitude\", \n    y=\"latitude\", \n    col=\"time\",\n    levels=8,\n    col_wrap=3, \n    add_colorbar=False,\n    figsize=(14, 8)\n)\n\n# Plot a colorbar on a secondary axis\nmappable = obpp.axes[0][0].collections[0]\ncax = plt.axes([0.05, -0.04, 0.95, 0.04])\ncbar1 = plt.colorbar(mappable, cax=cax, orientation='horizontal')"
  }
]